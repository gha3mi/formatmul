var tipuesearch = {"pages":[{"title":" ForMatmul ","text":"ForMatmul ForMatmul : A Fortran library that overloads the matmul function to enable efficient matrix multiplication with coarray. Usage use formatmul c = matmul ( a , b , method = 'coarray' , option = 'm1' ) fpm dependency If you want to use ForMatmul as a dependency in your own fpm project,\nyou can easily include it by adding the following line to your fpm.toml file: [dependencies] formatmul = { git = \"https://github.com/gha3mi/formatmul.git\" } How to run tests and examples Clone the repository: You can clone the ForMatmul repository from GitHub using the following command: git clone https://github.com/gha3mi/formatmul.git cd formatmul Run tests: Tested with Intel compiler: ifort (IFORT) 2021.10.0 20230609 fpm @ifort-test fpm @ifort-test-coarray Tested with Intel compiler: ifx (IFX) 2023.2.0 20230622 fpm @ifx-test fpm @ifx-test-coarray Tested with GNU compiler: GNU Fortran (GCC) 13.1.0 fpm @gfortran-test Run examples: To set the stack size to unlimited, use the following command: ulimit -s unlimited . You have the option to modify the number of images in the fpm.rsp file by using the flag -coarray-num-images=N . fpm @ifort-example fpm @ifort-example-coarray fpm @ifx-example fpm @ifx-example-coarray fpm @gfortran-example Results with -coarray-num-images=4 : Elapsed time ( example1: mat_mat ) : 1 .175 [ s ] Elapsed time ( example2: mat_mat, coarray ) : 0 .269 [ s ] Elapsed time ( example2: mat_mat, coarray ) : 0 .272 [ s ] Elapsed time ( example2: mat_mat, coarray ) : 0 .274 [ s ] Elapsed time ( example2: mat_mat, coarray ) : 0 .275 [ s ] Elapsed time ( example3: mat_vec ) : 0 .047 [ s ] Elapsed time ( example4: mat_vec, coarray ) : 0 .012 [ s ] Elapsed time ( example4: mat_vec, coarray ) : 0 .012 [ s ] Elapsed time ( example4: mat_vec, coarray ) : 0 .012 [ s ] Elapsed time ( example4: mat_vec, coarray ) : 0 .012 [ s ] Benchmark: To set the stack size to unlimited, use the following command: ulimit -s unlimited . Intel Fortran Compiler (ifort) fpm run --example benchmark3 --compiler ifort --flag \"-Ofast -xHost -qopenmp -qmkl -coarray -coarray-num-images=4 -DUSE_COARRAY\" Intel Fortran Compiler (ifx) fpm run --example benchmark3 --compiler ifx --flag \"-Ofast -xHost -qopenmp -qmkl -coarray -coarray-num-images=4 -DUSE_COARRAY\" You can then use the provided Python script to generate visual plots for the benchmark3 data: python benchmark/benchmark3.py Results obtained on an Intel(R) Core(TM) i9-9980HK CPU @ 2.40GHz using ifort (IFORT) 2021.10.0 20230609 are as follows: with -coarray-num-images=4 , MKL_NUM_THREADS=1 and OMP_NUM_THREADS=1 : with -coarray-num-images=4 and Multithread: with -coarray-num-images=5 , MKL_NUM_THREADS=1 and OMP_NUM_THREADS=1 : with -coarray-num-images=5 and Multithread: with -coarray-num-images=6 , MKL_NUM_THREADS=1 and OMP_NUM_THREADS=1 : with -coarray-num-images=6 and Multithread: API documentation The most up-to-date API documentation for the master branch is available here .\nTo generate the API documentation for ForMatmul using ford run the following\ncommand: ford ford.yml Contributing Contributions to ForMatmul are welcome!\nIf you find any issues or would like to suggest improvements, please open an issue. Developer Info Seyed Ali Ghasemi","tags":"home","loc":"index.html"},{"title":"impure_mm_12 – ForMatmul","text":"impure subroutine impure_mm_12(m, n, p, a, b, c) Uses kinds proc~~impure_mm_12~~UsesGraph proc~impure_mm_12 formatmul_opts.f90::impure_mm_12 kinds kinds proc~impure_mm_12->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: p real(kind=rk), intent(in) :: a (m,n) real(kind=rk), intent(in) :: b (n,p) real(kind=rk), intent(out) :: c (m,p) Source Code pure subroutine impure_mm_12 ( f_m , f_n , f_p , f_a , f_b , f_c ) import rk integer , intent ( in ) :: f_m , f_n , f_p real ( rk ), intent ( in ) :: f_a ( f_m , f_n ), f_b ( f_n , f_p ) real ( rk ), intent ( out ) :: f_c ( f_m , f_p ) end subroutine impure_mm_12","tags":"","loc":"proc/impure_mm_12.html"},{"title":"impure_mm_13 – ForMatmul","text":"impure subroutine impure_mm_13(m, n, p, a, b, c) Uses kinds proc~~impure_mm_13~~UsesGraph proc~impure_mm_13 formatmul_opts.f90::impure_mm_13 kinds kinds proc~impure_mm_13->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: p real(kind=rk), intent(in) :: a (m,n) real(kind=rk), intent(in) :: b (n,p) real(kind=rk), intent(out) :: c (m,p) Source Code pure subroutine impure_mm_13 ( f_m , f_n , f_p , f_a , f_b , f_c ) import rk integer , intent ( in ) :: f_m , f_n , f_p real ( rk ), intent ( in ) :: f_a ( f_m , f_n ), f_b ( f_n , f_p ) real ( rk ), intent ( out ) :: f_c ( f_m , f_p ) end subroutine impure_mm_13","tags":"","loc":"proc/impure_mm_13.html"},{"title":"matmul_mat_mat_rel_opts – ForMatmul","text":"private pure function matmul_mat_mat_rel_opts(A, B, option) result(C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) character(len=*), intent(in) :: option Return Value real(kind=rk), (size(A,1),size(B,2)) Calls proc~~matmul_mat_mat_rel_opts~~CallsGraph proc~matmul_mat_mat_rel_opts formatmul_opts::matmul_mat_mat_rel_opts interface~matmul_blas formatmul_opts::matmul_blas proc~matmul_mat_mat_rel_opts->interface~matmul_blas proc~mm_10 formatmul_opts::mm_10 proc~matmul_mat_mat_rel_opts->proc~mm_10 proc~mm_11 formatmul_opts::mm_11 proc~matmul_mat_mat_rel_opts->proc~mm_11 proc~mm_12 formatmul_opts::mm_12 proc~matmul_mat_mat_rel_opts->proc~mm_12 proc~mm_13 formatmul_opts::mm_13 proc~matmul_mat_mat_rel_opts->proc~mm_13 proc~mm_9 formatmul_opts::mm_9 proc~matmul_mat_mat_rel_opts->proc~mm_9 proc~mm_mnp formatmul_opts::mm_mnp proc~matmul_mat_mat_rel_opts->proc~mm_mnp proc~mm_mpn formatmul_opts::mm_mpn proc~matmul_mat_mat_rel_opts->proc~mm_mpn proc~mm_nmp formatmul_opts::mm_nmp proc~matmul_mat_mat_rel_opts->proc~mm_nmp proc~mm_npm formatmul_opts::mm_npm proc~matmul_mat_mat_rel_opts->proc~mm_npm proc~mm_pmn formatmul_opts::mm_pmn proc~matmul_mat_mat_rel_opts->proc~mm_pmn proc~mm_pnm formatmul_opts::mm_pnm proc~matmul_mat_mat_rel_opts->proc~mm_pnm proc~gemm_mat_mat_rel formatmul_opts::gemm_mat_mat_rel interface~matmul_blas->proc~gemm_mat_mat_rel proc~gemv_mat_vec_rel formatmul_opts::gemv_mat_vec_rel interface~matmul_blas->proc~gemv_mat_vec_rel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~matmul_mat_mat_rel_opts~~CalledByGraph proc~matmul_mat_mat_rel_opts formatmul_opts::matmul_mat_mat_rel_opts interface~matmul_opts formatmul_opts::matmul_opts interface~matmul_opts->proc~matmul_mat_mat_rel_opts proc~mat_mat formatmul::mat_mat proc~mat_mat->interface~matmul_opts proc~mat_vec formatmul::mat_vec proc~mat_vec->interface~matmul_opts interface~matmul formatmul::matmul interface~matmul->proc~mat_mat interface~matmul->proc~mat_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function matmul_mat_mat_rel_opts ( A , B , option ) result ( C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) character ( * ), intent ( in ) :: option real ( rk ) :: C ( size ( A , 1 ), size ( B , 2 )) select case ( option ) case ( 'm1' ) C = matmul ( A , B ) case ( 'm2' ) C = matmul_blas ( A , B ) case ( 'm3' ) call mm_mnp ( size ( A , 1 ), size ( A , 2 ), size ( B , 2 ), A , B , C ) case ( 'm4' ) call mm_mpn ( size ( A , 1 ), size ( A , 2 ), size ( B , 2 ), A , B , C ) case ( 'm5' ) call mm_nmp ( size ( A , 1 ), size ( A , 2 ), size ( B , 2 ), A , B , C ) case ( 'm6' ) call mm_npm ( size ( A , 1 ), size ( A , 2 ), size ( B , 2 ), A , B , C ) case ( 'm7' ) call mm_pmn ( size ( A , 1 ), size ( A , 2 ), size ( B , 2 ), A , B , C ) case ( 'm8' ) call mm_pnm ( size ( A , 1 ), size ( A , 2 ), size ( B , 2 ), A , B , C ) case ( 'm9' ) call mm_9 ( size ( A , 1 ), size ( A , 2 ), size ( B , 2 ), A , B , C ) case ( 'm10' ) call mm_10 ( size ( A , 1 ), size ( A , 2 ), size ( B , 2 ), A , B , C ) case ( 'm11' ) call mm_11 ( size ( A , 1 ), size ( A , 2 ), size ( B , 2 ), A , B , C ) case ( 'm12' ) call mm_12 ( size ( A , 1 ), size ( A , 2 ), size ( B , 2 ), A , B , C ) case ( 'm13' ) call mm_13 ( size ( A , 1 ), size ( A , 2 ), size ( B , 2 ), A , B , C ) case default C = matmul ( A , B ) end select end function matmul_mat_mat_rel_opts","tags":"","loc":"proc/matmul_mat_mat_rel_opts.html"},{"title":"matmul_mat_vec_rel_opts – ForMatmul","text":"private pure function matmul_mat_vec_rel_opts(A, v, option) result(w) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) character(len=*), intent(in) :: option Return Value real(kind=rk), (size(A,1)) Calls proc~~matmul_mat_vec_rel_opts~~CallsGraph proc~matmul_mat_vec_rel_opts formatmul_opts::matmul_mat_vec_rel_opts interface~matmul_blas formatmul_opts::matmul_blas proc~matmul_mat_vec_rel_opts->interface~matmul_blas proc~mv_3 formatmul_opts::mv_3 proc~matmul_mat_vec_rel_opts->proc~mv_3 proc~mv_4 formatmul_opts::mv_4 proc~matmul_mat_vec_rel_opts->proc~mv_4 proc~mv_5 formatmul_opts::mv_5 proc~matmul_mat_vec_rel_opts->proc~mv_5 proc~mv_6 formatmul_opts::mv_6 proc~matmul_mat_vec_rel_opts->proc~mv_6 proc~gemm_mat_mat_rel formatmul_opts::gemm_mat_mat_rel interface~matmul_blas->proc~gemm_mat_mat_rel proc~gemv_mat_vec_rel formatmul_opts::gemv_mat_vec_rel interface~matmul_blas->proc~gemv_mat_vec_rel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~matmul_mat_vec_rel_opts~~CalledByGraph proc~matmul_mat_vec_rel_opts formatmul_opts::matmul_mat_vec_rel_opts interface~matmul_opts formatmul_opts::matmul_opts interface~matmul_opts->proc~matmul_mat_vec_rel_opts proc~mat_mat formatmul::mat_mat proc~mat_mat->interface~matmul_opts proc~mat_vec formatmul::mat_vec proc~mat_vec->interface~matmul_opts interface~matmul formatmul::matmul interface~matmul->proc~mat_mat interface~matmul->proc~mat_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function matmul_mat_vec_rel_opts ( A , v , option ) result ( w ) real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) character ( * ), intent ( in ) :: option real ( rk ) :: w ( size ( A , 1 )) select case ( option ) case ( 'm1' ) w = matmul ( A , v ) case ( 'm2' ) w = matmul_blas ( A , v ) case ( 'm3' ) call mv_3 ( size ( A , 1 ), size ( A , 2 ), A , v , w ) case ( 'm4' ) call mv_4 ( size ( A , 1 ), size ( A , 2 ), A , v , w ) case ( 'm5' ) call mv_5 ( size ( A , 1 ), size ( A , 2 ), A , v , w ) case ( 'm6' ) call mv_6 ( size ( A , 1 ), size ( A , 2 ), A , v , w ) case default w = matmul ( A , v ) end select end function matmul_mat_vec_rel_opts","tags":"","loc":"proc/matmul_mat_vec_rel_opts.html"},{"title":"gemm_mat_mat_rel – ForMatmul","text":"private pure function gemm_mat_mat_rel(A, B) result(C) Matrix-matrix multiplication using BLAS.\nauthor: Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A Input matrices A and B. real(kind=rk), intent(in), dimension(:, :), contiguous :: B Return Value real(kind=rk), dimension(size(A,1), size(B,2)) Result matrix C. Called by proc~~gemm_mat_mat_rel~~CalledByGraph proc~gemm_mat_mat_rel formatmul_opts::gemm_mat_mat_rel interface~matmul_blas formatmul_opts::matmul_blas interface~matmul_blas->proc~gemm_mat_mat_rel proc~matmul_mat_mat_rel_opts formatmul_opts::matmul_mat_mat_rel_opts proc~matmul_mat_mat_rel_opts->interface~matmul_blas proc~matmul_mat_vec_rel_opts formatmul_opts::matmul_mat_vec_rel_opts proc~matmul_mat_vec_rel_opts->interface~matmul_blas program~benchmark1 benchmark1 program~benchmark1->interface~matmul_blas program~benchmark2 benchmark2 program~benchmark2->interface~matmul_blas program~example5 example5 program~example5->interface~matmul_blas program~example7 example7 program~example7->interface~matmul_blas interface~matmul_opts formatmul_opts::matmul_opts interface~matmul_opts->proc~matmul_mat_mat_rel_opts interface~matmul_opts->proc~matmul_mat_vec_rel_opts proc~mat_mat formatmul::mat_mat proc~mat_mat->interface~matmul_opts proc~mat_vec formatmul::mat_vec proc~mat_vec->interface~matmul_opts interface~matmul formatmul::matmul interface~matmul->proc~mat_mat interface~matmul->proc~mat_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function gemm_mat_mat_rel ( A , B ) result ( C ) !> Input matrices A and B. real ( rk ), dimension (:, :), contiguous , intent ( in ) :: A real ( rk ), dimension (:, :), contiguous , intent ( in ) :: B !> Result matrix C. real ( rk ), dimension ( size ( A , 1 ), size ( B , 2 )) :: C ! real(rk), dimension(:,:), allocatable             :: C integer :: m , k interface !> BLAS subroutine for matrix-matrix multiplication. pure subroutine dgemm ( f_transa , f_transb , f_m , f_n , f_k , f_alpha , f_a , f_lda , f_b , f_ldb , f_beta , f_c , f_ldc ) import rk integer , intent ( in ) :: f_ldc integer , intent ( in ) :: f_ldb integer , intent ( in ) :: f_lda character , intent ( in ) :: f_transa character , intent ( in ) :: f_transb integer , intent ( in ) :: f_m integer , intent ( in ) :: f_n integer , intent ( in ) :: f_k real ( rk ), intent ( in ) :: f_alpha real ( rk ), intent ( in ) :: f_a ( f_lda , * ) real ( rk ), intent ( in ) :: f_b ( f_ldb , * ) real ( rk ), intent ( in ) :: f_beta real ( rk ), intent ( inout ) :: f_c ( f_ldc , * ) end subroutine dgemm end interface m = size ( A , 1 ) k = size ( A , 2 ) C = 0.0_rk ! Call BLAS dgemm subroutine for matrix-matrix multiplication. call dgemm ( 'N' , 'N' , m , size ( B , 2 ), k , 1.0_rk , A , m , B , k , 0.0_rk , C , m ) end function gemm_mat_mat_rel","tags":"","loc":"proc/gemm_mat_mat_rel.html"},{"title":"gemv_mat_vec_rel – ForMatmul","text":"private pure function gemv_mat_vec_rel(A, x) result(y) Matrix-vector multiplication using BLAS.\nauthor: Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A Input matrix A and vector x. real(kind=rk), intent(in), dimension(:), contiguous :: x Return Value real(kind=rk), dimension(size(A,1)) Result vector y. Called by proc~~gemv_mat_vec_rel~~CalledByGraph proc~gemv_mat_vec_rel formatmul_opts::gemv_mat_vec_rel interface~matmul_blas formatmul_opts::matmul_blas interface~matmul_blas->proc~gemv_mat_vec_rel proc~matmul_mat_mat_rel_opts formatmul_opts::matmul_mat_mat_rel_opts proc~matmul_mat_mat_rel_opts->interface~matmul_blas proc~matmul_mat_vec_rel_opts formatmul_opts::matmul_mat_vec_rel_opts proc~matmul_mat_vec_rel_opts->interface~matmul_blas program~benchmark1 benchmark1 program~benchmark1->interface~matmul_blas program~benchmark2 benchmark2 program~benchmark2->interface~matmul_blas program~example5 example5 program~example5->interface~matmul_blas program~example7 example7 program~example7->interface~matmul_blas interface~matmul_opts formatmul_opts::matmul_opts interface~matmul_opts->proc~matmul_mat_mat_rel_opts interface~matmul_opts->proc~matmul_mat_vec_rel_opts proc~mat_mat formatmul::mat_mat proc~mat_mat->interface~matmul_opts proc~mat_vec formatmul::mat_vec proc~mat_vec->interface~matmul_opts interface~matmul formatmul::matmul interface~matmul->proc~mat_mat interface~matmul->proc~mat_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function gemv_mat_vec_rel ( A , x ) result ( y ) !> Input matrix A and vector x. real ( rk ), dimension (:, :), contiguous , intent ( in ) :: A real ( rk ), dimension (:), contiguous , intent ( in ) :: x !> Result vector y. real ( rk ), dimension ( size ( A , 1 )) :: y ! real(rk), dimension(:), allocatable               :: y integer :: m interface !> BLAS subroutine for matrix-vector multiplication. pure subroutine dgemv ( f_trans , f_m , f_n , f_alpha , f_a , f_lda , f_x , f_incx , f_beta , f_y , f_incy ) import rk integer , intent ( in ) :: f_m integer , intent ( in ) :: f_n integer , intent ( in ) :: f_lda character , intent ( in ) :: f_trans real ( rk ), intent ( in ) :: f_alpha real ( rk ), intent ( in ) :: f_a ( f_lda , * ) real ( rk ), intent ( in ) :: f_x ( * ) integer , intent ( in ) :: f_incx real ( rk ), intent ( in ) :: f_beta real ( rk ), intent ( inout ) :: f_y ( * ) integer , intent ( in ) :: f_incy end subroutine dgemv end interface m = size ( A , 1 ) y = 0.0_rk ! Call BLAS dgemv subroutine for matrix-vector multiplication. call dgemv ( 'N' , m , size ( A , 2 ), 1.0_rk , A , m , x , 1 , 0.0_rk , y , 1 ) end function gemv_mat_vec_rel","tags":"","loc":"proc/gemv_mat_vec_rel.html"},{"title":"mm_mnp – ForMatmul","text":"private pure subroutine mm_mnp(m, n, p, a, b, c) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: p real(kind=rk), intent(in) :: a (m,n) real(kind=rk), intent(in) :: b (n,p) real(kind=rk), intent(out) :: c (m,p) Called by proc~~mm_mnp~~CalledByGraph proc~mm_mnp formatmul_opts::mm_mnp proc~matmul_mat_mat_rel_opts formatmul_opts::matmul_mat_mat_rel_opts proc~matmul_mat_mat_rel_opts->proc~mm_mnp interface~matmul_opts formatmul_opts::matmul_opts interface~matmul_opts->proc~matmul_mat_mat_rel_opts proc~mat_mat formatmul::mat_mat proc~mat_mat->interface~matmul_opts proc~mat_vec formatmul::mat_vec proc~mat_vec->interface~matmul_opts interface~matmul formatmul::matmul interface~matmul->proc~mat_mat interface~matmul->proc~mat_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_mnp ( m , n , p , a , b , c ) integer , intent ( in ) :: m , n , p real ( rk ), intent ( in ) :: a ( m , n ), b ( n , p ) real ( rk ), intent ( out ) :: c ( m , p ) integer :: i , j , k c = 0.0_rk do i = 1 , m do j = 1 , n do k = 1 , p c ( i , k ) = c ( i , k ) + a ( i , j ) * b ( j , k ) end do end do end do end subroutine mm_mnp","tags":"","loc":"proc/mm_mnp.html"},{"title":"mm_mpn – ForMatmul","text":"private pure subroutine mm_mpn(m, n, p, a, b, c) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: p real(kind=rk), intent(in) :: a (m,n) real(kind=rk), intent(in) :: b (n,p) real(kind=rk), intent(out) :: c (m,p) Called by proc~~mm_mpn~~CalledByGraph proc~mm_mpn formatmul_opts::mm_mpn proc~matmul_mat_mat_rel_opts formatmul_opts::matmul_mat_mat_rel_opts proc~matmul_mat_mat_rel_opts->proc~mm_mpn interface~matmul_opts formatmul_opts::matmul_opts interface~matmul_opts->proc~matmul_mat_mat_rel_opts proc~mat_mat formatmul::mat_mat proc~mat_mat->interface~matmul_opts proc~mat_vec formatmul::mat_vec proc~mat_vec->interface~matmul_opts interface~matmul formatmul::matmul interface~matmul->proc~mat_mat interface~matmul->proc~mat_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_mpn ( m , n , p , a , b , c ) integer , intent ( in ) :: m , n , p real ( rk ), intent ( in ) :: a ( m , n ), b ( n , p ) real ( rk ), intent ( out ) :: c ( m , p ) integer :: i , j , k c = 0.0_rk do i = 1 , m do j = 1 , p do k = 1 , n c ( i , j ) = c ( i , j ) + a ( i , k ) * b ( k , j ) end do end do end do end subroutine mm_mpn","tags":"","loc":"proc/mm_mpn.html"},{"title":"mm_nmp – ForMatmul","text":"private pure subroutine mm_nmp(m, n, p, a, b, c) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: p real(kind=rk), intent(in) :: a (m,n) real(kind=rk), intent(in) :: b (n,p) real(kind=rk), intent(out) :: c (m,p) Called by proc~~mm_nmp~~CalledByGraph proc~mm_nmp formatmul_opts::mm_nmp proc~matmul_mat_mat_rel_opts formatmul_opts::matmul_mat_mat_rel_opts proc~matmul_mat_mat_rel_opts->proc~mm_nmp interface~matmul_opts formatmul_opts::matmul_opts interface~matmul_opts->proc~matmul_mat_mat_rel_opts proc~mat_mat formatmul::mat_mat proc~mat_mat->interface~matmul_opts proc~mat_vec formatmul::mat_vec proc~mat_vec->interface~matmul_opts interface~matmul formatmul::matmul interface~matmul->proc~mat_mat interface~matmul->proc~mat_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_nmp ( m , n , p , a , b , c ) integer , intent ( in ) :: m , n , p real ( rk ), intent ( in ) :: a ( m , n ), b ( n , p ) real ( rk ), intent ( out ) :: c ( m , p ) integer :: i , j , k c = 0.0_rk do i = 1 , n do j = 1 , m do k = 1 , p c ( j , k ) = c ( j , k ) + a ( j , i ) * b ( i , k ) end do end do end do end subroutine mm_nmp","tags":"","loc":"proc/mm_nmp.html"},{"title":"mm_npm – ForMatmul","text":"private pure subroutine mm_npm(m, n, p, a, b, c) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: p real(kind=rk), intent(in) :: a (m,n) real(kind=rk), intent(in) :: b (n,p) real(kind=rk), intent(out) :: c (m,p) Called by proc~~mm_npm~~CalledByGraph proc~mm_npm formatmul_opts::mm_npm proc~matmul_mat_mat_rel_opts formatmul_opts::matmul_mat_mat_rel_opts proc~matmul_mat_mat_rel_opts->proc~mm_npm interface~matmul_opts formatmul_opts::matmul_opts interface~matmul_opts->proc~matmul_mat_mat_rel_opts proc~mat_mat formatmul::mat_mat proc~mat_mat->interface~matmul_opts proc~mat_vec formatmul::mat_vec proc~mat_vec->interface~matmul_opts interface~matmul formatmul::matmul interface~matmul->proc~mat_mat interface~matmul->proc~mat_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_npm ( m , n , p , a , b , c ) integer , intent ( in ) :: m , n , p real ( rk ), intent ( in ) :: a ( m , n ), b ( n , p ) real ( rk ), intent ( out ) :: c ( m , p ) integer :: i , j , k c = 0.0_rk do i = 1 , n do j = 1 , p do k = 1 , m c ( k , j ) = c ( k , j ) + a ( k , i ) * b ( i , j ) end do end do end do end subroutine mm_npm","tags":"","loc":"proc/mm_npm.html"},{"title":"mm_pmn – ForMatmul","text":"private pure subroutine mm_pmn(m, n, p, a, b, c) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: p real(kind=rk), intent(in) :: a (m,n) real(kind=rk), intent(in) :: b (n,p) real(kind=rk), intent(out) :: c (m,p) Called by proc~~mm_pmn~~CalledByGraph proc~mm_pmn formatmul_opts::mm_pmn proc~matmul_mat_mat_rel_opts formatmul_opts::matmul_mat_mat_rel_opts proc~matmul_mat_mat_rel_opts->proc~mm_pmn interface~matmul_opts formatmul_opts::matmul_opts interface~matmul_opts->proc~matmul_mat_mat_rel_opts proc~mat_mat formatmul::mat_mat proc~mat_mat->interface~matmul_opts proc~mat_vec formatmul::mat_vec proc~mat_vec->interface~matmul_opts interface~matmul formatmul::matmul interface~matmul->proc~mat_mat interface~matmul->proc~mat_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_pmn ( m , n , p , a , b , c ) integer , intent ( in ) :: m , n , p real ( rk ), intent ( in ) :: a ( m , n ), b ( n , p ) real ( rk ), intent ( out ) :: c ( m , p ) integer :: i , j , k c = 0.0_rk do i = 1 , p do j = 1 , m do k = 1 , n c ( j , i ) = c ( j , i ) + a ( j , k ) * b ( k , i ) end do end do end do end subroutine mm_pmn","tags":"","loc":"proc/mm_pmn.html"},{"title":"mm_pnm – ForMatmul","text":"private pure subroutine mm_pnm(m, n, p, a, b, c) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: p real(kind=rk), intent(in) :: a (m,n) real(kind=rk), intent(in) :: b (n,p) real(kind=rk), intent(out) :: c (m,p) Called by proc~~mm_pnm~~CalledByGraph proc~mm_pnm formatmul_opts::mm_pnm proc~matmul_mat_mat_rel_opts formatmul_opts::matmul_mat_mat_rel_opts proc~matmul_mat_mat_rel_opts->proc~mm_pnm interface~matmul_opts formatmul_opts::matmul_opts interface~matmul_opts->proc~matmul_mat_mat_rel_opts proc~mat_mat formatmul::mat_mat proc~mat_mat->interface~matmul_opts proc~mat_vec formatmul::mat_vec proc~mat_vec->interface~matmul_opts interface~matmul formatmul::matmul interface~matmul->proc~mat_mat interface~matmul->proc~mat_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_pnm ( m , n , p , a , b , c ) integer , intent ( in ) :: m , n , p real ( rk ), intent ( in ) :: a ( m , n ), b ( n , p ) real ( rk ), intent ( out ) :: c ( m , p ) integer :: i , j , k c = 0.0_rk do i = 1 , p do j = 1 , n do k = 1 , m c ( k , i ) = c ( k , i ) + a ( k , j ) * b ( j , i ) end do end do end do end subroutine mm_pnm","tags":"","loc":"proc/mm_pnm.html"},{"title":"mm_9 – ForMatmul","text":"private pure subroutine mm_9(m, n, p, a, b, c) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: p real(kind=rk), intent(in) :: a (m,n) real(kind=rk), intent(in) :: b (n,p) real(kind=rk), intent(out) :: c (m,p) Called by proc~~mm_9~~CalledByGraph proc~mm_9 formatmul_opts::mm_9 proc~matmul_mat_mat_rel_opts formatmul_opts::matmul_mat_mat_rel_opts proc~matmul_mat_mat_rel_opts->proc~mm_9 interface~matmul_opts formatmul_opts::matmul_opts interface~matmul_opts->proc~matmul_mat_mat_rel_opts proc~mat_mat formatmul::mat_mat proc~mat_mat->interface~matmul_opts proc~mat_vec formatmul::mat_vec proc~mat_vec->interface~matmul_opts interface~matmul formatmul::matmul interface~matmul->proc~mat_mat interface~matmul->proc~mat_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_9 ( m , n , p , a , b , c ) integer , intent ( in ) :: m , n , p real ( rk ), intent ( in ) :: a ( m , n ), b ( n , p ) real ( rk ), intent ( out ) :: c ( m , p ) integer :: i , k c = 0.0_rk do i = 1 , p do k = 1 , m c ( k , i ) = dot_product ( a ( k ,:), b (:, i )) end do end do end subroutine mm_9","tags":"","loc":"proc/mm_9.html"},{"title":"mm_10 – ForMatmul","text":"private pure subroutine mm_10(m, n, p, a, b, c) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: p real(kind=rk), intent(in) :: a (m,n) real(kind=rk), intent(in) :: b (n,p) real(kind=rk), intent(out) :: c (m,p) Called by proc~~mm_10~~CalledByGraph proc~mm_10 formatmul_opts::mm_10 proc~matmul_mat_mat_rel_opts formatmul_opts::matmul_mat_mat_rel_opts proc~matmul_mat_mat_rel_opts->proc~mm_10 interface~matmul_opts formatmul_opts::matmul_opts interface~matmul_opts->proc~matmul_mat_mat_rel_opts proc~mat_mat formatmul::mat_mat proc~mat_mat->interface~matmul_opts proc~mat_vec formatmul::mat_vec proc~mat_vec->interface~matmul_opts interface~matmul formatmul::matmul interface~matmul->proc~mat_mat interface~matmul->proc~mat_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_10 ( m , n , p , a , b , c ) integer , intent ( in ) :: m , n , p real ( rk ), intent ( in ) :: a ( m , n ), b ( n , p ) real ( rk ), intent ( out ) :: c ( m , p ) integer :: i , k c = 0.0_rk do concurrent ( i = 1 : p ) do k = 1 , m c ( k , i ) = dot_product ( a ( k ,:), b (:, i )) end do end do end subroutine mm_10","tags":"","loc":"proc/mm_10.html"},{"title":"mm_11 – ForMatmul","text":"private pure subroutine mm_11(m, n, p, a, b, c) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: p real(kind=rk), intent(in) :: a (m,n) real(kind=rk), intent(in) :: b (n,p) real(kind=rk), intent(out) :: c (m,p) Called by proc~~mm_11~~CalledByGraph proc~mm_11 formatmul_opts::mm_11 proc~matmul_mat_mat_rel_opts formatmul_opts::matmul_mat_mat_rel_opts proc~matmul_mat_mat_rel_opts->proc~mm_11 interface~matmul_opts formatmul_opts::matmul_opts interface~matmul_opts->proc~matmul_mat_mat_rel_opts proc~mat_mat formatmul::mat_mat proc~mat_mat->interface~matmul_opts proc~mat_vec formatmul::mat_vec proc~mat_vec->interface~matmul_opts interface~matmul formatmul::matmul interface~matmul->proc~mat_mat interface~matmul->proc~mat_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_11 ( m , n , p , a , b , c ) integer , intent ( in ) :: m , n , p real ( rk ), intent ( in ) :: a ( m , n ), b ( n , p ) real ( rk ), intent ( out ) :: c ( m , p ) integer :: i , j , k c = 0.0_rk do concurrent ( i = 1 : p ) do j = 1 , n do k = 1 , m c ( k , i ) = c ( k , i ) + a ( k , j ) * b ( j , i ) end do end do end do end subroutine mm_11","tags":"","loc":"proc/mm_11.html"},{"title":"mm_12 – ForMatmul","text":"private pure subroutine mm_12(m, n, p, a, b, c) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: p real(kind=rk), intent(in) :: a (m,n) real(kind=rk), intent(in) :: b (n,p) real(kind=rk), intent(out) :: c (m,p) Called by proc~~mm_12~~CalledByGraph proc~mm_12 formatmul_opts::mm_12 proc~matmul_mat_mat_rel_opts formatmul_opts::matmul_mat_mat_rel_opts proc~matmul_mat_mat_rel_opts->proc~mm_12 interface~matmul_opts formatmul_opts::matmul_opts interface~matmul_opts->proc~matmul_mat_mat_rel_opts proc~mat_mat formatmul::mat_mat proc~mat_mat->interface~matmul_opts proc~mat_vec formatmul::mat_vec proc~mat_vec->interface~matmul_opts interface~matmul formatmul::matmul interface~matmul->proc~mat_mat interface~matmul->proc~mat_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_12 ( m , n , p , a , b , c ) integer , intent ( in ) :: m , n , p real ( rk ), intent ( in ) :: a ( m , n ), b ( n , p ) real ( rk ), intent ( out ) :: c ( m , p ) interface pure subroutine impure_mm_12 ( f_m , f_n , f_p , f_a , f_b , f_c ) import rk integer , intent ( in ) :: f_m , f_n , f_p real ( rk ), intent ( in ) :: f_a ( f_m , f_n ), f_b ( f_n , f_p ) real ( rk ), intent ( out ) :: f_c ( f_m , f_p ) end subroutine impure_mm_12 end interface call impure_mm_12 ( m , n , p , a , b , c ) end subroutine mm_12","tags":"","loc":"proc/mm_12.html"},{"title":"mm_13 – ForMatmul","text":"private pure subroutine mm_13(m, n, p, a, b, c) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: p real(kind=rk), intent(in) :: a (m,n) real(kind=rk), intent(in) :: b (n,p) real(kind=rk), intent(out) :: c (m,p) Called by proc~~mm_13~~CalledByGraph proc~mm_13 formatmul_opts::mm_13 proc~matmul_mat_mat_rel_opts formatmul_opts::matmul_mat_mat_rel_opts proc~matmul_mat_mat_rel_opts->proc~mm_13 interface~matmul_opts formatmul_opts::matmul_opts interface~matmul_opts->proc~matmul_mat_mat_rel_opts proc~mat_mat formatmul::mat_mat proc~mat_mat->interface~matmul_opts proc~mat_vec formatmul::mat_vec proc~mat_vec->interface~matmul_opts interface~matmul formatmul::matmul interface~matmul->proc~mat_mat interface~matmul->proc~mat_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_13 ( m , n , p , a , b , c ) integer , intent ( in ) :: m , n , p real ( rk ), intent ( in ) :: a ( m , n ), b ( n , p ) real ( rk ), intent ( out ) :: c ( m , p ) integer :: i , k interface pure subroutine impure_mm_13 ( f_m , f_n , f_p , f_a , f_b , f_c ) import rk integer , intent ( in ) :: f_m , f_n , f_p real ( rk ), intent ( in ) :: f_a ( f_m , f_n ), f_b ( f_n , f_p ) real ( rk ), intent ( out ) :: f_c ( f_m , f_p ) end subroutine impure_mm_13 end interface call impure_mm_13 ( m , n , p , a , b , c ) end subroutine mm_13","tags":"","loc":"proc/mm_13.html"},{"title":"mv_3 – ForMatmul","text":"private pure subroutine mv_3(m, n, a, b, c) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n real(kind=rk), intent(in) :: a (m,n) real(kind=rk), intent(in) :: b (n) real(kind=rk), intent(out) :: c (m) Called by proc~~mv_3~~CalledByGraph proc~mv_3 formatmul_opts::mv_3 proc~matmul_mat_vec_rel_opts formatmul_opts::matmul_mat_vec_rel_opts proc~matmul_mat_vec_rel_opts->proc~mv_3 interface~matmul_opts formatmul_opts::matmul_opts interface~matmul_opts->proc~matmul_mat_vec_rel_opts proc~mat_mat formatmul::mat_mat proc~mat_mat->interface~matmul_opts proc~mat_vec formatmul::mat_vec proc~mat_vec->interface~matmul_opts interface~matmul formatmul::matmul interface~matmul->proc~mat_mat interface~matmul->proc~mat_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mv_3 ( m , n , a , b , c ) integer , intent ( in ) :: m , n real ( rk ), intent ( in ) :: a ( m , n ), b ( n ) real ( rk ), intent ( out ) :: c ( m ) integer :: i , j c = 0.0_rk do i = 1 , m do j = 1 , n c ( i ) = c ( i ) + a ( i , j ) * b ( j ) end do end do end subroutine mv_3","tags":"","loc":"proc/mv_3.html"},{"title":"mv_4 – ForMatmul","text":"private pure subroutine mv_4(m, n, a, b, c) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n real(kind=rk), intent(in) :: a (m,n) real(kind=rk), intent(in) :: b (n) real(kind=rk), intent(out) :: c (m) Called by proc~~mv_4~~CalledByGraph proc~mv_4 formatmul_opts::mv_4 proc~matmul_mat_vec_rel_opts formatmul_opts::matmul_mat_vec_rel_opts proc~matmul_mat_vec_rel_opts->proc~mv_4 interface~matmul_opts formatmul_opts::matmul_opts interface~matmul_opts->proc~matmul_mat_vec_rel_opts proc~mat_mat formatmul::mat_mat proc~mat_mat->interface~matmul_opts proc~mat_vec formatmul::mat_vec proc~mat_vec->interface~matmul_opts interface~matmul formatmul::matmul interface~matmul->proc~mat_mat interface~matmul->proc~mat_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mv_4 ( m , n , a , b , c ) integer , intent ( in ) :: m , n real ( rk ), intent ( in ) :: a ( m , n ), b ( n ) real ( rk ), intent ( out ) :: c ( m ) integer :: i , j c = 0.0_rk do j = 1 , n do i = 1 , m c ( i ) = c ( i ) + a ( i , j ) * b ( j ) end do end do end subroutine mv_4","tags":"","loc":"proc/mv_4.html"},{"title":"mv_5 – ForMatmul","text":"private pure subroutine mv_5(m, n, a, b, c) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n real(kind=rk), intent(in) :: a (m,n) real(kind=rk), intent(in) :: b (n) real(kind=rk), intent(out) :: c (m) Called by proc~~mv_5~~CalledByGraph proc~mv_5 formatmul_opts::mv_5 proc~matmul_mat_vec_rel_opts formatmul_opts::matmul_mat_vec_rel_opts proc~matmul_mat_vec_rel_opts->proc~mv_5 interface~matmul_opts formatmul_opts::matmul_opts interface~matmul_opts->proc~matmul_mat_vec_rel_opts proc~mat_mat formatmul::mat_mat proc~mat_mat->interface~matmul_opts proc~mat_vec formatmul::mat_vec proc~mat_vec->interface~matmul_opts interface~matmul formatmul::matmul interface~matmul->proc~mat_mat interface~matmul->proc~mat_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mv_5 ( m , n , a , b , c ) integer , intent ( in ) :: m , n real ( rk ), intent ( in ) :: a ( m , n ), b ( n ) real ( rk ), intent ( out ) :: c ( m ) integer :: k c = 0.0_rk do k = 1 , m c ( k ) = dot_product ( a ( k ,:), b (:)) end do end subroutine mv_5","tags":"","loc":"proc/mv_5.html"},{"title":"mv_6 – ForMatmul","text":"private pure subroutine mv_6(m, n, a, b, c) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n real(kind=rk), intent(in) :: a (m,n) real(kind=rk), intent(in) :: b (n) real(kind=rk), intent(out) :: c (m) Called by proc~~mv_6~~CalledByGraph proc~mv_6 formatmul_opts::mv_6 proc~matmul_mat_vec_rel_opts formatmul_opts::matmul_mat_vec_rel_opts proc~matmul_mat_vec_rel_opts->proc~mv_6 interface~matmul_opts formatmul_opts::matmul_opts interface~matmul_opts->proc~matmul_mat_vec_rel_opts proc~mat_mat formatmul::mat_mat proc~mat_mat->interface~matmul_opts proc~mat_vec formatmul::mat_vec proc~mat_vec->interface~matmul_opts interface~matmul formatmul::matmul interface~matmul->proc~mat_mat interface~matmul->proc~mat_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mv_6 ( m , n , a , b , c ) integer , intent ( in ) :: m , n real ( rk ), intent ( in ) :: a ( m , n ), b ( n ) real ( rk ), intent ( out ) :: c ( m ) integer :: k c = 0.0_rk do k = 1 , n c (:) = c (:) + a (:, k ) * b ( k ) end do end subroutine mv_6","tags":"","loc":"proc/mv_6.html"},{"title":"matmul_opts – ForMatmul","text":"public interface matmul_opts Calls interface~~matmul_opts~~CallsGraph interface~matmul_opts formatmul_opts::matmul_opts proc~matmul_mat_mat_rel_opts formatmul_opts::matmul_mat_mat_rel_opts interface~matmul_opts->proc~matmul_mat_mat_rel_opts proc~matmul_mat_vec_rel_opts formatmul_opts::matmul_mat_vec_rel_opts interface~matmul_opts->proc~matmul_mat_vec_rel_opts interface~matmul_blas formatmul_opts::matmul_blas proc~matmul_mat_mat_rel_opts->interface~matmul_blas proc~mm_10 formatmul_opts::mm_10 proc~matmul_mat_mat_rel_opts->proc~mm_10 proc~mm_11 formatmul_opts::mm_11 proc~matmul_mat_mat_rel_opts->proc~mm_11 proc~mm_12 formatmul_opts::mm_12 proc~matmul_mat_mat_rel_opts->proc~mm_12 proc~mm_13 formatmul_opts::mm_13 proc~matmul_mat_mat_rel_opts->proc~mm_13 proc~mm_9 formatmul_opts::mm_9 proc~matmul_mat_mat_rel_opts->proc~mm_9 proc~mm_mnp formatmul_opts::mm_mnp proc~matmul_mat_mat_rel_opts->proc~mm_mnp proc~mm_mpn formatmul_opts::mm_mpn proc~matmul_mat_mat_rel_opts->proc~mm_mpn proc~mm_nmp formatmul_opts::mm_nmp proc~matmul_mat_mat_rel_opts->proc~mm_nmp proc~mm_npm formatmul_opts::mm_npm proc~matmul_mat_mat_rel_opts->proc~mm_npm proc~mm_pmn formatmul_opts::mm_pmn proc~matmul_mat_mat_rel_opts->proc~mm_pmn proc~mm_pnm formatmul_opts::mm_pnm proc~matmul_mat_mat_rel_opts->proc~mm_pnm proc~matmul_mat_vec_rel_opts->interface~matmul_blas proc~mv_3 formatmul_opts::mv_3 proc~matmul_mat_vec_rel_opts->proc~mv_3 proc~mv_4 formatmul_opts::mv_4 proc~matmul_mat_vec_rel_opts->proc~mv_4 proc~mv_5 formatmul_opts::mv_5 proc~matmul_mat_vec_rel_opts->proc~mv_5 proc~mv_6 formatmul_opts::mv_6 proc~matmul_mat_vec_rel_opts->proc~mv_6 proc~gemm_mat_mat_rel formatmul_opts::gemm_mat_mat_rel interface~matmul_blas->proc~gemm_mat_mat_rel proc~gemv_mat_vec_rel formatmul_opts::gemv_mat_vec_rel interface~matmul_blas->proc~gemv_mat_vec_rel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~matmul_opts~~CalledByGraph interface~matmul_opts formatmul_opts::matmul_opts proc~mat_mat formatmul::mat_mat proc~mat_mat->interface~matmul_opts proc~mat_vec formatmul::mat_vec proc~mat_vec->interface~matmul_opts interface~matmul formatmul::matmul interface~matmul->proc~mat_mat interface~matmul->proc~mat_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function matmul_mat_mat_rel_opts (A, B, option) result(C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) character(len=*), intent(in) :: option Return Value real(kind=rk), (size(A,1),size(B,2)) private pure function matmul_mat_vec_rel_opts (A, v, option) result(w) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) character(len=*), intent(in) :: option Return Value real(kind=rk), (size(A,1))","tags":"","loc":"interface/matmul_opts.html"},{"title":"matmul_blas – ForMatmul","text":"public interface matmul_blas Interface for BLAS-based matrix multiplication functions. Calls interface~~matmul_blas~~CallsGraph interface~matmul_blas formatmul_opts::matmul_blas proc~gemm_mat_mat_rel formatmul_opts::gemm_mat_mat_rel interface~matmul_blas->proc~gemm_mat_mat_rel proc~gemv_mat_vec_rel formatmul_opts::gemv_mat_vec_rel interface~matmul_blas->proc~gemv_mat_vec_rel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~matmul_blas~~CalledByGraph interface~matmul_blas formatmul_opts::matmul_blas proc~matmul_mat_mat_rel_opts formatmul_opts::matmul_mat_mat_rel_opts proc~matmul_mat_mat_rel_opts->interface~matmul_blas proc~matmul_mat_vec_rel_opts formatmul_opts::matmul_mat_vec_rel_opts proc~matmul_mat_vec_rel_opts->interface~matmul_blas program~benchmark1 benchmark1 program~benchmark1->interface~matmul_blas program~benchmark2 benchmark2 program~benchmark2->interface~matmul_blas program~example5 example5 program~example5->interface~matmul_blas program~example7 example7 program~example7->interface~matmul_blas interface~matmul_opts formatmul_opts::matmul_opts interface~matmul_opts->proc~matmul_mat_mat_rel_opts interface~matmul_opts->proc~matmul_mat_vec_rel_opts proc~mat_mat formatmul::mat_mat proc~mat_mat->interface~matmul_opts proc~mat_vec formatmul::mat_vec proc~mat_vec->interface~matmul_opts interface~matmul formatmul::matmul interface~matmul->proc~mat_mat interface~matmul->proc~mat_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function gemm_mat_mat_rel (A, B) result(C) Matrix-matrix multiplication using BLAS.\nauthor: Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A Input matrices A and B. real(kind=rk), intent(in), dimension(:, :), contiguous :: B Return Value real(kind=rk), dimension(size(A,1), size(B,2)) Result matrix C. private pure function gemv_mat_vec_rel (A, x) result(y) Matrix-vector multiplication using BLAS.\nauthor: Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A Input matrix A and vector x. real(kind=rk), intent(in), dimension(:), contiguous :: x Return Value real(kind=rk), dimension(size(A,1)) Result vector y.","tags":"","loc":"interface/matmul_blas.html"},{"title":"mat_mat – ForMatmul","text":"private impure function mat_mat(A, B, method, option) result(C) Matrix-matrix multiplication using coarray parallelism.\nauthor: Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) Input matrices A and B. real(kind=rk), intent(in), contiguous :: B (:,:) Input matrices A and B. character(len=*), intent(in) :: method Multiplication method ('coarray'). character(len=*), intent(in), optional :: option Optional method-specific option. Return Value real(kind=rk), (size(A,1),size(B,2)) Result matrix C. Calls proc~~mat_mat~~CallsGraph proc~mat_mat formatmul::mat_mat a_block a_block proc~mat_mat->a_block b_block b_block proc~mat_mat->b_block block_size block_size proc~mat_mat->block_size c_block c_block proc~mat_mat->c_block end_elem end_elem proc~mat_mat->end_elem interface~matmul_opts formatmul_opts::matmul_opts proc~mat_mat->interface~matmul_opts proc~compute_block_ranges formatmul::compute_block_ranges proc~mat_mat->proc~compute_block_ranges start_elem start_elem proc~mat_mat->start_elem proc~matmul_mat_mat_rel_opts formatmul_opts::matmul_mat_mat_rel_opts interface~matmul_opts->proc~matmul_mat_mat_rel_opts proc~matmul_mat_vec_rel_opts formatmul_opts::matmul_mat_vec_rel_opts interface~matmul_opts->proc~matmul_mat_vec_rel_opts interface~matmul_blas formatmul_opts::matmul_blas proc~matmul_mat_mat_rel_opts->interface~matmul_blas proc~mm_10 formatmul_opts::mm_10 proc~matmul_mat_mat_rel_opts->proc~mm_10 proc~mm_11 formatmul_opts::mm_11 proc~matmul_mat_mat_rel_opts->proc~mm_11 proc~mm_12 formatmul_opts::mm_12 proc~matmul_mat_mat_rel_opts->proc~mm_12 proc~mm_13 formatmul_opts::mm_13 proc~matmul_mat_mat_rel_opts->proc~mm_13 proc~mm_9 formatmul_opts::mm_9 proc~matmul_mat_mat_rel_opts->proc~mm_9 proc~mm_mnp formatmul_opts::mm_mnp proc~matmul_mat_mat_rel_opts->proc~mm_mnp proc~mm_mpn formatmul_opts::mm_mpn proc~matmul_mat_mat_rel_opts->proc~mm_mpn proc~mm_nmp formatmul_opts::mm_nmp proc~matmul_mat_mat_rel_opts->proc~mm_nmp proc~mm_npm formatmul_opts::mm_npm proc~matmul_mat_mat_rel_opts->proc~mm_npm proc~mm_pmn formatmul_opts::mm_pmn proc~matmul_mat_mat_rel_opts->proc~mm_pmn proc~mm_pnm formatmul_opts::mm_pnm proc~matmul_mat_mat_rel_opts->proc~mm_pnm proc~matmul_mat_vec_rel_opts->interface~matmul_blas proc~mv_3 formatmul_opts::mv_3 proc~matmul_mat_vec_rel_opts->proc~mv_3 proc~mv_4 formatmul_opts::mv_4 proc~matmul_mat_vec_rel_opts->proc~mv_4 proc~mv_5 formatmul_opts::mv_5 proc~matmul_mat_vec_rel_opts->proc~mv_5 proc~mv_6 formatmul_opts::mv_6 proc~matmul_mat_vec_rel_opts->proc~mv_6 proc~gemm_mat_mat_rel formatmul_opts::gemm_mat_mat_rel interface~matmul_blas->proc~gemm_mat_mat_rel proc~gemv_mat_vec_rel formatmul_opts::gemv_mat_vec_rel interface~matmul_blas->proc~gemv_mat_vec_rel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~mat_mat~~CalledByGraph proc~mat_mat formatmul::mat_mat interface~matmul formatmul::matmul interface~matmul->proc~mat_mat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure function mat_mat ( A , B , method , option ) result ( C ) #else pure function mat_mat ( A , B , method , option ) result ( C ) #endif !> Input matrices A and B. real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) !> Multiplication method ('coarray'). character ( * ), intent ( in ) :: method !> Optional method-specific option. character ( * ), intent ( in ), optional :: option !> Result matrix C. real ( rk ) :: C ( size ( A , 1 ), size ( B , 2 )) select case ( method ) #if defined(USE_COARRAY) case ( 'coarray' ) ! Coarray-based parallel multiplication. if ( size ( A , 1 ) >= size ( B , 2 )) then ! Handle A's columns > B's rows. block integer :: i , im , nimg , n , o integer :: block_size ( num_images ()), start_elem ( num_images ()), end_elem ( num_images ()) real ( rk ), allocatable :: C_block (:,:)[:], A_block (:,:)[:] im = this_image () nimg = num_images () n = size ( A , 2 ) o = size ( B , 2 ) call compute_block_ranges ( size ( A , 1 ), nimg , block_size , start_elem , end_elem ) allocate ( A_block ( block_size ( im ), n )[ * ], C_block ( block_size ( im ), o )[ * ]) A_block (:,:)[ im ] = A ( start_elem ( im ): end_elem ( im ), :) C_block (:,:)[ im ] = matmul_opts ( A_block (:,:)[ im ], B , option ) sync all if ( im == 1 ) then do i = 1 , nimg C ( start_elem ( i ): end_elem ( i ), :) = C_block (:,:)[ i ] end do end if end block else ! Handle B's columns > A's rows. block integer :: i , im , nimg , n , m integer :: block_size ( num_images ()), start_elem ( num_images ()), end_elem ( num_images ()) real ( rk ), allocatable :: C_block (:,:)[:], B_block (:,:)[:] im = this_image () nimg = num_images () n = size ( A , 2 ) m = size ( A , 1 ) call compute_block_ranges ( size ( B , 2 ), nimg , block_size , start_elem , end_elem ) allocate ( B_block ( n , block_size ( im ))[ * ], C_block ( m , block_size ( im ))[ * ]) B_block (:,:)[ im ] = B (:, start_elem ( im ): end_elem ( im )) C_block (:,:)[ im ] = matmul_opts ( A , B_block (:,:)[ im ], option ) sync all if ( im == 1 ) then do i = 1 , nimg C (:, start_elem ( i ): end_elem ( i )) = C_block (:,:)[ i ] end do end if end block end if #endif case ( 'default' ) C = matmul_opts ( A , B , option ) end select end function mat_mat","tags":"","loc":"proc/mat_mat.html"},{"title":"mat_vec – ForMatmul","text":"private impure function mat_vec(A, v, method, option) result(w) Matrix-vector multiplication using coarray parallelism.\nauthor: Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) Input matrix A and vector v. real(kind=rk), intent(in), contiguous :: v (:) Input matrix A and vector v. character(len=*), intent(in) :: method Multiplication method ('coarray'). character(len=*), intent(in), optional :: option Optional method-specific option. Return Value real(kind=rk), (size(A,1)) Result vector w. Calls proc~~mat_vec~~CallsGraph proc~mat_vec formatmul::mat_vec block_size block_size proc~mat_vec->block_size end_elem end_elem proc~mat_vec->end_elem interface~matmul_opts formatmul_opts::matmul_opts proc~mat_vec->interface~matmul_opts proc~compute_block_ranges formatmul::compute_block_ranges proc~mat_vec->proc~compute_block_ranges start_elem start_elem proc~mat_vec->start_elem w_block w_block proc~mat_vec->w_block proc~matmul_mat_mat_rel_opts formatmul_opts::matmul_mat_mat_rel_opts interface~matmul_opts->proc~matmul_mat_mat_rel_opts proc~matmul_mat_vec_rel_opts formatmul_opts::matmul_mat_vec_rel_opts interface~matmul_opts->proc~matmul_mat_vec_rel_opts interface~matmul_blas formatmul_opts::matmul_blas proc~matmul_mat_mat_rel_opts->interface~matmul_blas proc~mm_10 formatmul_opts::mm_10 proc~matmul_mat_mat_rel_opts->proc~mm_10 proc~mm_11 formatmul_opts::mm_11 proc~matmul_mat_mat_rel_opts->proc~mm_11 proc~mm_12 formatmul_opts::mm_12 proc~matmul_mat_mat_rel_opts->proc~mm_12 proc~mm_13 formatmul_opts::mm_13 proc~matmul_mat_mat_rel_opts->proc~mm_13 proc~mm_9 formatmul_opts::mm_9 proc~matmul_mat_mat_rel_opts->proc~mm_9 proc~mm_mnp formatmul_opts::mm_mnp proc~matmul_mat_mat_rel_opts->proc~mm_mnp proc~mm_mpn formatmul_opts::mm_mpn proc~matmul_mat_mat_rel_opts->proc~mm_mpn proc~mm_nmp formatmul_opts::mm_nmp proc~matmul_mat_mat_rel_opts->proc~mm_nmp proc~mm_npm formatmul_opts::mm_npm proc~matmul_mat_mat_rel_opts->proc~mm_npm proc~mm_pmn formatmul_opts::mm_pmn proc~matmul_mat_mat_rel_opts->proc~mm_pmn proc~mm_pnm formatmul_opts::mm_pnm proc~matmul_mat_mat_rel_opts->proc~mm_pnm proc~matmul_mat_vec_rel_opts->interface~matmul_blas proc~mv_3 formatmul_opts::mv_3 proc~matmul_mat_vec_rel_opts->proc~mv_3 proc~mv_4 formatmul_opts::mv_4 proc~matmul_mat_vec_rel_opts->proc~mv_4 proc~mv_5 formatmul_opts::mv_5 proc~matmul_mat_vec_rel_opts->proc~mv_5 proc~mv_6 formatmul_opts::mv_6 proc~matmul_mat_vec_rel_opts->proc~mv_6 proc~gemm_mat_mat_rel formatmul_opts::gemm_mat_mat_rel interface~matmul_blas->proc~gemm_mat_mat_rel proc~gemv_mat_vec_rel formatmul_opts::gemv_mat_vec_rel interface~matmul_blas->proc~gemv_mat_vec_rel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~mat_vec~~CalledByGraph proc~mat_vec formatmul::mat_vec interface~matmul formatmul::matmul interface~matmul->proc~mat_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure function mat_vec ( A , v , method , option ) result ( w ) #else pure function mat_vec ( A , v , method , option ) result ( w ) #endif !> Input matrix A and vector v. real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) !> Multiplication method ('coarray'). character ( * ), intent ( in ) :: method !> Optional method-specific option. character ( * ), intent ( in ), optional :: option !> Result vector w. real ( rk ) :: w ( size ( A , 1 )) select case ( method ) #if defined(USE_COARRAY) case ( 'coarray' ) ! Coarray-based parallel multiplication. block integer :: i , im , nimg integer :: block_size ( num_images ()), start_elem ( num_images ()), end_elem ( num_images ()) real ( rk ), allocatable :: w_block (:)[:] im = this_image () nimg = num_images () call compute_block_ranges ( size ( A , 1 ), nimg , block_size , start_elem , end_elem ) allocate ( w_block ( block_size ( im ))[ * ]) w_block (:)[ im ] = matmul_opts ( A ( start_elem ( im ): end_elem ( im ), :), v , option ) sync all if ( im == 1 ) then do i = 1 , nimg w ( start_elem ( i ): end_elem ( i )) = w_block (:)[ i ] end do end if end block #endif case ( 'default' ) w = matmul_opts ( A , v , option ) end select end function mat_vec","tags":"","loc":"proc/mat_vec.html"},{"title":"compute_block_ranges – ForMatmul","text":"private pure subroutine compute_block_ranges(d, nimg, block_size, start_elem, end_elem) Calculate block sizes and ranges.\nauthor: Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name integer, intent(in) :: d integer, intent(in) :: nimg integer, intent(out) :: block_size (nimg) integer, intent(out) :: start_elem (nimg) integer, intent(out) :: end_elem (nimg) Called by proc~~compute_block_ranges~~CalledByGraph proc~compute_block_ranges formatmul::compute_block_ranges proc~mat_mat formatmul::mat_mat proc~mat_mat->proc~compute_block_ranges proc~mat_vec formatmul::mat_vec proc~mat_vec->proc~compute_block_ranges interface~matmul formatmul::matmul interface~matmul->proc~mat_mat interface~matmul->proc~mat_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine compute_block_ranges ( d , nimg , block_size , start_elem , end_elem ) integer , intent ( in ) :: d , nimg integer , intent ( out ) :: block_size ( nimg ), start_elem ( nimg ), end_elem ( nimg ) integer :: i , remainder block_size = d / nimg remainder = mod ( d , nimg ) block_size ( 1 : remainder ) = block_size ( 1 : remainder ) + 1 start_elem ( 1 ) = 1 end_elem ( 1 ) = block_size ( 1 ) do i = 2 , nimg start_elem ( i ) = start_elem ( i - 1 ) + block_size ( i - 1 ) end_elem ( i ) = start_elem ( i ) + block_size ( i ) - 1 end do ! Check if the block sizes are valid. if ( minval ( block_size ) <= 0 ) error stop 'ForMatmul: reduce the number of images of coarray.' end subroutine compute_block_ranges","tags":"","loc":"proc/compute_block_ranges.html"},{"title":"matmul – ForMatmul","text":"public interface matmul Interface for matrix multiplication functions. Calls interface~~matmul~~CallsGraph interface~matmul formatmul::matmul proc~mat_mat formatmul::mat_mat interface~matmul->proc~mat_mat proc~mat_vec formatmul::mat_vec interface~matmul->proc~mat_vec a_block a_block proc~mat_mat->a_block b_block b_block proc~mat_mat->b_block block_size block_size proc~mat_mat->block_size c_block c_block proc~mat_mat->c_block end_elem end_elem proc~mat_mat->end_elem interface~matmul_opts formatmul_opts::matmul_opts proc~mat_mat->interface~matmul_opts proc~compute_block_ranges formatmul::compute_block_ranges proc~mat_mat->proc~compute_block_ranges start_elem start_elem proc~mat_mat->start_elem proc~mat_vec->block_size proc~mat_vec->end_elem proc~mat_vec->interface~matmul_opts proc~mat_vec->proc~compute_block_ranges proc~mat_vec->start_elem w_block w_block proc~mat_vec->w_block proc~matmul_mat_mat_rel_opts formatmul_opts::matmul_mat_mat_rel_opts interface~matmul_opts->proc~matmul_mat_mat_rel_opts proc~matmul_mat_vec_rel_opts formatmul_opts::matmul_mat_vec_rel_opts interface~matmul_opts->proc~matmul_mat_vec_rel_opts interface~matmul_blas formatmul_opts::matmul_blas proc~matmul_mat_mat_rel_opts->interface~matmul_blas proc~mm_10 formatmul_opts::mm_10 proc~matmul_mat_mat_rel_opts->proc~mm_10 proc~mm_11 formatmul_opts::mm_11 proc~matmul_mat_mat_rel_opts->proc~mm_11 proc~mm_12 formatmul_opts::mm_12 proc~matmul_mat_mat_rel_opts->proc~mm_12 proc~mm_13 formatmul_opts::mm_13 proc~matmul_mat_mat_rel_opts->proc~mm_13 proc~mm_9 formatmul_opts::mm_9 proc~matmul_mat_mat_rel_opts->proc~mm_9 proc~mm_mnp formatmul_opts::mm_mnp proc~matmul_mat_mat_rel_opts->proc~mm_mnp proc~mm_mpn formatmul_opts::mm_mpn proc~matmul_mat_mat_rel_opts->proc~mm_mpn proc~mm_nmp formatmul_opts::mm_nmp proc~matmul_mat_mat_rel_opts->proc~mm_nmp proc~mm_npm formatmul_opts::mm_npm proc~matmul_mat_mat_rel_opts->proc~mm_npm proc~mm_pmn formatmul_opts::mm_pmn proc~matmul_mat_mat_rel_opts->proc~mm_pmn proc~mm_pnm formatmul_opts::mm_pnm proc~matmul_mat_mat_rel_opts->proc~mm_pnm proc~matmul_mat_vec_rel_opts->interface~matmul_blas proc~mv_3 formatmul_opts::mv_3 proc~matmul_mat_vec_rel_opts->proc~mv_3 proc~mv_4 formatmul_opts::mv_4 proc~matmul_mat_vec_rel_opts->proc~mv_4 proc~mv_5 formatmul_opts::mv_5 proc~matmul_mat_vec_rel_opts->proc~mv_5 proc~mv_6 formatmul_opts::mv_6 proc~matmul_mat_vec_rel_opts->proc~mv_6 proc~gemm_mat_mat_rel formatmul_opts::gemm_mat_mat_rel interface~matmul_blas->proc~gemm_mat_mat_rel proc~gemv_mat_vec_rel formatmul_opts::gemv_mat_vec_rel interface~matmul_blas->proc~gemv_mat_vec_rel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private impure function mat_mat (A, B, method, option) result(C) Matrix-matrix multiplication using coarray parallelism.\nauthor: Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) Input matrices A and B. real(kind=rk), intent(in), contiguous :: B (:,:) Input matrices A and B. character(len=*), intent(in) :: method Multiplication method ('coarray'). character(len=*), intent(in), optional :: option Optional method-specific option. Return Value real(kind=rk), (size(A,1),size(B,2)) Result matrix C. private impure function mat_vec (A, v, method, option) result(w) Matrix-vector multiplication using coarray parallelism.\nauthor: Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) Input matrix A and vector v. real(kind=rk), intent(in), contiguous :: v (:) Input matrix A and vector v. character(len=*), intent(in) :: method Multiplication method ('coarray'). character(len=*), intent(in), optional :: option Optional method-specific option. Return Value real(kind=rk), (size(A,1)) Result vector w.","tags":"","loc":"interface/matmul.html"},{"title":"start_benchmark – ForMatmul","text":"public  subroutine start_benchmark(t, m, n, o, msg) Arguments Type Intent Optional Attributes Name type(timer), intent(out) :: t integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: o character(len=*), intent(in) :: msg Calls proc~~start_benchmark~~CallsGraph proc~start_benchmark formatmul_benchmark::start_benchmark timer_start timer_start proc~start_benchmark->timer_start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~start_benchmark~~CalledByGraph proc~start_benchmark formatmul_benchmark::start_benchmark program~benchmark3 benchmark3 program~benchmark3->proc~start_benchmark program~benchmark4 benchmark4 program~benchmark4->proc~start_benchmark Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine start_benchmark ( t , m , n , o , msg ) type ( timer ), intent ( out ) :: t character ( * ), intent ( in ) :: msg integer , intent ( in ) :: m , n , o #if defined(USE_COARRAY) sync all if ( this_image () == 1 ) then print \"(a,', m=',g0,', n=',g0,', o=',g0)\" , msg , m , n , o end if call t % timer_start () #else print \"(a,', m=',g0,', n=',g0,', o=',g0)\" , msg , m , n , o call t % timer_start () #endif end subroutine start_benchmark","tags":"","loc":"proc/start_benchmark.html"},{"title":"stop_benchmark – ForMatmul","text":"public  subroutine stop_benchmark(t, m, n, o, nloops, Mat, Mat_ref, method, filename) Arguments Type Intent Optional Attributes Name type(timer), intent(inout) :: t [*] integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: o integer, intent(in) :: nloops real(kind=rk), intent(in) :: Mat (m,o) real(kind=rk), intent(in) :: Mat_ref (m,o) character(len=*), intent(in) :: method character(len=*), intent(in) :: filename Calls proc~~stop_benchmark~~CallsGraph proc~stop_benchmark formatmul_benchmark::stop_benchmark proc~write_benchmark formatmul_benchmark::write_benchmark proc~stop_benchmark->proc~write_benchmark timer_stop timer_stop proc~stop_benchmark->timer_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~stop_benchmark~~CalledByGraph proc~stop_benchmark formatmul_benchmark::stop_benchmark program~benchmark3 benchmark3 program~benchmark3->proc~stop_benchmark program~benchmark4 benchmark4 program~benchmark4->proc~stop_benchmark Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine stop_benchmark ( t , m , n , o , nloops , Mat , Mat_ref , method , filename ) #if defined(USE_COARRAY) type ( timer ), intent ( inout ) :: t [ * ] #else type ( timer ), intent ( inout ) :: t #endif integer , intent ( in ) :: m , n , o , nloops real ( rk ), intent ( in ) :: Mat ( m , o ), Mat_ref ( m , o ) character ( * ), intent ( in ) :: method character ( * ), intent ( in ) :: filename integer :: nunit , i real ( rk ) :: elapsed_time_average #if defined(USE_COARRAY) real ( rk ), allocatable :: gflops [:] #else real ( rk ) :: gflops #endif real ( rk ) :: gflops_total #if defined(USE_COARRAY) allocate ( gflops [ * ]) call t [ this_image ()]% timer_stop ( message = ' Elapsed time :' , nloops = nloops ) gflops [ this_image ()] = real ( m , rk ) * real ( n , rk ) * real ( o , rk ) * 1e-9_rk / t [ this_image ()]% elapsed_time print '(a,f6.2,a)' , ' Performance  : ' , gflops [ this_image ()], ' [GFLOPS/image]' sync all if ( this_image () == 1 ) then elapsed_time_average = 0.0_rk gflops_total = 0.0_rk do i = 1 , num_images () elapsed_time_average = elapsed_time_average + t [ i ]% elapsed_time gflops_total = gflops_total + gflops [ i ] end do elapsed_time_average = elapsed_time_average / num_images () print '(a,3e13.6)' , ' Relative err.: ' , norm2 ( Mat_ref - Mat ) / norm2 ( Mat_ref ) print '(a,f7.3,a)' , ' Elapsed time (average) :' , elapsed_time_average , ' [s]' print '(a,f6.2,a)' , ' Performance  (total)   : ' , gflops_total , ' [GFLOPS]' print '(a)' , '' end if call co_broadcast ( elapsed_time_average , 1 ) call co_broadcast ( gflops_total , 1 ) call write_benchmark ( method , m , n , o , nloops , t , elapsed_time_average , gflops , gflops_total , filename ) #else call t % timer_stop ( message = ' Elapsed time :' , nloops = nloops ) gflops = real ( m , rk ) * real ( n , rk ) * real ( o , rk ) * 1e-9_rk / t % elapsed_time print '(a,f6.2,a)' , ' Performance  : ' , gflops , ' [GFLOPS]' print '(a,3e13.6)' , ' Relative err.: ' , norm2 ( Mat_ref - Mat ) / norm2 ( Mat_ref ) print '(a,f7.3,a)' , ' Elapsed time :' , t % elapsed_time , ' [s]' print '(a,f6.2,a)' , ' Performance  : ' , gflops , ' [GFLOPS]' print '(a)' , '' call write_benchmark ( method , m , n , o , nloops , t , elapsed_time_average , gflops , gflops_total , filename ) #endif end subroutine stop_benchmark","tags":"","loc":"proc/stop_benchmark.html"},{"title":"write_benchmark – ForMatmul","text":"public  subroutine write_benchmark(method, m, n, o, nloops, t, elapsed_time_average, gflops, gflops_total, filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: method integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: o integer, intent(in) :: nloops type(timer), intent(in) :: t [*] real(kind=rk), intent(in) :: elapsed_time_average real(kind=rk) :: gflops [*] real(kind=rk), intent(in) :: gflops_total character(len=*), intent(in) :: filename Called by proc~~write_benchmark~~CalledByGraph proc~write_benchmark formatmul_benchmark::write_benchmark proc~stop_benchmark formatmul_benchmark::stop_benchmark proc~stop_benchmark->proc~write_benchmark program~benchmark3 benchmark3 program~benchmark3->proc~stop_benchmark program~benchmark4 benchmark4 program~benchmark4->proc~stop_benchmark Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine write_benchmark ( method , m , n , o , nloops , t , elapsed_time_average , gflops , gflops_total , filename ) character ( * ), intent ( in ) :: method integer , intent ( in ) :: m , n , o , nloops #if defined(USE_COARRAY) type ( timer ), intent ( in ) :: t [ * ] #else type ( timer ), intent ( in ) :: t #endif character ( * ), intent ( in ) :: filename real ( rk ), intent ( in ) :: elapsed_time_average real ( rk ), intent ( in ) :: gflops_total integer :: nunit #if defined(USE_COARRAY) real ( rk ) :: gflops [ * ] #else real ( rk ) :: gflops #endif #if defined(USE_COARRAY) open ( newunit = nunit , file = filename , access = 'append' ) write ( nunit , '(a,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0)' ) & method , m , n , o , nloops , t [ this_image ()]% elapsed_time , gflops [ this_image ()], elapsed_time_average , gflops_total close ( nunit ) #else open ( newunit = nunit , file = filename , access = 'append' ) write ( nunit , '(a,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0)' ) & method , m , n , o , nloops , t % elapsed_time , gflops , elapsed_time_average , gflops_total close ( nunit ) #endif end subroutine write_benchmark","tags":"","loc":"proc/write_benchmark.html"},{"title":"formatmul_opts – ForMatmul","text":"Uses kinds module~~formatmul_opts~~UsesGraph module~formatmul_opts formatmul_opts kinds kinds module~formatmul_opts->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~formatmul_opts~~UsedByGraph module~formatmul_opts formatmul_opts module~formatmul formatmul module~formatmul->module~formatmul_opts program~benchmark1 benchmark1 program~benchmark1->module~formatmul_opts program~benchmark1->module~formatmul program~benchmark2 benchmark2 program~benchmark2->module~formatmul_opts program~benchmark2->module~formatmul program~example5 example5 program~example5->module~formatmul_opts program~example7 example7 program~example7->module~formatmul_opts program~benchmark3 benchmark3 program~benchmark3->module~formatmul program~benchmark4 benchmark4 program~benchmark4->module~formatmul program~example1 example1 program~example1->module~formatmul program~example2 example2 program~example2->module~formatmul program~example3 example3 program~example3->module~formatmul program~example4 example4 program~example4->module~formatmul program~example6 example6 program~example6->module~formatmul program~example8 example8 program~example8->module~formatmul program~mat_mat mat_mat program~mat_mat->module~formatmul program~mat_vec mat_vec program~mat_vec->module~formatmul Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface matmul_opts private pure function matmul_mat_mat_rel_opts (A, B, option) result(C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) character(len=*), intent(in) :: option Return Value real(kind=rk), (size(A,1),size(B,2)) private pure function matmul_mat_vec_rel_opts (A, v, option) result(w) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) character(len=*), intent(in) :: option Return Value real(kind=rk), (size(A,1)) public        interface matmul_blas Interface for BLAS-based matrix multiplication functions. private pure function gemm_mat_mat_rel (A, B) result(C) Matrix-matrix multiplication using BLAS.\nauthor: Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A Input matrices A and B. real(kind=rk), intent(in), dimension(:, :), contiguous :: B Return Value real(kind=rk), dimension(size(A,1), size(B,2)) Result matrix C. private pure function gemv_mat_vec_rel (A, x) result(y) Matrix-vector multiplication using BLAS.\nauthor: Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A Input matrix A and vector x. real(kind=rk), intent(in), dimension(:), contiguous :: x Return Value real(kind=rk), dimension(size(A,1)) Result vector y. Functions private pure function matmul_mat_mat_rel_opts (A, B, option) result(C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) character(len=*), intent(in) :: option Return Value real(kind=rk), (size(A,1),size(B,2)) private pure function matmul_mat_vec_rel_opts (A, v, option) result(w) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) character(len=*), intent(in) :: option Return Value real(kind=rk), (size(A,1)) private pure function gemm_mat_mat_rel (A, B) result(C) Matrix-matrix multiplication using BLAS.\nauthor: Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A Input matrices A and B. real(kind=rk), intent(in), dimension(:, :), contiguous :: B Return Value real(kind=rk), dimension(size(A,1), size(B,2)) Result matrix C. private pure function gemv_mat_vec_rel (A, x) result(y) Matrix-vector multiplication using BLAS.\nauthor: Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A Input matrix A and vector x. real(kind=rk), intent(in), dimension(:), contiguous :: x Return Value real(kind=rk), dimension(size(A,1)) Result vector y. Subroutines private pure subroutine mm_mnp (m, n, p, a, b, c) Author @tyrandis Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: p real(kind=rk), intent(in) :: a (m,n) real(kind=rk), intent(in) :: b (n,p) real(kind=rk), intent(out) :: c (m,p) private pure subroutine mm_mpn (m, n, p, a, b, c) Author @tyrandis Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: p real(kind=rk), intent(in) :: a (m,n) real(kind=rk), intent(in) :: b (n,p) real(kind=rk), intent(out) :: c (m,p) private pure subroutine mm_nmp (m, n, p, a, b, c) Author @tyrandis Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: p real(kind=rk), intent(in) :: a (m,n) real(kind=rk), intent(in) :: b (n,p) real(kind=rk), intent(out) :: c (m,p) private pure subroutine mm_npm (m, n, p, a, b, c) Author @tyrandis Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: p real(kind=rk), intent(in) :: a (m,n) real(kind=rk), intent(in) :: b (n,p) real(kind=rk), intent(out) :: c (m,p) private pure subroutine mm_pmn (m, n, p, a, b, c) Author @tyrandis Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: p real(kind=rk), intent(in) :: a (m,n) real(kind=rk), intent(in) :: b (n,p) real(kind=rk), intent(out) :: c (m,p) private pure subroutine mm_pnm (m, n, p, a, b, c) Author @tyrandis Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: p real(kind=rk), intent(in) :: a (m,n) real(kind=rk), intent(in) :: b (n,p) real(kind=rk), intent(out) :: c (m,p) private pure subroutine mm_9 (m, n, p, a, b, c) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: p real(kind=rk), intent(in) :: a (m,n) real(kind=rk), intent(in) :: b (n,p) real(kind=rk), intent(out) :: c (m,p) private pure subroutine mm_10 (m, n, p, a, b, c) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: p real(kind=rk), intent(in) :: a (m,n) real(kind=rk), intent(in) :: b (n,p) real(kind=rk), intent(out) :: c (m,p) private pure subroutine mm_11 (m, n, p, a, b, c) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: p real(kind=rk), intent(in) :: a (m,n) real(kind=rk), intent(in) :: b (n,p) real(kind=rk), intent(out) :: c (m,p) private pure subroutine mm_12 (m, n, p, a, b, c) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: p real(kind=rk), intent(in) :: a (m,n) real(kind=rk), intent(in) :: b (n,p) real(kind=rk), intent(out) :: c (m,p) private pure subroutine mm_13 (m, n, p, a, b, c) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: p real(kind=rk), intent(in) :: a (m,n) real(kind=rk), intent(in) :: b (n,p) real(kind=rk), intent(out) :: c (m,p) private pure subroutine mv_3 (m, n, a, b, c) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n real(kind=rk), intent(in) :: a (m,n) real(kind=rk), intent(in) :: b (n) real(kind=rk), intent(out) :: c (m) private pure subroutine mv_4 (m, n, a, b, c) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n real(kind=rk), intent(in) :: a (m,n) real(kind=rk), intent(in) :: b (n) real(kind=rk), intent(out) :: c (m) private pure subroutine mv_5 (m, n, a, b, c) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n real(kind=rk), intent(in) :: a (m,n) real(kind=rk), intent(in) :: b (n) real(kind=rk), intent(out) :: c (m) private pure subroutine mv_6 (m, n, a, b, c) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n real(kind=rk), intent(in) :: a (m,n) real(kind=rk), intent(in) :: b (n) real(kind=rk), intent(out) :: c (m)","tags":"","loc":"module/formatmul_opts.html"},{"title":"formatmul – ForMatmul","text":"This module provides matrix and vector multiplication functions using different methods. Use the kinds module for real(kind) type. Uses formatmul_opts kinds module~~formatmul~~UsesGraph module~formatmul formatmul kinds kinds module~formatmul->kinds module~formatmul_opts formatmul_opts module~formatmul->module~formatmul_opts module~formatmul_opts->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~formatmul~~UsedByGraph module~formatmul formatmul program~benchmark1 benchmark1 program~benchmark1->module~formatmul program~benchmark2 benchmark2 program~benchmark2->module~formatmul program~benchmark3 benchmark3 program~benchmark3->module~formatmul program~benchmark4 benchmark4 program~benchmark4->module~formatmul program~example1 example1 program~example1->module~formatmul program~example2 example2 program~example2->module~formatmul program~example3 example3 program~example3->module~formatmul program~example4 example4 program~example4->module~formatmul program~example6 example6 program~example6->module~formatmul program~example8 example8 program~example8->module~formatmul program~mat_mat mat_mat program~mat_mat->module~formatmul program~mat_vec mat_vec program~mat_vec->module~formatmul Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface matmul Interface for matrix multiplication functions. private impure function mat_mat (A, B, method, option) result(C) Matrix-matrix multiplication using coarray parallelism.\nauthor: Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) Input matrices A and B. real(kind=rk), intent(in), contiguous :: B (:,:) Input matrices A and B. character(len=*), intent(in) :: method Multiplication method ('coarray'). character(len=*), intent(in), optional :: option Optional method-specific option. Return Value real(kind=rk), (size(A,1),size(B,2)) Result matrix C. private impure function mat_vec (A, v, method, option) result(w) Matrix-vector multiplication using coarray parallelism.\nauthor: Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) Input matrix A and vector v. real(kind=rk), intent(in), contiguous :: v (:) Input matrix A and vector v. character(len=*), intent(in) :: method Multiplication method ('coarray'). character(len=*), intent(in), optional :: option Optional method-specific option. Return Value real(kind=rk), (size(A,1)) Result vector w. Functions private impure function mat_mat (A, B, method, option) result(C) Matrix-matrix multiplication using coarray parallelism.\nauthor: Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) Input matrices A and B. real(kind=rk), intent(in), contiguous :: B (:,:) Input matrices A and B. character(len=*), intent(in) :: method Multiplication method ('coarray'). character(len=*), intent(in), optional :: option Optional method-specific option. Return Value real(kind=rk), (size(A,1),size(B,2)) Result matrix C. private impure function mat_vec (A, v, method, option) result(w) Matrix-vector multiplication using coarray parallelism.\nauthor: Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) Input matrix A and vector v. real(kind=rk), intent(in), contiguous :: v (:) Input matrix A and vector v. character(len=*), intent(in) :: method Multiplication method ('coarray'). character(len=*), intent(in), optional :: option Optional method-specific option. Return Value real(kind=rk), (size(A,1)) Result vector w. Subroutines private pure subroutine compute_block_ranges (d, nimg, block_size, start_elem, end_elem) Calculate block sizes and ranges.\nauthor: Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name integer, intent(in) :: d integer, intent(in) :: nimg integer, intent(out) :: block_size (nimg) integer, intent(out) :: start_elem (nimg) integer, intent(out) :: end_elem (nimg)","tags":"","loc":"module/formatmul.html"},{"title":"formatmul_benchmark – ForMatmul","text":"Uses fortime kinds module~~formatmul_benchmark~~UsesGraph module~formatmul_benchmark formatmul_benchmark fortime fortime module~formatmul_benchmark->fortime kinds kinds module~formatmul_benchmark->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~formatmul_benchmark~~UsedByGraph module~formatmul_benchmark formatmul_benchmark program~benchmark3 benchmark3 program~benchmark3->module~formatmul_benchmark program~benchmark4 benchmark4 program~benchmark4->module~formatmul_benchmark Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine start_benchmark (t, m, n, o, msg) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name type(timer), intent(out) :: t integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: o character(len=*), intent(in) :: msg public  subroutine stop_benchmark (t, m, n, o, nloops, Mat, Mat_ref, method, filename) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name type(timer), intent(inout) :: t [*] integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: o integer, intent(in) :: nloops real(kind=rk), intent(in) :: Mat (m,o) real(kind=rk), intent(in) :: Mat_ref (m,o) character(len=*), intent(in) :: method character(len=*), intent(in) :: filename public  subroutine write_benchmark (method, m, n, o, nloops, t, elapsed_time_average, gflops, gflops_total, filename) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: method integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: o integer, intent(in) :: nloops type(timer), intent(in) :: t [*] real(kind=rk), intent(in) :: elapsed_time_average real(kind=rk) :: gflops [*] real(kind=rk), intent(in) :: gflops_total character(len=*), intent(in) :: filename","tags":"","loc":"module/formatmul_benchmark.html"},{"title":"example5 – ForMatmul","text":"Uses formatmul_opts fortime kinds program~~example5~~UsesGraph program~example5 example5 fortime fortime program~example5->fortime kinds kinds program~example5->kinds module~formatmul_opts formatmul_opts program~example5->module~formatmul_opts module~formatmul_opts->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~example5~~CallsGraph program~example5 example5 interface~matmul_blas formatmul_opts::matmul_blas program~example5->interface~matmul_blas timer_start timer_start program~example5->timer_start timer_stop timer_stop program~example5->timer_stop proc~gemm_mat_mat_rel formatmul_opts::gemm_mat_mat_rel interface~matmul_blas->proc~gemm_mat_mat_rel proc~gemv_mat_vec_rel formatmul_opts::gemv_mat_vec_rel interface~matmul_blas->proc~gemv_mat_vec_rel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:,:) real(kind=rk), allocatable :: B (:,:) real(kind=rk), allocatable :: C (:,:) type(timer) :: t integer :: m integer :: n integer :: o Source Code program example5 use kinds , only : rk use fortime , only : timer use formatmul_opts , only : matmul_blas implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C (:,:) type ( timer ) :: t integer :: m , n , o ! C(m,o) = A(m,n).B(n,o) m = 64 * 2 * 100 n = 16 * 100 o = 64 * 10 allocate ( A ( m , n ), B ( n , o )) call random_number ( A ) call random_number ( B ) #if defined(USE_COARRAY) sync all if ( this_image () == 1 ) call t % timer_start () C = matmul_blas ( A , B ) if ( this_image () == 1 ) call t % timer_stop ( message = ' Elapsed time (example5: mat_mat with blas):' ) #else call t % timer_start () C = matmul_blas ( A , B ) call t % timer_stop ( message = ' Elapsed time (example5: mat_mat with blas):' ) #endif end program example5","tags":"","loc":"program/example5.html"},{"title":"example6 – ForMatmul","text":"Uses fortime kinds formatmul program~~example6~~UsesGraph program~example6 example6 fortime fortime program~example6->fortime kinds kinds program~example6->kinds module~formatmul formatmul program~example6->module~formatmul module~formatmul->kinds module~formatmul_opts formatmul_opts module~formatmul->module~formatmul_opts module~formatmul_opts->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~example6~~CallsGraph program~example6 example6 timer_start timer_start program~example6->timer_start timer_stop timer_stop program~example6->timer_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:,:) real(kind=rk), allocatable :: B (:,:) real(kind=rk), allocatable :: C (:,:) type(timer) :: t integer :: m integer :: n integer :: o Source Code program example6 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C (:,:) type ( timer ) :: t integer :: m , n , o ! C(m,o) = A(m,n).B(n,o) m = 64 * 2 * 100 n = 16 * 100 o = 64 * 10 allocate ( A ( m , n ), B ( n , o )) call random_number ( A ) call random_number ( B ) #if defined(USE_COARRAY) sync all call t % timer_start () C = matmul ( A , B , 'coarray' , option = 'm2' ) call t % timer_stop ( message = ' Elapsed time (example6: mat_mat, coarray with blas):' ) #else call t % timer_start () C = matmul ( A , B , 'default' , option = 'm2' ) call t % timer_stop ( message = ' Elapsed time (example6: mat_mat, blas):' ) #endif end program example6","tags":"","loc":"program/example6.html"},{"title":"example1 – ForMatmul","text":"Uses fortime kinds formatmul program~~example1~~UsesGraph program~example1 example1 fortime fortime program~example1->fortime kinds kinds program~example1->kinds module~formatmul formatmul program~example1->module~formatmul module~formatmul->kinds module~formatmul_opts formatmul_opts module~formatmul->module~formatmul_opts module~formatmul_opts->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~example1~~CallsGraph program~example1 example1 timer_start timer_start program~example1->timer_start timer_stop timer_stop program~example1->timer_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:,:) real(kind=rk), allocatable :: B (:,:) real(kind=rk), allocatable :: C (:,:) type(timer) :: t integer :: m integer :: n integer :: o Source Code program example1 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C (:,:) type ( timer ) :: t integer :: m , n , o ! C(m,o) = A(m,n).B(n,o) m = 64 * 2 * 100 n = 16 * 100 o = 64 * 10 allocate ( A ( m , n ), B ( n , o )) call random_number ( A ) call random_number ( B ) #if defined(USE_COARRAY) sync all if ( this_image () == 1 ) call t % timer_start () C = matmul ( A , B ) if ( this_image () == 1 ) call t % timer_stop ( message = ' Elapsed time (example1: mat_mat):' ) #else call t % timer_start () C = matmul ( A , B ) call t % timer_stop ( message = ' Elapsed time (example1: mat_mat):' ) #endif end program example1","tags":"","loc":"program/example1.html"},{"title":"example2 – ForMatmul","text":"Uses fortime kinds formatmul program~~example2~~UsesGraph program~example2 example2 fortime fortime program~example2->fortime kinds kinds program~example2->kinds module~formatmul formatmul program~example2->module~formatmul module~formatmul->kinds module~formatmul_opts formatmul_opts module~formatmul->module~formatmul_opts module~formatmul_opts->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~example2~~CallsGraph program~example2 example2 timer_start timer_start program~example2->timer_start timer_stop timer_stop program~example2->timer_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:,:) real(kind=rk), allocatable :: B (:,:) real(kind=rk), allocatable :: C (:,:) type(timer) :: t integer :: m integer :: n integer :: o Source Code program example2 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C (:,:) type ( timer ) :: t integer :: m , n , o ! C(m,o) = A(m,n).B(n,o) m = 64 * 2 * 100 n = 16 * 100 o = 64 * 10 allocate ( A ( m , n ), B ( n , o )) call random_number ( A ) call random_number ( B ) #if defined(USE_COARRAY) sync all call t % timer_start () C = matmul ( A , B , 'coarray' ) call t % timer_stop ( message = ' Elapsed time (example2: mat_mat, coarray):' ) #else call t % timer_start () C = matmul ( A , B ) call t % timer_stop ( message = ' Elapsed time (example2: mat_mat):' ) #endif end program example2","tags":"","loc":"program/example2.html"},{"title":"benchmark4 – ForMatmul","text":"Uses formatmul_benchmark fortime kinds formatmul iso_fortran_env program~~benchmark4~~UsesGraph program~benchmark4 benchmark4 fortime fortime program~benchmark4->fortime iso_fortran_env iso_fortran_env program~benchmark4->iso_fortran_env kinds kinds program~benchmark4->kinds module~formatmul formatmul program~benchmark4->module~formatmul module~formatmul_benchmark formatmul_benchmark program~benchmark4->module~formatmul_benchmark module~formatmul->kinds module~formatmul_opts formatmul_opts module~formatmul->module~formatmul_opts module~formatmul_benchmark->fortime module~formatmul_benchmark->kinds module~formatmul_opts->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~benchmark4~~CallsGraph program~benchmark4 benchmark4 proc~start_benchmark formatmul_benchmark::start_benchmark program~benchmark4->proc~start_benchmark proc~stop_benchmark formatmul_benchmark::stop_benchmark program~benchmark4->proc~stop_benchmark timer_start timer_start proc~start_benchmark->timer_start proc~write_benchmark formatmul_benchmark::write_benchmark proc~stop_benchmark->proc~write_benchmark timer_stop timer_stop proc~stop_benchmark->timer_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:,:) real(kind=rk), allocatable :: v (:) real(kind=rk), allocatable :: w_ref (:) real(kind=rk), allocatable :: w (:) type(timer) :: t [*] type(timer) :: t integer :: m integer :: n integer :: i integer :: nloops integer :: p integer :: unit_num integer :: im integer :: nim character(len=:), allocatable :: file_name character(len=1000) :: im_chr Source Code program benchmark4 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul use formatmul_benchmark , only : start_benchmark , stop_benchmark , write_benchmark use , intrinsic :: iso_fortran_env , only : compiler_version , compiler_options implicit none real ( rk ), allocatable :: A (:,:), v (:) real ( rk ), allocatable :: w_ref (:), w (:) #if defined(USE_COARRAY) type ( timer ) :: t [ * ] #else type ( timer ) :: t #endif integer :: m , n , i , nloops , p , unit_num , im , nim character ( len = :), allocatable :: file_name character ( len = 1000 ) :: im_chr nloops = 10 #if defined(USE_COARRAY) im = this_image () nim = num_images () write ( im_chr , '(i0)' ) im file_name = \"benchmark/benchmark4_im\" // trim ( im_chr ) // \".data\" #else file_name = \"benchmark/benchmark4.data\" #endif open ( newunit = unit_num , file = file_name ) write ( unit_num , '(a)' ) 'ForMatmul' write ( unit_num , '(a)' ) compiler_version () write ( unit_num , '(a)' ) compiler_options () #if defined(USE_COARRAY) write ( unit_num , \"(g0,' ',g0)\" ) im , nim #endif close ( unit_num ) do p = 250 , 30000 , 250 ! w(m) = A(m,n).v(n) m = p n = p if ( allocated ( A )) deallocate ( A ) if ( allocated ( v )) deallocate ( v ) if ( allocated ( w )) deallocate ( w ) if ( allocated ( w_ref )) deallocate ( w_ref ) allocate ( A ( m , n )) allocate ( v ( n )) allocate ( w ( m )) allocate ( w_ref ( m )) call random_number ( A ) call random_number ( v ) #if defined(USE_COARRAY) call start_benchmark ( t [ im ], m , n , 1 , \"w_ref = matmul(A,v)\" ) do i = 1 , nloops w_ref = matmul ( A , v ) end do call stop_benchmark ( t [ im ], m , n , 1 , nloops , w_ref , w_ref , 'Matmul' , file_name ) #else call start_benchmark ( t , m , n , 1 , \"w_ref = matmul(A,v)\" ) do i = 1 , nloops w_ref = matmul ( A , v ) end do call stop_benchmark ( t , m , n , 1 , nloops , w_ref , w_ref , 'Matmul' , file_name ) #endif #if defined(USE_COARRAY) call start_benchmark ( t [ im ], m , n , 1 , \"w = matmul(A,v,'coarray','m1')\" ) do i = 1 , nloops w = matmul ( A , v , 'coarray' , 'm1' ) end do call stop_benchmark ( t [ im ], m , n , 1 , nloops , w , w_ref , 'coarray_Matmul' , file_name ) #else call start_benchmark ( t , m , n , 1 , \"w = matmul(A,v,'default','m1')\" ) do i = 1 , nloops w = matmul ( A , v , 'default' , 'm1' ) end do call stop_benchmark ( t , m , n , 1 , nloops , w , w_ref , 'default_Matmul' , file_name ) #endif #if defined(USE_COARRAY) call start_benchmark ( t [ im ], m , n , 1 , \"w = matmul(A,v,'coarray','m2')\" ) do i = 1 , nloops w = matmul ( A , v , 'coarray' , 'm2' ) end do call stop_benchmark ( t [ im ], m , n , 1 , nloops , w , w_ref , 'coarray_dgemm' , file_name ) #else call start_benchmark ( t , m , n , 1 , \"w = matmul(A,v,'default','m2')\" ) do i = 1 , nloops w = matmul ( A , v , 'default' , 'm2' ) end do call stop_benchmark ( t , m , n , 1 , nloops , w , w_ref , 'default_dgemm' , file_name ) #endif #if defined(USE_COARRAY) call start_benchmark ( t [ im ], m , n , 1 , \"w = matmul(A,v,'coarray','m3')\" ) do i = 1 , nloops w = matmul ( A , v , 'coarray' , 'm3' ) end do call stop_benchmark ( t [ im ], m , n , 1 , nloops , w , w_ref , 'coarray_m3' , file_name ) #else call start_benchmark ( t , m , n , 1 , \"w = matmul(A,v,'default','m3')\" ) do i = 1 , nloops w = matmul ( A , v , 'default' , 'm3' ) end do call stop_benchmark ( t , m , n , 1 , nloops , w , w_ref , 'default_m3' , file_name ) #endif #if defined(USE_COARRAY) call start_benchmark ( t [ im ], m , n , 1 , \"w = matmul(A,v,'coarray','m4')\" ) do i = 1 , nloops w = matmul ( A , v , 'coarray' , 'm4' ) end do call stop_benchmark ( t [ im ], m , n , 1 , nloops , w , w_ref , 'coarray_m4' , file_name ) #else call start_benchmark ( t , m , n , 1 , \"w = matmul(A,v,'default','m4')\" ) do i = 1 , nloops w = matmul ( A , v , 'default' , 'm4' ) end do call stop_benchmark ( t , m , n , 1 , nloops , w , w_ref , 'default_m4' , file_name ) #endif #if defined(USE_COARRAY) call start_benchmark ( t [ im ], m , n , 1 , \"w = matmul(A,v,'coarray','m5')\" ) do i = 1 , nloops w = matmul ( A , v , 'coarray' , 'm5' ) end do call stop_benchmark ( t [ im ], m , n , 1 , nloops , w , w_ref , 'coarray_m5' , file_name ) #else call start_benchmark ( t , m , n , 1 , \"w = matmul(A,v,'default','m5')\" ) do i = 1 , nloops w = matmul ( A , v , 'default' , 'm5' ) end do call stop_benchmark ( t , m , n , 1 , nloops , w , w_ref , 'default_m5' , file_name ) #endif #if defined(USE_COARRAY) call start_benchmark ( t [ im ], m , n , 1 , \"w = matmul(A,v,'coarray','m6')\" ) do i = 1 , nloops w = matmul ( A , v , 'coarray' , 'm6' ) end do call stop_benchmark ( t [ im ], m , n , 1 , nloops , w , w_ref , 'coarray_m6' , file_name ) #else call start_benchmark ( t , m , n , 1 , \"w = matmul(A,v,'default','m6')\" ) do i = 1 , nloops w = matmul ( A , v , 'default' , 'm6' ) end do call stop_benchmark ( t , m , n , 1 , nloops , w , w_ref , 'default_m6' , file_name ) #endif end do end program benchmark4","tags":"","loc":"program/benchmark4.html"},{"title":"example7 – ForMatmul","text":"Uses formatmul_opts fortime kinds program~~example7~~UsesGraph program~example7 example7 fortime fortime program~example7->fortime kinds kinds program~example7->kinds module~formatmul_opts formatmul_opts program~example7->module~formatmul_opts module~formatmul_opts->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~example7~~CallsGraph program~example7 example7 interface~matmul_blas formatmul_opts::matmul_blas program~example7->interface~matmul_blas timer_start timer_start program~example7->timer_start timer_stop timer_stop program~example7->timer_stop proc~gemm_mat_mat_rel formatmul_opts::gemm_mat_mat_rel interface~matmul_blas->proc~gemm_mat_mat_rel proc~gemv_mat_vec_rel formatmul_opts::gemv_mat_vec_rel interface~matmul_blas->proc~gemv_mat_vec_rel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:,:) real(kind=rk), allocatable :: v (:) real(kind=rk), allocatable :: w (:) type(timer) :: t integer :: m integer :: n Source Code program example7 use kinds , only : rk use fortime , only : timer use formatmul_opts , only : matmul_blas implicit none real ( rk ), allocatable :: A (:,:), v (:) real ( rk ), allocatable :: w (:) type ( timer ) :: t integer :: m , n ! w(m) = A(m,n).v(n) m = 64 * 2 * 100 n = 16 * 2 * 100 allocate ( A ( m , n ), v ( n )) call random_number ( A ) call random_number ( v ) #if defined(USE_COARRAY) sync all if ( this_image () == 1 ) call t % timer_start () w = matmul_blas ( A , v ) if ( this_image () == 1 ) call t % timer_stop ( message = ' Elapsed time (example7: mat_vec with blas):' ) #else call t % timer_start () w = matmul_blas ( A , v ) call t % timer_stop ( message = ' Elapsed time (example7: mat_vec with blas):' ) #endif end program example7","tags":"","loc":"program/example7.html"},{"title":"mat_mat – ForMatmul","text":"Uses fortime kinds formatmul program~~mat_mat~~UsesGraph program~mat_mat mat_mat fortime fortime program~mat_mat->fortime kinds kinds program~mat_mat->kinds module~formatmul formatmul program~mat_mat->module~formatmul module~formatmul->kinds module~formatmul_opts formatmul_opts module~formatmul->module~formatmul_opts module~formatmul_opts->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:,:) real(kind=rk), allocatable :: B (:,:) real(kind=rk), allocatable :: C (:,:) real(kind=rk), allocatable :: C_co (:,:) type(timer) :: t integer :: m integer :: n integer :: o Source Code program mat_mat use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C (:,:), C_co (:,:) type ( timer ) :: t integer :: m , n , o ! C(m,o) = A(m,n).B(n,o) m = 200 n = 100 o = 10 allocate ( A ( m , n ), B ( n , o )) call random_number ( A ) call random_number ( B ) #if defined(USE_COARRAY) sync all #endif C = matmul ( A , B ) #if defined(USE_COARRAY) sync all C_co = matmul ( A , B , 'coarray' ) sync all if ( this_image () == 1 ) print * , 'test1: relative error:' , norm2 ( C - C_co ) / norm2 ( C ) #endif end program mat_mat","tags":"","loc":"program/mat_mat.html"},{"title":"example8 – ForMatmul","text":"Uses fortime kinds formatmul program~~example8~~UsesGraph program~example8 example8 fortime fortime program~example8->fortime kinds kinds program~example8->kinds module~formatmul formatmul program~example8->module~formatmul module~formatmul->kinds module~formatmul_opts formatmul_opts module~formatmul->module~formatmul_opts module~formatmul_opts->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~example8~~CallsGraph program~example8 example8 timer_start timer_start program~example8->timer_start timer_stop timer_stop program~example8->timer_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:,:) real(kind=rk), allocatable :: v (:) real(kind=rk), allocatable :: w (:) type(timer) :: t integer :: m integer :: n Source Code program example8 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), v (:) real ( rk ), allocatable :: w (:) type ( timer ) :: t integer :: m , n ! w(m) = A(m,n).v(n) m = 64 * 2 * 100 n = 16 * 2 * 100 allocate ( A ( m , n ), v ( n )) call random_number ( A ) call random_number ( v ) #if defined(USE_COARRAY) sync all call t % timer_start () w = matmul ( A , v , 'coarray' , option = 'm2' ) call t % timer_stop ( message = ' Elapsed time (example8: mat_vec, coarray with blas):' ) #else call t % timer_start () w = matmul ( A , v , 'default' , option = 'm2' ) call t % timer_stop ( message = ' Elapsed time (example8: mat_vec, blas):' ) #endif end program example8","tags":"","loc":"program/example8.html"},{"title":"benchmark3 – ForMatmul","text":"Uses formatmul_benchmark fortime kinds formatmul iso_fortran_env program~~benchmark3~~UsesGraph program~benchmark3 benchmark3 fortime fortime program~benchmark3->fortime iso_fortran_env iso_fortran_env program~benchmark3->iso_fortran_env kinds kinds program~benchmark3->kinds module~formatmul formatmul program~benchmark3->module~formatmul module~formatmul_benchmark formatmul_benchmark program~benchmark3->module~formatmul_benchmark module~formatmul->kinds module~formatmul_opts formatmul_opts module~formatmul->module~formatmul_opts module~formatmul_benchmark->fortime module~formatmul_benchmark->kinds module~formatmul_opts->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~benchmark3~~CallsGraph program~benchmark3 benchmark3 proc~start_benchmark formatmul_benchmark::start_benchmark program~benchmark3->proc~start_benchmark proc~stop_benchmark formatmul_benchmark::stop_benchmark program~benchmark3->proc~stop_benchmark timer_start timer_start proc~start_benchmark->timer_start proc~write_benchmark formatmul_benchmark::write_benchmark proc~stop_benchmark->proc~write_benchmark timer_stop timer_stop proc~stop_benchmark->timer_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:,:) real(kind=rk), allocatable :: B (:,:) real(kind=rk), allocatable :: C_ref (:,:) real(kind=rk), allocatable :: C (:,:) type(timer) :: t [*] type(timer) :: t integer :: m integer :: n integer :: o integer :: i integer :: nloops integer :: p integer :: unit_num integer :: im integer :: nim character(len=:), allocatable :: file_name character(len=1000) :: im_chr Source Code program benchmark3 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul use formatmul_benchmark , only : start_benchmark , stop_benchmark , write_benchmark use , intrinsic :: iso_fortran_env , only : compiler_version , compiler_options implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C_ref (:,:), C (:,:) #if defined(USE_COARRAY) type ( timer ) :: t [ * ] #else type ( timer ) :: t #endif integer :: m , n , o , i , nloops , p , unit_num , im , nim character ( len = :), allocatable :: file_name character ( len = 1000 ) :: im_chr nloops = 10 #if defined(USE_COARRAY) im = this_image () nim = num_images () write ( im_chr , '(i0)' ) im file_name = \"benchmark/benchmark3_im\" // trim ( im_chr ) // \".data\" #else file_name = \"benchmark/benchmark3.data\" #endif open ( newunit = unit_num , file = file_name ) write ( unit_num , '(a)' ) 'ForMatmul' write ( unit_num , '(a)' ) compiler_version () write ( unit_num , '(a)' ) compiler_options () #if defined(USE_COARRAY) write ( unit_num , \"(g0,' ',g0)\" ) im , nim #endif close ( unit_num ) do p = 250 , 4000 , 250 ! C(m,o) = A(m,n).B(n,o) m = p n = p o = p if ( allocated ( A )) deallocate ( A ) if ( allocated ( B )) deallocate ( B ) if ( allocated ( C )) deallocate ( C ) if ( allocated ( C_ref )) deallocate ( C_ref ) allocate ( A ( m , n )) allocate ( B ( n , o )) allocate ( C ( m , o )) allocate ( C_ref ( m , o )) call random_number ( A ) call random_number ( B ) #if defined(USE_COARRAY) call start_benchmark ( t [ im ], m , n , o , \"C_ref = matmul(A,B)\" ) do i = 1 , nloops C_ref = matmul ( A , B ) end do call stop_benchmark ( t [ im ], m , n , o , nloops , C_ref , C_ref , 'Matmul' , file_name ) #else call start_benchmark ( t , m , n , o , \"C_ref = matmul(A,B)\" ) do i = 1 , nloops C_ref = matmul ( A , B ) end do call stop_benchmark ( t , m , n , o , nloops , C_ref , C_ref , 'Matmul' , file_name ) #endif #if defined(USE_COARRAY) call start_benchmark ( t [ im ], m , n , o , \"C = matmul(A,B,'coarray','m1')\" ) do i = 1 , nloops C = matmul ( A , B , 'coarray' , 'm1' ) end do call stop_benchmark ( t [ im ], m , n , o , nloops , C , C_ref , 'coarray_Matmul' , file_name ) #else call start_benchmark ( t , m , n , o , \"C = matmul(A,B,'default','m1')\" ) do i = 1 , nloops C = matmul ( A , B , 'default' , 'm1' ) end do call stop_benchmark ( t , m , n , o , nloops , C , C_ref , 'default_Matmul' , file_name ) #endif #if defined(USE_COARRAY) call start_benchmark ( t [ im ], m , n , o , \"C = matmul(A,B,'coarray','m2')\" ) do i = 1 , nloops C = matmul ( A , B , 'coarray' , 'm2' ) end do call stop_benchmark ( t [ im ], m , n , o , nloops , C , C_ref , 'coarray_dgemm' , file_name ) #else call start_benchmark ( t , m , n , o , \"C = matmul(A,B,'default','m2')\" ) do i = 1 , nloops C = matmul ( A , B , 'default' , 'm2' ) end do call stop_benchmark ( t , m , n , o , nloops , C , C_ref , 'default_dgemm' , file_name ) #endif #if defined(USE_COARRAY) call start_benchmark ( t [ im ], m , n , o , \"C = matmul(A,B,'coarray','m3')\" ) do i = 1 , nloops C = matmul ( A , B , 'coarray' , 'm3' ) end do call stop_benchmark ( t [ im ], m , n , o , nloops , C , C_ref , 'coarray_m3' , file_name ) #else call start_benchmark ( t , m , n , o , \"C = matmul(A,B,'default','m3')\" ) do i = 1 , nloops C = matmul ( A , B , 'default' , 'm3' ) end do call stop_benchmark ( t , m , n , o , nloops , C , C_ref , 'default_m3' , file_name ) #endif #if defined(USE_COARRAY) call start_benchmark ( t [ im ], m , n , o , \"C = matmul(A,B,'coarray','m4')\" ) do i = 1 , nloops C = matmul ( A , B , 'coarray' , 'm4' ) end do call stop_benchmark ( t [ im ], m , n , o , nloops , C , C_ref , 'coarray_m4' , file_name ) #else call start_benchmark ( t , m , n , o , \"C = matmul(A,B,'default','m4')\" ) do i = 1 , nloops C = matmul ( A , B , 'default' , 'm4' ) end do call stop_benchmark ( t , m , n , o , nloops , C , C_ref , 'default_m4' , file_name ) #endif #if defined(USE_COARRAY) call start_benchmark ( t [ im ], m , n , o , \"C = matmul(A,B,'coarray','m5')\" ) do i = 1 , nloops C = matmul ( A , B , 'coarray' , 'm5' ) end do call stop_benchmark ( t [ im ], m , n , o , nloops , C , C_ref , 'coarray_m5' , file_name ) #else call start_benchmark ( t , m , n , o , \"C = matmul(A,B,'default','m5')\" ) do i = 1 , nloops C = matmul ( A , B , 'default' , 'm5' ) end do call stop_benchmark ( t , m , n , o , nloops , C , C_ref , 'default_m5' , file_name ) #endif #if defined(USE_COARRAY) call start_benchmark ( t [ im ], m , n , o , \"C = matmul(A,B,'coarray','m6')\" ) do i = 1 , nloops C = matmul ( A , B , 'coarray' , 'm6' ) end do call stop_benchmark ( t [ im ], m , n , o , nloops , C , C_ref , 'coarray_m6' , file_name ) #else call start_benchmark ( t , m , n , o , \"C = matmul(A,B,'default','m6')\" ) do i = 1 , nloops C = matmul ( A , B , 'default' , 'm6' ) end do call stop_benchmark ( t , m , n , o , nloops , C , C_ref , 'default_m6' , file_name ) #endif #if defined(USE_COARRAY) call start_benchmark ( t [ im ], m , n , o , \"C = matmul(A,B,'coarray','m7')\" ) do i = 1 , nloops C = matmul ( A , B , 'coarray' , 'm7' ) end do call stop_benchmark ( t [ im ], m , n , o , nloops , C , C_ref , 'coarray_m7' , file_name ) #else call start_benchmark ( t , m , n , o , \"C = matmul(A,B,'default','m7')\" ) do i = 1 , nloops C = matmul ( A , B , 'default' , 'm7' ) end do call stop_benchmark ( t , m , n , o , nloops , C , C_ref , 'default_m7' , file_name ) #endif #if defined(USE_COARRAY) call start_benchmark ( t [ im ], m , n , o , \"C = matmul(A,B,'coarray','m8')\" ) do i = 1 , nloops C = matmul ( A , B , 'coarray' , 'm8' ) end do call stop_benchmark ( t [ im ], m , n , o , nloops , C , C_ref , 'coarray_m8' , file_name ) #else call start_benchmark ( t , m , n , o , \"C = matmul(A,B,'default','m8')\" ) do i = 1 , nloops C = matmul ( A , B , 'default' , 'm8' ) end do call stop_benchmark ( t , m , n , o , nloops , C , C_ref , 'default_m8' , file_name ) #endif #if defined(USE_COARRAY) call start_benchmark ( t [ im ], m , n , o , \"C = matmul(A,B,'coarray','m9')\" ) do i = 1 , nloops C = matmul ( A , B , 'coarray' , 'm9' ) end do call stop_benchmark ( t [ im ], m , n , o , nloops , C , C_ref , 'coarray_m9' , file_name ) #else call start_benchmark ( t , m , n , o , \"C = matmul(A,B,'default','m9')\" ) do i = 1 , nloops C = matmul ( A , B , 'default' , 'm9' ) end do call stop_benchmark ( t , m , n , o , nloops , C , C_ref , 'default_m9' , file_name ) #endif #if defined(USE_COARRAY) call start_benchmark ( t [ im ], m , n , o , \"C = matmul(A,B,'coarray','m10')\" ) do i = 1 , nloops C = matmul ( A , B , 'coarray' , 'm10' ) end do call stop_benchmark ( t [ im ], m , n , o , nloops , C , C_ref , 'coarray_m10' , file_name ) #else call start_benchmark ( t , m , n , o , \"C = matmul(A,B,'default','m10')\" ) do i = 1 , nloops C = matmul ( A , B , 'default' , 'm10' ) end do call stop_benchmark ( t , m , n , o , nloops , C , C_ref , 'default_m10' , file_name ) #endif #if defined(USE_COARRAY) call start_benchmark ( t [ im ], m , n , o , \"C = matmul(A,B,'coarray','m11')\" ) do i = 1 , nloops C = matmul ( A , B , 'coarray' , 'm11' ) end do call stop_benchmark ( t [ im ], m , n , o , nloops , C , C_ref , 'coarray_m11' , file_name ) #else call start_benchmark ( t , m , n , o , \"C = matmul(A,B,'default','m11')\" ) do i = 1 , nloops C = matmul ( A , B , 'default' , 'm11' ) end do call stop_benchmark ( t , m , n , o , nloops , C , C_ref , 'default_m11' , file_name ) #endif #if defined(USE_COARRAY) call start_benchmark ( t [ im ], m , n , o , \"C = matmul(A,B,'coarray','m12')\" ) do i = 1 , nloops C = matmul ( A , B , 'coarray' , 'm12' ) end do call stop_benchmark ( t [ im ], m , n , o , nloops , C , C_ref , 'coarray_m12' , file_name ) #else call start_benchmark ( t , m , n , o , \"C = matmul(A,B,'default','m12')\" ) do i = 1 , nloops C = matmul ( A , B , 'default' , 'm12' ) end do call stop_benchmark ( t , m , n , o , nloops , C , C_ref , 'default_m12' , file_name ) #endif #if defined(USE_COARRAY) call start_benchmark ( t [ im ], m , n , o , \"C = matmul(A,B,'coarray','m13')\" ) do i = 1 , nloops C = matmul ( A , B , 'coarray' , 'm13' ) end do call stop_benchmark ( t [ im ], m , n , o , nloops , C , C_ref , 'coarray_m13' , file_name ) #else call start_benchmark ( t , m , n , o , \"C = matmul(A,B,'default','m13')\" ) do i = 1 , nloops C = matmul ( A , B , 'default' , 'm13' ) end do call stop_benchmark ( t , m , n , o , nloops , C , C_ref , 'default_m13' , file_name ) #endif end do end program benchmark3","tags":"","loc":"program/benchmark3.html"},{"title":"example4 – ForMatmul","text":"Uses fortime kinds formatmul program~~example4~~UsesGraph program~example4 example4 fortime fortime program~example4->fortime kinds kinds program~example4->kinds module~formatmul formatmul program~example4->module~formatmul module~formatmul->kinds module~formatmul_opts formatmul_opts module~formatmul->module~formatmul_opts module~formatmul_opts->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~example4~~CallsGraph program~example4 example4 timer_start timer_start program~example4->timer_start timer_stop timer_stop program~example4->timer_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:,:) real(kind=rk), allocatable :: v (:) real(kind=rk), allocatable :: w (:) type(timer) :: t integer :: m integer :: n Source Code program example4 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), v (:) real ( rk ), allocatable :: w (:) type ( timer ) :: t integer :: m , n ! w(m) = A(m,n).v(n) m = 64 * 2 * 100 n = 16 * 2 * 100 allocate ( A ( m , n ), v ( n )) call random_number ( A ) call random_number ( v ) #if defined(USE_COARRAY) sync all call t % timer_start () w = matmul ( A , v , 'coarray' ) call t % timer_stop ( message = ' Elapsed time (example4: mat_vec, coarray):' ) #else call t % timer_start () w = matmul ( A , v ) call t % timer_stop ( message = ' Elapsed time (example4: mat_vec):' ) #endif end program example4","tags":"","loc":"program/example4.html"},{"title":"benchmark2 – ForMatmul","text":"Uses formatmul_opts fortime kinds formatmul program~~benchmark2~~UsesGraph program~benchmark2 benchmark2 fortime fortime program~benchmark2->fortime kinds kinds program~benchmark2->kinds module~formatmul formatmul program~benchmark2->module~formatmul module~formatmul_opts formatmul_opts program~benchmark2->module~formatmul_opts module~formatmul->kinds module~formatmul->module~formatmul_opts module~formatmul_opts->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~benchmark2~~CallsGraph program~benchmark2 benchmark2 interface~matmul_blas formatmul_opts::matmul_blas program~benchmark2->interface~matmul_blas timer_start timer_start program~benchmark2->timer_start timer_stop timer_stop program~benchmark2->timer_stop proc~gemm_mat_mat_rel formatmul_opts::gemm_mat_mat_rel interface~matmul_blas->proc~gemm_mat_mat_rel proc~gemv_mat_vec_rel formatmul_opts::gemv_mat_vec_rel interface~matmul_blas->proc~gemv_mat_vec_rel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:,:) real(kind=rk), allocatable :: v (:) real(kind=rk), allocatable :: w (:) type(timer) :: t integer :: m integer :: n integer :: i integer :: l character(len=2) :: im Source Code program benchmark2 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul use formatmul_opts , only : matmul_blas implicit none real ( rk ), allocatable :: A (:,:), v (:) real ( rk ), allocatable :: w (:) type ( timer ) :: t integer :: m , n , i , l character ( 2 ) :: im ! w(m) = A(m,n).v(n) m = 64 * 2 * 100 n = 16 * 2 * 100 l = 5 allocate ( A ( m , n ), v ( n )) call random_number ( A ) call random_number ( v ) #if defined(USE_COARRAY) sync all if ( this_image () == 1 ) call t % timer_start () do i = 1 , l w = matmul ( A , v ) end do if ( this_image () == 1 ) call t % timer_stop ( message = ' Elapsed time (matmul):' , nloops = l ) #else call t % timer_start () do i = 1 , l w = matmul ( A , v ) end do call t % timer_stop ( message = ' Elapsed time (matmul):' , nloops = l ) #endif #if defined(USE_COARRAY) sync all if ( this_image () == 1 ) call t % timer_start () do i = 1 , l w = matmul_blas ( A , v ) end do if ( this_image () == 1 ) call t % timer_stop ( message = ' Elapsed time (dgemv):' , nloops = l ) #else call t % timer_start () do i = 1 , l w = matmul_blas ( A , v ) end do call t % timer_stop ( message = ' Elapsed time (dgemv):' , nloops = l ) #endif #if defined(USE_COARRAY) sync all call t % timer_start () do i = 1 , l w = matmul ( A , v , 'coarray' , 'm1' ) end do write ( im , \"(I2)\" ) this_image () call t % timer_stop ( message = ' Elapsed time (coarray with matmul) image=' // trim ( im ) // ':' , nloops = l ) #else call t % timer_start () do i = 1 , l w = matmul ( A , v , 'default' , 'm1' ) end do call t % timer_stop ( message = ' Elapsed time (default with matmul) image=' // trim ( im ) // ':' , nloops = l ) #endif #if defined(USE_COARRAY) sync all call t % timer_start () do i = 1 , l w = matmul ( A , v , 'coarray' , 'm2' ) end do write ( im , \"(I2)\" ) this_image () call t % timer_stop ( message = ' Elapsed time (coarray with dgemv) image=' // trim ( im ) // ':' , nloops = l ) #else call t % timer_start () do i = 1 , l w = matmul ( A , v , 'default' , 'm2' ) end do call t % timer_stop ( message = ' Elapsed time (default with dgemv) image=' // trim ( im ) // ':' , nloops = l ) #endif end program benchmark2","tags":"","loc":"program/benchmark2.html"},{"title":"mat_vec – ForMatmul","text":"Uses fortime kinds formatmul program~~mat_vec~~UsesGraph program~mat_vec mat_vec fortime fortime program~mat_vec->fortime kinds kinds program~mat_vec->kinds module~formatmul formatmul program~mat_vec->module~formatmul module~formatmul->kinds module~formatmul_opts formatmul_opts module~formatmul->module~formatmul_opts module~formatmul_opts->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:,:) real(kind=rk), allocatable :: v (:) real(kind=rk), allocatable :: w (:) real(kind=rk), allocatable :: w_co (:) type(timer) :: t integer :: m integer :: n Source Code program mat_vec use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), v (:) real ( rk ), allocatable :: w (:), w_co (:) type ( timer ) :: t integer :: m , n ! w(m) = A(m,n).v(n) m = 200 n = 100 allocate ( A ( m , n ), v ( n )) call random_number ( A ) call random_number ( v ) w = matmul ( A , v ) #if defined(USE_COARRAY) sync all w_co = matmul ( A , v , 'coarray' ) sync all if ( this_image () == 1 ) print * , 'test2: relative error:' , norm2 ( w - w_co ) / norm2 ( w ) #endif end program mat_vec","tags":"","loc":"program/mat_vec.html"},{"title":"benchmark1 – ForMatmul","text":"Uses formatmul_opts fortime kinds formatmul program~~benchmark1~~UsesGraph program~benchmark1 benchmark1 fortime fortime program~benchmark1->fortime kinds kinds program~benchmark1->kinds module~formatmul formatmul program~benchmark1->module~formatmul module~formatmul_opts formatmul_opts program~benchmark1->module~formatmul_opts module~formatmul->kinds module~formatmul->module~formatmul_opts module~formatmul_opts->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~benchmark1~~CallsGraph program~benchmark1 benchmark1 interface~matmul_blas formatmul_opts::matmul_blas program~benchmark1->interface~matmul_blas timer_start timer_start program~benchmark1->timer_start timer_stop timer_stop program~benchmark1->timer_stop proc~gemm_mat_mat_rel formatmul_opts::gemm_mat_mat_rel interface~matmul_blas->proc~gemm_mat_mat_rel proc~gemv_mat_vec_rel formatmul_opts::gemv_mat_vec_rel interface~matmul_blas->proc~gemv_mat_vec_rel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:,:) real(kind=rk), allocatable :: B (:,:) real(kind=rk), allocatable :: C (:,:) type(timer) :: t integer :: m integer :: n integer :: o integer :: i integer :: l character(len=2) :: im Source Code program benchmark1 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul use formatmul_opts , only : matmul_blas implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C (:,:) type ( timer ) :: t integer :: m , n , o , i , l character ( 2 ) :: im ! C(m,o) = A(m,n).B(n,o) m = 3000 n = 2000 o = 1000 l = 5 allocate ( A ( m , n ), B ( n , o )) call random_number ( A ) call random_number ( B ) #if defined(USE_COARRAY) sync all if ( this_image () == 1 ) call t % timer_start () do i = 1 , l C = matmul ( A , B ) end do if ( this_image () == 1 ) call t % timer_stop ( message = ' Elapsed time (matmul):' , nloops = l ) #else call t % timer_start () do i = 1 , l C = matmul ( A , B ) end do call t % timer_stop ( message = ' Elapsed time (matmul):' , nloops = l ) #endif #if defined(USE_COARRAY) sync all if ( this_image () == 1 ) call t % timer_start () do i = 1 , l C = matmul_blas ( A , B ) end do if ( this_image () == 1 ) call t % timer_stop ( message = ' Elapsed time (dgemm):' , nloops = l ) #else call t % timer_start () do i = 1 , l C = matmul_blas ( A , B ) end do call t % timer_stop ( message = ' Elapsed time (dgemm):' , nloops = l ) #endif #if defined(USE_COARRAY) sync all call t % timer_start () do i = 1 , l C = matmul ( A , B , 'coarray' , 'm1' ) end do write ( im , \"(I2)\" ) this_image () call t % timer_stop ( message = ' Elapsed time (coarray with matmul) image=' // trim ( im ) // ':' , nloops = l ) #else call t % timer_start () do i = 1 , l C = matmul ( A , B , 'default' , 'm1' ) end do call t % timer_stop ( message = ' Elapsed time (default with matmul) image=' // trim ( im ) // ':' , nloops = l ) #endif #if defined(USE_COARRAY) sync all call t % timer_start () do i = 1 , l C = matmul ( A , B , 'coarray' , 'm2' ) end do call t % timer_stop ( message = ' Elapsed time (coarray with dgemm) image=' // trim ( im ) // ':' , nloops = l ) #else call t % timer_start () do i = 1 , l C = matmul ( A , B , 'default' , 'm2' ) end do call t % timer_stop ( message = ' Elapsed time (default with dgemm) image=' // trim ( im ) // ':' , nloops = l ) #endif end program benchmark1","tags":"","loc":"program/benchmark1.html"},{"title":"example3 – ForMatmul","text":"Uses fortime kinds formatmul program~~example3~~UsesGraph program~example3 example3 fortime fortime program~example3->fortime kinds kinds program~example3->kinds module~formatmul formatmul program~example3->module~formatmul module~formatmul->kinds module~formatmul_opts formatmul_opts module~formatmul->module~formatmul_opts module~formatmul_opts->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~example3~~CallsGraph program~example3 example3 timer_start timer_start program~example3->timer_start timer_stop timer_stop program~example3->timer_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:,:) real(kind=rk), allocatable :: v (:) real(kind=rk), allocatable :: w (:) type(timer) :: t integer :: m integer :: n Source Code program example3 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), v (:) real ( rk ), allocatable :: w (:) type ( timer ) :: t integer :: m , n ! w(m) = A(m,n).v(n) m = 64 * 2 * 100 n = 16 * 2 * 100 allocate ( A ( m , n ), v ( n )) call random_number ( A ) call random_number ( v ) #if defined(USE_COARRAY) sync all if ( this_image () == 1 ) call t % timer_start () w = matmul ( A , v ) if ( this_image () == 1 ) call t % timer_stop ( message = ' Elapsed time (example3: mat_vec):' ) #else call t % timer_start () w = matmul ( A , v ) call t % timer_stop ( message = ' Elapsed time (example3: mat_vec):' ) #endif end program example3","tags":"","loc":"program/example3.html"},{"title":"example5.f90 – ForMatmul","text":"This file depends on sourcefile~~example5.f90~~EfferentGraph sourcefile~example5.f90 example5.f90 sourcefile~formatmul_opts.f90 formatmul_opts.f90 sourcefile~example5.f90->sourcefile~formatmul_opts.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program example5 use kinds , only : rk use fortime , only : timer use formatmul_opts , only : matmul_blas implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C (:,:) type ( timer ) :: t integer :: m , n , o ! C(m,o) = A(m,n).B(n,o) m = 64 * 2 * 100 n = 16 * 100 o = 64 * 10 allocate ( A ( m , n ), B ( n , o )) call random_number ( A ) call random_number ( B ) #if defined(USE_COARRAY) sync all if ( this_image () == 1 ) call t % timer_start () C = matmul_blas ( A , B ) if ( this_image () == 1 ) call t % timer_stop ( message = ' Elapsed time (example5: mat_mat with blas):' ) #else call t % timer_start () C = matmul_blas ( A , B ) call t % timer_stop ( message = ' Elapsed time (example5: mat_mat with blas):' ) #endif end program example5","tags":"","loc":"sourcefile/example5.f90.html"},{"title":"example6.f90 – ForMatmul","text":"This file depends on sourcefile~~example6.f90~~EfferentGraph sourcefile~example6.f90 example6.f90 sourcefile~formatmul.f90 formatmul.f90 sourcefile~example6.f90->sourcefile~formatmul.f90 sourcefile~formatmul_opts.f90 formatmul_opts.f90 sourcefile~formatmul.f90->sourcefile~formatmul_opts.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program example6 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C (:,:) type ( timer ) :: t integer :: m , n , o ! C(m,o) = A(m,n).B(n,o) m = 64 * 2 * 100 n = 16 * 100 o = 64 * 10 allocate ( A ( m , n ), B ( n , o )) call random_number ( A ) call random_number ( B ) #if defined(USE_COARRAY) sync all call t % timer_start () C = matmul ( A , B , 'coarray' , option = 'm2' ) call t % timer_stop ( message = ' Elapsed time (example6: mat_mat, coarray with blas):' ) #else call t % timer_start () C = matmul ( A , B , 'default' , option = 'm2' ) call t % timer_stop ( message = ' Elapsed time (example6: mat_mat, blas):' ) #endif end program example6","tags":"","loc":"sourcefile/example6.f90.html"},{"title":"example1.f90 – ForMatmul","text":"This file depends on sourcefile~~example1.f90~~EfferentGraph sourcefile~example1.f90 example1.f90 sourcefile~formatmul.f90 formatmul.f90 sourcefile~example1.f90->sourcefile~formatmul.f90 sourcefile~formatmul_opts.f90 formatmul_opts.f90 sourcefile~formatmul.f90->sourcefile~formatmul_opts.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program example1 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C (:,:) type ( timer ) :: t integer :: m , n , o ! C(m,o) = A(m,n).B(n,o) m = 64 * 2 * 100 n = 16 * 100 o = 64 * 10 allocate ( A ( m , n ), B ( n , o )) call random_number ( A ) call random_number ( B ) #if defined(USE_COARRAY) sync all if ( this_image () == 1 ) call t % timer_start () C = matmul ( A , B ) if ( this_image () == 1 ) call t % timer_stop ( message = ' Elapsed time (example1: mat_mat):' ) #else call t % timer_start () C = matmul ( A , B ) call t % timer_stop ( message = ' Elapsed time (example1: mat_mat):' ) #endif end program example1","tags":"","loc":"sourcefile/example1.f90.html"},{"title":"example2.f90 – ForMatmul","text":"This file depends on sourcefile~~example2.f90~~EfferentGraph sourcefile~example2.f90 example2.f90 sourcefile~formatmul.f90 formatmul.f90 sourcefile~example2.f90->sourcefile~formatmul.f90 sourcefile~formatmul_opts.f90 formatmul_opts.f90 sourcefile~formatmul.f90->sourcefile~formatmul_opts.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program example2 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C (:,:) type ( timer ) :: t integer :: m , n , o ! C(m,o) = A(m,n).B(n,o) m = 64 * 2 * 100 n = 16 * 100 o = 64 * 10 allocate ( A ( m , n ), B ( n , o )) call random_number ( A ) call random_number ( B ) #if defined(USE_COARRAY) sync all call t % timer_start () C = matmul ( A , B , 'coarray' ) call t % timer_stop ( message = ' Elapsed time (example2: mat_mat, coarray):' ) #else call t % timer_start () C = matmul ( A , B ) call t % timer_stop ( message = ' Elapsed time (example2: mat_mat):' ) #endif end program example2","tags":"","loc":"sourcefile/example2.f90.html"},{"title":"benchmark4.f90 – ForMatmul","text":"This file depends on sourcefile~~benchmark4.f90~~EfferentGraph sourcefile~benchmark4.f90 benchmark4.f90 sourcefile~formatmul.f90 formatmul.f90 sourcefile~benchmark4.f90->sourcefile~formatmul.f90 sourcefile~formatmul_benchmark.f90 formatmul_benchmark.f90 sourcefile~benchmark4.f90->sourcefile~formatmul_benchmark.f90 sourcefile~formatmul_opts.f90 formatmul_opts.f90 sourcefile~formatmul.f90->sourcefile~formatmul_opts.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program benchmark4 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul use formatmul_benchmark , only : start_benchmark , stop_benchmark , write_benchmark use , intrinsic :: iso_fortran_env , only : compiler_version , compiler_options implicit none real ( rk ), allocatable :: A (:,:), v (:) real ( rk ), allocatable :: w_ref (:), w (:) #if defined(USE_COARRAY) type ( timer ) :: t [ * ] #else type ( timer ) :: t #endif integer :: m , n , i , nloops , p , unit_num , im , nim character ( len = :), allocatable :: file_name character ( len = 1000 ) :: im_chr nloops = 10 #if defined(USE_COARRAY) im = this_image () nim = num_images () write ( im_chr , '(i0)' ) im file_name = \"benchmark/benchmark4_im\" // trim ( im_chr ) // \".data\" #else file_name = \"benchmark/benchmark4.data\" #endif open ( newunit = unit_num , file = file_name ) write ( unit_num , '(a)' ) 'ForMatmul' write ( unit_num , '(a)' ) compiler_version () write ( unit_num , '(a)' ) compiler_options () #if defined(USE_COARRAY) write ( unit_num , \"(g0,' ',g0)\" ) im , nim #endif close ( unit_num ) do p = 250 , 30000 , 250 ! w(m) = A(m,n).v(n) m = p n = p if ( allocated ( A )) deallocate ( A ) if ( allocated ( v )) deallocate ( v ) if ( allocated ( w )) deallocate ( w ) if ( allocated ( w_ref )) deallocate ( w_ref ) allocate ( A ( m , n )) allocate ( v ( n )) allocate ( w ( m )) allocate ( w_ref ( m )) call random_number ( A ) call random_number ( v ) #if defined(USE_COARRAY) call start_benchmark ( t [ im ], m , n , 1 , \"w_ref = matmul(A,v)\" ) do i = 1 , nloops w_ref = matmul ( A , v ) end do call stop_benchmark ( t [ im ], m , n , 1 , nloops , w_ref , w_ref , 'Matmul' , file_name ) #else call start_benchmark ( t , m , n , 1 , \"w_ref = matmul(A,v)\" ) do i = 1 , nloops w_ref = matmul ( A , v ) end do call stop_benchmark ( t , m , n , 1 , nloops , w_ref , w_ref , 'Matmul' , file_name ) #endif #if defined(USE_COARRAY) call start_benchmark ( t [ im ], m , n , 1 , \"w = matmul(A,v,'coarray','m1')\" ) do i = 1 , nloops w = matmul ( A , v , 'coarray' , 'm1' ) end do call stop_benchmark ( t [ im ], m , n , 1 , nloops , w , w_ref , 'coarray_Matmul' , file_name ) #else call start_benchmark ( t , m , n , 1 , \"w = matmul(A,v,'default','m1')\" ) do i = 1 , nloops w = matmul ( A , v , 'default' , 'm1' ) end do call stop_benchmark ( t , m , n , 1 , nloops , w , w_ref , 'default_Matmul' , file_name ) #endif #if defined(USE_COARRAY) call start_benchmark ( t [ im ], m , n , 1 , \"w = matmul(A,v,'coarray','m2')\" ) do i = 1 , nloops w = matmul ( A , v , 'coarray' , 'm2' ) end do call stop_benchmark ( t [ im ], m , n , 1 , nloops , w , w_ref , 'coarray_dgemm' , file_name ) #else call start_benchmark ( t , m , n , 1 , \"w = matmul(A,v,'default','m2')\" ) do i = 1 , nloops w = matmul ( A , v , 'default' , 'm2' ) end do call stop_benchmark ( t , m , n , 1 , nloops , w , w_ref , 'default_dgemm' , file_name ) #endif #if defined(USE_COARRAY) call start_benchmark ( t [ im ], m , n , 1 , \"w = matmul(A,v,'coarray','m3')\" ) do i = 1 , nloops w = matmul ( A , v , 'coarray' , 'm3' ) end do call stop_benchmark ( t [ im ], m , n , 1 , nloops , w , w_ref , 'coarray_m3' , file_name ) #else call start_benchmark ( t , m , n , 1 , \"w = matmul(A,v,'default','m3')\" ) do i = 1 , nloops w = matmul ( A , v , 'default' , 'm3' ) end do call stop_benchmark ( t , m , n , 1 , nloops , w , w_ref , 'default_m3' , file_name ) #endif #if defined(USE_COARRAY) call start_benchmark ( t [ im ], m , n , 1 , \"w = matmul(A,v,'coarray','m4')\" ) do i = 1 , nloops w = matmul ( A , v , 'coarray' , 'm4' ) end do call stop_benchmark ( t [ im ], m , n , 1 , nloops , w , w_ref , 'coarray_m4' , file_name ) #else call start_benchmark ( t , m , n , 1 , \"w = matmul(A,v,'default','m4')\" ) do i = 1 , nloops w = matmul ( A , v , 'default' , 'm4' ) end do call stop_benchmark ( t , m , n , 1 , nloops , w , w_ref , 'default_m4' , file_name ) #endif #if defined(USE_COARRAY) call start_benchmark ( t [ im ], m , n , 1 , \"w = matmul(A,v,'coarray','m5')\" ) do i = 1 , nloops w = matmul ( A , v , 'coarray' , 'm5' ) end do call stop_benchmark ( t [ im ], m , n , 1 , nloops , w , w_ref , 'coarray_m5' , file_name ) #else call start_benchmark ( t , m , n , 1 , \"w = matmul(A,v,'default','m5')\" ) do i = 1 , nloops w = matmul ( A , v , 'default' , 'm5' ) end do call stop_benchmark ( t , m , n , 1 , nloops , w , w_ref , 'default_m5' , file_name ) #endif #if defined(USE_COARRAY) call start_benchmark ( t [ im ], m , n , 1 , \"w = matmul(A,v,'coarray','m6')\" ) do i = 1 , nloops w = matmul ( A , v , 'coarray' , 'm6' ) end do call stop_benchmark ( t [ im ], m , n , 1 , nloops , w , w_ref , 'coarray_m6' , file_name ) #else call start_benchmark ( t , m , n , 1 , \"w = matmul(A,v,'default','m6')\" ) do i = 1 , nloops w = matmul ( A , v , 'default' , 'm6' ) end do call stop_benchmark ( t , m , n , 1 , nloops , w , w_ref , 'default_m6' , file_name ) #endif end do end program benchmark4","tags":"","loc":"sourcefile/benchmark4.f90.html"},{"title":"example7.f90 – ForMatmul","text":"This file depends on sourcefile~~example7.f90~~EfferentGraph sourcefile~example7.f90 example7.f90 sourcefile~formatmul_opts.f90 formatmul_opts.f90 sourcefile~example7.f90->sourcefile~formatmul_opts.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program example7 use kinds , only : rk use fortime , only : timer use formatmul_opts , only : matmul_blas implicit none real ( rk ), allocatable :: A (:,:), v (:) real ( rk ), allocatable :: w (:) type ( timer ) :: t integer :: m , n ! w(m) = A(m,n).v(n) m = 64 * 2 * 100 n = 16 * 2 * 100 allocate ( A ( m , n ), v ( n )) call random_number ( A ) call random_number ( v ) #if defined(USE_COARRAY) sync all if ( this_image () == 1 ) call t % timer_start () w = matmul_blas ( A , v ) if ( this_image () == 1 ) call t % timer_stop ( message = ' Elapsed time (example7: mat_vec with blas):' ) #else call t % timer_start () w = matmul_blas ( A , v ) call t % timer_stop ( message = ' Elapsed time (example7: mat_vec with blas):' ) #endif end program example7","tags":"","loc":"sourcefile/example7.f90.html"},{"title":"test1.f90 – ForMatmul","text":"This file depends on sourcefile~~test1.f90~~EfferentGraph sourcefile~test1.f90 test1.f90 sourcefile~formatmul.f90 formatmul.f90 sourcefile~test1.f90->sourcefile~formatmul.f90 sourcefile~formatmul_opts.f90 formatmul_opts.f90 sourcefile~formatmul.f90->sourcefile~formatmul_opts.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program mat_mat use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C (:,:), C_co (:,:) type ( timer ) :: t integer :: m , n , o ! C(m,o) = A(m,n).B(n,o) m = 200 n = 100 o = 10 allocate ( A ( m , n ), B ( n , o )) call random_number ( A ) call random_number ( B ) #if defined(USE_COARRAY) sync all #endif C = matmul ( A , B ) #if defined(USE_COARRAY) sync all C_co = matmul ( A , B , 'coarray' ) sync all if ( this_image () == 1 ) print * , 'test1: relative error:' , norm2 ( C - C_co ) / norm2 ( C ) #endif end program mat_mat","tags":"","loc":"sourcefile/test1.f90.html"},{"title":"example8.f90 – ForMatmul","text":"This file depends on sourcefile~~example8.f90~~EfferentGraph sourcefile~example8.f90 example8.f90 sourcefile~formatmul.f90 formatmul.f90 sourcefile~example8.f90->sourcefile~formatmul.f90 sourcefile~formatmul_opts.f90 formatmul_opts.f90 sourcefile~formatmul.f90->sourcefile~formatmul_opts.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program example8 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), v (:) real ( rk ), allocatable :: w (:) type ( timer ) :: t integer :: m , n ! w(m) = A(m,n).v(n) m = 64 * 2 * 100 n = 16 * 2 * 100 allocate ( A ( m , n ), v ( n )) call random_number ( A ) call random_number ( v ) #if defined(USE_COARRAY) sync all call t % timer_start () w = matmul ( A , v , 'coarray' , option = 'm2' ) call t % timer_stop ( message = ' Elapsed time (example8: mat_vec, coarray with blas):' ) #else call t % timer_start () w = matmul ( A , v , 'default' , option = 'm2' ) call t % timer_stop ( message = ' Elapsed time (example8: mat_vec, blas):' ) #endif end program example8","tags":"","loc":"sourcefile/example8.f90.html"},{"title":"benchmark3.f90 – ForMatmul","text":"This file depends on sourcefile~~benchmark3.f90~~EfferentGraph sourcefile~benchmark3.f90 benchmark3.f90 sourcefile~formatmul.f90 formatmul.f90 sourcefile~benchmark3.f90->sourcefile~formatmul.f90 sourcefile~formatmul_benchmark.f90 formatmul_benchmark.f90 sourcefile~benchmark3.f90->sourcefile~formatmul_benchmark.f90 sourcefile~formatmul_opts.f90 formatmul_opts.f90 sourcefile~formatmul.f90->sourcefile~formatmul_opts.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program benchmark3 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul use formatmul_benchmark , only : start_benchmark , stop_benchmark , write_benchmark use , intrinsic :: iso_fortran_env , only : compiler_version , compiler_options implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C_ref (:,:), C (:,:) #if defined(USE_COARRAY) type ( timer ) :: t [ * ] #else type ( timer ) :: t #endif integer :: m , n , o , i , nloops , p , unit_num , im , nim character ( len = :), allocatable :: file_name character ( len = 1000 ) :: im_chr nloops = 10 #if defined(USE_COARRAY) im = this_image () nim = num_images () write ( im_chr , '(i0)' ) im file_name = \"benchmark/benchmark3_im\" // trim ( im_chr ) // \".data\" #else file_name = \"benchmark/benchmark3.data\" #endif open ( newunit = unit_num , file = file_name ) write ( unit_num , '(a)' ) 'ForMatmul' write ( unit_num , '(a)' ) compiler_version () write ( unit_num , '(a)' ) compiler_options () #if defined(USE_COARRAY) write ( unit_num , \"(g0,' ',g0)\" ) im , nim #endif close ( unit_num ) do p = 250 , 4000 , 250 ! C(m,o) = A(m,n).B(n,o) m = p n = p o = p if ( allocated ( A )) deallocate ( A ) if ( allocated ( B )) deallocate ( B ) if ( allocated ( C )) deallocate ( C ) if ( allocated ( C_ref )) deallocate ( C_ref ) allocate ( A ( m , n )) allocate ( B ( n , o )) allocate ( C ( m , o )) allocate ( C_ref ( m , o )) call random_number ( A ) call random_number ( B ) #if defined(USE_COARRAY) call start_benchmark ( t [ im ], m , n , o , \"C_ref = matmul(A,B)\" ) do i = 1 , nloops C_ref = matmul ( A , B ) end do call stop_benchmark ( t [ im ], m , n , o , nloops , C_ref , C_ref , 'Matmul' , file_name ) #else call start_benchmark ( t , m , n , o , \"C_ref = matmul(A,B)\" ) do i = 1 , nloops C_ref = matmul ( A , B ) end do call stop_benchmark ( t , m , n , o , nloops , C_ref , C_ref , 'Matmul' , file_name ) #endif #if defined(USE_COARRAY) call start_benchmark ( t [ im ], m , n , o , \"C = matmul(A,B,'coarray','m1')\" ) do i = 1 , nloops C = matmul ( A , B , 'coarray' , 'm1' ) end do call stop_benchmark ( t [ im ], m , n , o , nloops , C , C_ref , 'coarray_Matmul' , file_name ) #else call start_benchmark ( t , m , n , o , \"C = matmul(A,B,'default','m1')\" ) do i = 1 , nloops C = matmul ( A , B , 'default' , 'm1' ) end do call stop_benchmark ( t , m , n , o , nloops , C , C_ref , 'default_Matmul' , file_name ) #endif #if defined(USE_COARRAY) call start_benchmark ( t [ im ], m , n , o , \"C = matmul(A,B,'coarray','m2')\" ) do i = 1 , nloops C = matmul ( A , B , 'coarray' , 'm2' ) end do call stop_benchmark ( t [ im ], m , n , o , nloops , C , C_ref , 'coarray_dgemm' , file_name ) #else call start_benchmark ( t , m , n , o , \"C = matmul(A,B,'default','m2')\" ) do i = 1 , nloops C = matmul ( A , B , 'default' , 'm2' ) end do call stop_benchmark ( t , m , n , o , nloops , C , C_ref , 'default_dgemm' , file_name ) #endif #if defined(USE_COARRAY) call start_benchmark ( t [ im ], m , n , o , \"C = matmul(A,B,'coarray','m3')\" ) do i = 1 , nloops C = matmul ( A , B , 'coarray' , 'm3' ) end do call stop_benchmark ( t [ im ], m , n , o , nloops , C , C_ref , 'coarray_m3' , file_name ) #else call start_benchmark ( t , m , n , o , \"C = matmul(A,B,'default','m3')\" ) do i = 1 , nloops C = matmul ( A , B , 'default' , 'm3' ) end do call stop_benchmark ( t , m , n , o , nloops , C , C_ref , 'default_m3' , file_name ) #endif #if defined(USE_COARRAY) call start_benchmark ( t [ im ], m , n , o , \"C = matmul(A,B,'coarray','m4')\" ) do i = 1 , nloops C = matmul ( A , B , 'coarray' , 'm4' ) end do call stop_benchmark ( t [ im ], m , n , o , nloops , C , C_ref , 'coarray_m4' , file_name ) #else call start_benchmark ( t , m , n , o , \"C = matmul(A,B,'default','m4')\" ) do i = 1 , nloops C = matmul ( A , B , 'default' , 'm4' ) end do call stop_benchmark ( t , m , n , o , nloops , C , C_ref , 'default_m4' , file_name ) #endif #if defined(USE_COARRAY) call start_benchmark ( t [ im ], m , n , o , \"C = matmul(A,B,'coarray','m5')\" ) do i = 1 , nloops C = matmul ( A , B , 'coarray' , 'm5' ) end do call stop_benchmark ( t [ im ], m , n , o , nloops , C , C_ref , 'coarray_m5' , file_name ) #else call start_benchmark ( t , m , n , o , \"C = matmul(A,B,'default','m5')\" ) do i = 1 , nloops C = matmul ( A , B , 'default' , 'm5' ) end do call stop_benchmark ( t , m , n , o , nloops , C , C_ref , 'default_m5' , file_name ) #endif #if defined(USE_COARRAY) call start_benchmark ( t [ im ], m , n , o , \"C = matmul(A,B,'coarray','m6')\" ) do i = 1 , nloops C = matmul ( A , B , 'coarray' , 'm6' ) end do call stop_benchmark ( t [ im ], m , n , o , nloops , C , C_ref , 'coarray_m6' , file_name ) #else call start_benchmark ( t , m , n , o , \"C = matmul(A,B,'default','m6')\" ) do i = 1 , nloops C = matmul ( A , B , 'default' , 'm6' ) end do call stop_benchmark ( t , m , n , o , nloops , C , C_ref , 'default_m6' , file_name ) #endif #if defined(USE_COARRAY) call start_benchmark ( t [ im ], m , n , o , \"C = matmul(A,B,'coarray','m7')\" ) do i = 1 , nloops C = matmul ( A , B , 'coarray' , 'm7' ) end do call stop_benchmark ( t [ im ], m , n , o , nloops , C , C_ref , 'coarray_m7' , file_name ) #else call start_benchmark ( t , m , n , o , \"C = matmul(A,B,'default','m7')\" ) do i = 1 , nloops C = matmul ( A , B , 'default' , 'm7' ) end do call stop_benchmark ( t , m , n , o , nloops , C , C_ref , 'default_m7' , file_name ) #endif #if defined(USE_COARRAY) call start_benchmark ( t [ im ], m , n , o , \"C = matmul(A,B,'coarray','m8')\" ) do i = 1 , nloops C = matmul ( A , B , 'coarray' , 'm8' ) end do call stop_benchmark ( t [ im ], m , n , o , nloops , C , C_ref , 'coarray_m8' , file_name ) #else call start_benchmark ( t , m , n , o , \"C = matmul(A,B,'default','m8')\" ) do i = 1 , nloops C = matmul ( A , B , 'default' , 'm8' ) end do call stop_benchmark ( t , m , n , o , nloops , C , C_ref , 'default_m8' , file_name ) #endif #if defined(USE_COARRAY) call start_benchmark ( t [ im ], m , n , o , \"C = matmul(A,B,'coarray','m9')\" ) do i = 1 , nloops C = matmul ( A , B , 'coarray' , 'm9' ) end do call stop_benchmark ( t [ im ], m , n , o , nloops , C , C_ref , 'coarray_m9' , file_name ) #else call start_benchmark ( t , m , n , o , \"C = matmul(A,B,'default','m9')\" ) do i = 1 , nloops C = matmul ( A , B , 'default' , 'm9' ) end do call stop_benchmark ( t , m , n , o , nloops , C , C_ref , 'default_m9' , file_name ) #endif #if defined(USE_COARRAY) call start_benchmark ( t [ im ], m , n , o , \"C = matmul(A,B,'coarray','m10')\" ) do i = 1 , nloops C = matmul ( A , B , 'coarray' , 'm10' ) end do call stop_benchmark ( t [ im ], m , n , o , nloops , C , C_ref , 'coarray_m10' , file_name ) #else call start_benchmark ( t , m , n , o , \"C = matmul(A,B,'default','m10')\" ) do i = 1 , nloops C = matmul ( A , B , 'default' , 'm10' ) end do call stop_benchmark ( t , m , n , o , nloops , C , C_ref , 'default_m10' , file_name ) #endif #if defined(USE_COARRAY) call start_benchmark ( t [ im ], m , n , o , \"C = matmul(A,B,'coarray','m11')\" ) do i = 1 , nloops C = matmul ( A , B , 'coarray' , 'm11' ) end do call stop_benchmark ( t [ im ], m , n , o , nloops , C , C_ref , 'coarray_m11' , file_name ) #else call start_benchmark ( t , m , n , o , \"C = matmul(A,B,'default','m11')\" ) do i = 1 , nloops C = matmul ( A , B , 'default' , 'm11' ) end do call stop_benchmark ( t , m , n , o , nloops , C , C_ref , 'default_m11' , file_name ) #endif #if defined(USE_COARRAY) call start_benchmark ( t [ im ], m , n , o , \"C = matmul(A,B,'coarray','m12')\" ) do i = 1 , nloops C = matmul ( A , B , 'coarray' , 'm12' ) end do call stop_benchmark ( t [ im ], m , n , o , nloops , C , C_ref , 'coarray_m12' , file_name ) #else call start_benchmark ( t , m , n , o , \"C = matmul(A,B,'default','m12')\" ) do i = 1 , nloops C = matmul ( A , B , 'default' , 'm12' ) end do call stop_benchmark ( t , m , n , o , nloops , C , C_ref , 'default_m12' , file_name ) #endif #if defined(USE_COARRAY) call start_benchmark ( t [ im ], m , n , o , \"C = matmul(A,B,'coarray','m13')\" ) do i = 1 , nloops C = matmul ( A , B , 'coarray' , 'm13' ) end do call stop_benchmark ( t [ im ], m , n , o , nloops , C , C_ref , 'coarray_m13' , file_name ) #else call start_benchmark ( t , m , n , o , \"C = matmul(A,B,'default','m13')\" ) do i = 1 , nloops C = matmul ( A , B , 'default' , 'm13' ) end do call stop_benchmark ( t , m , n , o , nloops , C , C_ref , 'default_m13' , file_name ) #endif end do end program benchmark3","tags":"","loc":"sourcefile/benchmark3.f90.html"},{"title":"formatmul_opts.f90 – ForMatmul","text":"Files dependent on this one sourcefile~~formatmul_opts.f90~~AfferentGraph sourcefile~formatmul_opts.f90 formatmul_opts.f90 sourcefile~benchmark1.f90 benchmark1.f90 sourcefile~benchmark1.f90->sourcefile~formatmul_opts.f90 sourcefile~formatmul.f90 formatmul.f90 sourcefile~benchmark1.f90->sourcefile~formatmul.f90 sourcefile~benchmark2.f90 benchmark2.f90 sourcefile~benchmark2.f90->sourcefile~formatmul_opts.f90 sourcefile~benchmark2.f90->sourcefile~formatmul.f90 sourcefile~example5.f90 example5.f90 sourcefile~example5.f90->sourcefile~formatmul_opts.f90 sourcefile~example7.f90 example7.f90 sourcefile~example7.f90->sourcefile~formatmul_opts.f90 sourcefile~formatmul.f90->sourcefile~formatmul_opts.f90 sourcefile~benchmark3.f90 benchmark3.f90 sourcefile~benchmark3.f90->sourcefile~formatmul.f90 sourcefile~benchmark4.f90 benchmark4.f90 sourcefile~benchmark4.f90->sourcefile~formatmul.f90 sourcefile~example1.f90 example1.f90 sourcefile~example1.f90->sourcefile~formatmul.f90 sourcefile~example2.f90 example2.f90 sourcefile~example2.f90->sourcefile~formatmul.f90 sourcefile~example3.f90 example3.f90 sourcefile~example3.f90->sourcefile~formatmul.f90 sourcefile~example4.f90 example4.f90 sourcefile~example4.f90->sourcefile~formatmul.f90 sourcefile~example6.f90 example6.f90 sourcefile~example6.f90->sourcefile~formatmul.f90 sourcefile~example8.f90 example8.f90 sourcefile~example8.f90->sourcefile~formatmul.f90 sourcefile~test1.f90 test1.f90 sourcefile~test1.f90->sourcefile~formatmul.f90 sourcefile~test2.f90 test2.f90 sourcefile~test2.f90->sourcefile~formatmul.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module formatmul_opts use kinds , only : rk implicit none private public :: matmul_opts , matmul_blas interface matmul_opts procedure :: matmul_mat_mat_rel_opts procedure :: matmul_mat_vec_rel_opts end interface !> Interface for BLAS-based matrix multiplication functions. interface matmul_blas procedure :: gemm_mat_mat_rel procedure :: gemv_mat_vec_rel end interface contains pure function matmul_mat_mat_rel_opts ( A , B , option ) result ( C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) character ( * ), intent ( in ) :: option real ( rk ) :: C ( size ( A , 1 ), size ( B , 2 )) select case ( option ) case ( 'm1' ) C = matmul ( A , B ) case ( 'm2' ) C = matmul_blas ( A , B ) case ( 'm3' ) call mm_mnp ( size ( A , 1 ), size ( A , 2 ), size ( B , 2 ), A , B , C ) case ( 'm4' ) call mm_mpn ( size ( A , 1 ), size ( A , 2 ), size ( B , 2 ), A , B , C ) case ( 'm5' ) call mm_nmp ( size ( A , 1 ), size ( A , 2 ), size ( B , 2 ), A , B , C ) case ( 'm6' ) call mm_npm ( size ( A , 1 ), size ( A , 2 ), size ( B , 2 ), A , B , C ) case ( 'm7' ) call mm_pmn ( size ( A , 1 ), size ( A , 2 ), size ( B , 2 ), A , B , C ) case ( 'm8' ) call mm_pnm ( size ( A , 1 ), size ( A , 2 ), size ( B , 2 ), A , B , C ) case ( 'm9' ) call mm_9 ( size ( A , 1 ), size ( A , 2 ), size ( B , 2 ), A , B , C ) case ( 'm10' ) call mm_10 ( size ( A , 1 ), size ( A , 2 ), size ( B , 2 ), A , B , C ) case ( 'm11' ) call mm_11 ( size ( A , 1 ), size ( A , 2 ), size ( B , 2 ), A , B , C ) case ( 'm12' ) call mm_12 ( size ( A , 1 ), size ( A , 2 ), size ( B , 2 ), A , B , C ) case ( 'm13' ) call mm_13 ( size ( A , 1 ), size ( A , 2 ), size ( B , 2 ), A , B , C ) case default C = matmul ( A , B ) end select end function matmul_mat_mat_rel_opts pure function matmul_mat_vec_rel_opts ( A , v , option ) result ( w ) real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) character ( * ), intent ( in ) :: option real ( rk ) :: w ( size ( A , 1 )) select case ( option ) case ( 'm1' ) w = matmul ( A , v ) case ( 'm2' ) w = matmul_blas ( A , v ) case ( 'm3' ) call mv_3 ( size ( A , 1 ), size ( A , 2 ), A , v , w ) case ( 'm4' ) call mv_4 ( size ( A , 1 ), size ( A , 2 ), A , v , w ) case ( 'm5' ) call mv_5 ( size ( A , 1 ), size ( A , 2 ), A , v , w ) case ( 'm6' ) call mv_6 ( size ( A , 1 ), size ( A , 2 ), A , v , w ) case default w = matmul ( A , v ) end select end function matmul_mat_vec_rel_opts !> Matrix-matrix multiplication using BLAS. !> author: Seyed Ali Ghasemi pure function gemm_mat_mat_rel ( A , B ) result ( C ) !> Input matrices A and B. real ( rk ), dimension (:, :), contiguous , intent ( in ) :: A real ( rk ), dimension (:, :), contiguous , intent ( in ) :: B !> Result matrix C. real ( rk ), dimension ( size ( A , 1 ), size ( B , 2 )) :: C ! real(rk), dimension(:,:), allocatable             :: C integer :: m , k interface !> BLAS subroutine for matrix-matrix multiplication. pure subroutine dgemm ( f_transa , f_transb , f_m , f_n , f_k , f_alpha , f_a , f_lda , f_b , f_ldb , f_beta , f_c , f_ldc ) import rk integer , intent ( in ) :: f_ldc integer , intent ( in ) :: f_ldb integer , intent ( in ) :: f_lda character , intent ( in ) :: f_transa character , intent ( in ) :: f_transb integer , intent ( in ) :: f_m integer , intent ( in ) :: f_n integer , intent ( in ) :: f_k real ( rk ), intent ( in ) :: f_alpha real ( rk ), intent ( in ) :: f_a ( f_lda , * ) real ( rk ), intent ( in ) :: f_b ( f_ldb , * ) real ( rk ), intent ( in ) :: f_beta real ( rk ), intent ( inout ) :: f_c ( f_ldc , * ) end subroutine dgemm end interface m = size ( A , 1 ) k = size ( A , 2 ) C = 0.0_rk ! Call BLAS dgemm subroutine for matrix-matrix multiplication. call dgemm ( 'N' , 'N' , m , size ( B , 2 ), k , 1.0_rk , A , m , B , k , 0.0_rk , C , m ) end function gemm_mat_mat_rel !> Matrix-vector multiplication using BLAS. !> author: Seyed Ali Ghasemi pure function gemv_mat_vec_rel ( A , x ) result ( y ) !> Input matrix A and vector x. real ( rk ), dimension (:, :), contiguous , intent ( in ) :: A real ( rk ), dimension (:), contiguous , intent ( in ) :: x !> Result vector y. real ( rk ), dimension ( size ( A , 1 )) :: y ! real(rk), dimension(:), allocatable               :: y integer :: m interface !> BLAS subroutine for matrix-vector multiplication. pure subroutine dgemv ( f_trans , f_m , f_n , f_alpha , f_a , f_lda , f_x , f_incx , f_beta , f_y , f_incy ) import rk integer , intent ( in ) :: f_m integer , intent ( in ) :: f_n integer , intent ( in ) :: f_lda character , intent ( in ) :: f_trans real ( rk ), intent ( in ) :: f_alpha real ( rk ), intent ( in ) :: f_a ( f_lda , * ) real ( rk ), intent ( in ) :: f_x ( * ) integer , intent ( in ) :: f_incx real ( rk ), intent ( in ) :: f_beta real ( rk ), intent ( inout ) :: f_y ( * ) integer , intent ( in ) :: f_incy end subroutine dgemv end interface m = size ( A , 1 ) y = 0.0_rk ! Call BLAS dgemv subroutine for matrix-vector multiplication. call dgemv ( 'N' , m , size ( A , 2 ), 1.0_rk , A , m , x , 1 , 0.0_rk , y , 1 ) end function gemv_mat_vec_rel !> author: @tyrandis pure subroutine mm_mnp ( m , n , p , a , b , c ) integer , intent ( in ) :: m , n , p real ( rk ), intent ( in ) :: a ( m , n ), b ( n , p ) real ( rk ), intent ( out ) :: c ( m , p ) integer :: i , j , k c = 0.0_rk do i = 1 , m do j = 1 , n do k = 1 , p c ( i , k ) = c ( i , k ) + a ( i , j ) * b ( j , k ) end do end do end do end subroutine mm_mnp !> author: @tyrandis pure subroutine mm_mpn ( m , n , p , a , b , c ) integer , intent ( in ) :: m , n , p real ( rk ), intent ( in ) :: a ( m , n ), b ( n , p ) real ( rk ), intent ( out ) :: c ( m , p ) integer :: i , j , k c = 0.0_rk do i = 1 , m do j = 1 , p do k = 1 , n c ( i , j ) = c ( i , j ) + a ( i , k ) * b ( k , j ) end do end do end do end subroutine mm_mpn !> author: @tyrandis pure subroutine mm_nmp ( m , n , p , a , b , c ) integer , intent ( in ) :: m , n , p real ( rk ), intent ( in ) :: a ( m , n ), b ( n , p ) real ( rk ), intent ( out ) :: c ( m , p ) integer :: i , j , k c = 0.0_rk do i = 1 , n do j = 1 , m do k = 1 , p c ( j , k ) = c ( j , k ) + a ( j , i ) * b ( i , k ) end do end do end do end subroutine mm_nmp !> author: @tyrandis pure subroutine mm_npm ( m , n , p , a , b , c ) integer , intent ( in ) :: m , n , p real ( rk ), intent ( in ) :: a ( m , n ), b ( n , p ) real ( rk ), intent ( out ) :: c ( m , p ) integer :: i , j , k c = 0.0_rk do i = 1 , n do j = 1 , p do k = 1 , m c ( k , j ) = c ( k , j ) + a ( k , i ) * b ( i , j ) end do end do end do end subroutine mm_npm !> author: @tyrandis pure subroutine mm_pmn ( m , n , p , a , b , c ) integer , intent ( in ) :: m , n , p real ( rk ), intent ( in ) :: a ( m , n ), b ( n , p ) real ( rk ), intent ( out ) :: c ( m , p ) integer :: i , j , k c = 0.0_rk do i = 1 , p do j = 1 , m do k = 1 , n c ( j , i ) = c ( j , i ) + a ( j , k ) * b ( k , i ) end do end do end do end subroutine mm_pmn !> author: @tyrandis pure subroutine mm_pnm ( m , n , p , a , b , c ) integer , intent ( in ) :: m , n , p real ( rk ), intent ( in ) :: a ( m , n ), b ( n , p ) real ( rk ), intent ( out ) :: c ( m , p ) integer :: i , j , k c = 0.0_rk do i = 1 , p do j = 1 , n do k = 1 , m c ( k , i ) = c ( k , i ) + a ( k , j ) * b ( j , i ) end do end do end do end subroutine mm_pnm !> author: Seyed Ali Ghasemi pure subroutine mm_9 ( m , n , p , a , b , c ) integer , intent ( in ) :: m , n , p real ( rk ), intent ( in ) :: a ( m , n ), b ( n , p ) real ( rk ), intent ( out ) :: c ( m , p ) integer :: i , k c = 0.0_rk do i = 1 , p do k = 1 , m c ( k , i ) = dot_product ( a ( k ,:), b (:, i )) end do end do end subroutine mm_9 !> author: Seyed Ali Ghasemi pure subroutine mm_10 ( m , n , p , a , b , c ) integer , intent ( in ) :: m , n , p real ( rk ), intent ( in ) :: a ( m , n ), b ( n , p ) real ( rk ), intent ( out ) :: c ( m , p ) integer :: i , k c = 0.0_rk do concurrent ( i = 1 : p ) do k = 1 , m c ( k , i ) = dot_product ( a ( k ,:), b (:, i )) end do end do end subroutine mm_10 !> author: Seyed Ali Ghasemi pure subroutine mm_11 ( m , n , p , a , b , c ) integer , intent ( in ) :: m , n , p real ( rk ), intent ( in ) :: a ( m , n ), b ( n , p ) real ( rk ), intent ( out ) :: c ( m , p ) integer :: i , j , k c = 0.0_rk do concurrent ( i = 1 : p ) do j = 1 , n do k = 1 , m c ( k , i ) = c ( k , i ) + a ( k , j ) * b ( j , i ) end do end do end do end subroutine mm_11 !> author: Seyed Ali Ghasemi pure subroutine mm_12 ( m , n , p , a , b , c ) integer , intent ( in ) :: m , n , p real ( rk ), intent ( in ) :: a ( m , n ), b ( n , p ) real ( rk ), intent ( out ) :: c ( m , p ) interface pure subroutine impure_mm_12 ( f_m , f_n , f_p , f_a , f_b , f_c ) import rk integer , intent ( in ) :: f_m , f_n , f_p real ( rk ), intent ( in ) :: f_a ( f_m , f_n ), f_b ( f_n , f_p ) real ( rk ), intent ( out ) :: f_c ( f_m , f_p ) end subroutine impure_mm_12 end interface call impure_mm_12 ( m , n , p , a , b , c ) end subroutine mm_12 !> author: Seyed Ali Ghasemi pure subroutine mm_13 ( m , n , p , a , b , c ) integer , intent ( in ) :: m , n , p real ( rk ), intent ( in ) :: a ( m , n ), b ( n , p ) real ( rk ), intent ( out ) :: c ( m , p ) integer :: i , k interface pure subroutine impure_mm_13 ( f_m , f_n , f_p , f_a , f_b , f_c ) import rk integer , intent ( in ) :: f_m , f_n , f_p real ( rk ), intent ( in ) :: f_a ( f_m , f_n ), f_b ( f_n , f_p ) real ( rk ), intent ( out ) :: f_c ( f_m , f_p ) end subroutine impure_mm_13 end interface call impure_mm_13 ( m , n , p , a , b , c ) end subroutine mm_13 !> author: Seyed Ali Ghasemi pure subroutine mv_3 ( m , n , a , b , c ) integer , intent ( in ) :: m , n real ( rk ), intent ( in ) :: a ( m , n ), b ( n ) real ( rk ), intent ( out ) :: c ( m ) integer :: i , j c = 0.0_rk do i = 1 , m do j = 1 , n c ( i ) = c ( i ) + a ( i , j ) * b ( j ) end do end do end subroutine mv_3 !> author: Seyed Ali Ghasemi pure subroutine mv_4 ( m , n , a , b , c ) integer , intent ( in ) :: m , n real ( rk ), intent ( in ) :: a ( m , n ), b ( n ) real ( rk ), intent ( out ) :: c ( m ) integer :: i , j c = 0.0_rk do j = 1 , n do i = 1 , m c ( i ) = c ( i ) + a ( i , j ) * b ( j ) end do end do end subroutine mv_4 !> author: Seyed Ali Ghasemi pure subroutine mv_5 ( m , n , a , b , c ) integer , intent ( in ) :: m , n real ( rk ), intent ( in ) :: a ( m , n ), b ( n ) real ( rk ), intent ( out ) :: c ( m ) integer :: k c = 0.0_rk do k = 1 , m c ( k ) = dot_product ( a ( k ,:), b (:)) end do end subroutine mv_5 !> author: Seyed Ali Ghasemi pure subroutine mv_6 ( m , n , a , b , c ) integer , intent ( in ) :: m , n real ( rk ), intent ( in ) :: a ( m , n ), b ( n ) real ( rk ), intent ( out ) :: c ( m ) integer :: k c = 0.0_rk do k = 1 , n c (:) = c (:) + a (:, k ) * b ( k ) end do end subroutine mv_6 end module formatmul_opts !> author: Seyed Ali Ghasemi impure subroutine impure_mm_12 ( m , n , p , a , b , c ) use kinds , only : rk implicit none integer , intent ( in ) :: m , n , p real ( rk ), intent ( in ) :: a ( m , n ), b ( n , p ) real ( rk ), intent ( out ) :: c ( m , p ) integer :: i , k c = 0.0_rk !$OMP PARALLEL DO PRIVATE(i, k) do i = 1 , p do k = 1 , m c ( k , i ) = dot_product ( a ( k ,:), b (:, i )) end do end do !$OMP END PARALLEL DO end subroutine impure_mm_12 !> author: Seyed Ali Ghasemi impure subroutine impure_mm_13 ( m , n , p , a , b , c ) use kinds , only : rk implicit none integer , intent ( in ) :: m , n , p real ( rk ), intent ( in ) :: a ( m , n ), b ( n , p ) real ( rk ), intent ( out ) :: c ( m , p ) integer :: i , k c = 0.0_rk !$OMP PARALLEL DO DEFAULT(NONE) PRIVATE(i, k) SHARED(m, p, a, b, c) do i = 1 , p do k = 1 , m c ( k , i ) = dot_product ( a ( k ,:), b (:, i )) end do end do !$OMP END PARALLEL DO end subroutine impure_mm_13","tags":"","loc":"sourcefile/formatmul_opts.f90.html"},{"title":"formatmul.f90 – ForMatmul","text":"This file depends on sourcefile~~formatmul.f90~~EfferentGraph sourcefile~formatmul.f90 formatmul.f90 sourcefile~formatmul_opts.f90 formatmul_opts.f90 sourcefile~formatmul.f90->sourcefile~formatmul_opts.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~formatmul.f90~~AfferentGraph sourcefile~formatmul.f90 formatmul.f90 sourcefile~benchmark1.f90 benchmark1.f90 sourcefile~benchmark1.f90->sourcefile~formatmul.f90 sourcefile~benchmark2.f90 benchmark2.f90 sourcefile~benchmark2.f90->sourcefile~formatmul.f90 sourcefile~benchmark3.f90 benchmark3.f90 sourcefile~benchmark3.f90->sourcefile~formatmul.f90 sourcefile~benchmark4.f90 benchmark4.f90 sourcefile~benchmark4.f90->sourcefile~formatmul.f90 sourcefile~example1.f90 example1.f90 sourcefile~example1.f90->sourcefile~formatmul.f90 sourcefile~example2.f90 example2.f90 sourcefile~example2.f90->sourcefile~formatmul.f90 sourcefile~example3.f90 example3.f90 sourcefile~example3.f90->sourcefile~formatmul.f90 sourcefile~example4.f90 example4.f90 sourcefile~example4.f90->sourcefile~formatmul.f90 sourcefile~example6.f90 example6.f90 sourcefile~example6.f90->sourcefile~formatmul.f90 sourcefile~example8.f90 example8.f90 sourcefile~example8.f90->sourcefile~formatmul.f90 sourcefile~test1.f90 test1.f90 sourcefile~test1.f90->sourcefile~formatmul.f90 sourcefile~test2.f90 test2.f90 sourcefile~test2.f90->sourcefile~formatmul.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Module: formatmul !! This module provides matrix and vector multiplication functions using different methods. module formatmul !> Use the kinds module for real(kind) type. use kinds use formatmul_opts implicit none private public matmul !> Interface for matrix multiplication functions. interface matmul procedure :: mat_mat procedure :: mat_vec end interface contains !> Matrix-matrix multiplication using coarray parallelism. !> author: Seyed Ali Ghasemi #if defined(USE_COARRAY) impure function mat_mat ( A , B , method , option ) result ( C ) #else pure function mat_mat ( A , B , method , option ) result ( C ) #endif !> Input matrices A and B. real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) !> Multiplication method ('coarray'). character ( * ), intent ( in ) :: method !> Optional method-specific option. character ( * ), intent ( in ), optional :: option !> Result matrix C. real ( rk ) :: C ( size ( A , 1 ), size ( B , 2 )) select case ( method ) #if defined(USE_COARRAY) case ( 'coarray' ) ! Coarray-based parallel multiplication. if ( size ( A , 1 ) >= size ( B , 2 )) then ! Handle A's columns > B's rows. block integer :: i , im , nimg , n , o integer :: block_size ( num_images ()), start_elem ( num_images ()), end_elem ( num_images ()) real ( rk ), allocatable :: C_block (:,:)[:], A_block (:,:)[:] im = this_image () nimg = num_images () n = size ( A , 2 ) o = size ( B , 2 ) call compute_block_ranges ( size ( A , 1 ), nimg , block_size , start_elem , end_elem ) allocate ( A_block ( block_size ( im ), n )[ * ], C_block ( block_size ( im ), o )[ * ]) A_block (:,:)[ im ] = A ( start_elem ( im ): end_elem ( im ), :) C_block (:,:)[ im ] = matmul_opts ( A_block (:,:)[ im ], B , option ) sync all if ( im == 1 ) then do i = 1 , nimg C ( start_elem ( i ): end_elem ( i ), :) = C_block (:,:)[ i ] end do end if end block else ! Handle B's columns > A's rows. block integer :: i , im , nimg , n , m integer :: block_size ( num_images ()), start_elem ( num_images ()), end_elem ( num_images ()) real ( rk ), allocatable :: C_block (:,:)[:], B_block (:,:)[:] im = this_image () nimg = num_images () n = size ( A , 2 ) m = size ( A , 1 ) call compute_block_ranges ( size ( B , 2 ), nimg , block_size , start_elem , end_elem ) allocate ( B_block ( n , block_size ( im ))[ * ], C_block ( m , block_size ( im ))[ * ]) B_block (:,:)[ im ] = B (:, start_elem ( im ): end_elem ( im )) C_block (:,:)[ im ] = matmul_opts ( A , B_block (:,:)[ im ], option ) sync all if ( im == 1 ) then do i = 1 , nimg C (:, start_elem ( i ): end_elem ( i )) = C_block (:,:)[ i ] end do end if end block end if #endif case ( 'default' ) C = matmul_opts ( A , B , option ) end select end function mat_mat !> Matrix-vector multiplication using coarray parallelism. !> author: Seyed Ali Ghasemi #if defined(USE_COARRAY) impure function mat_vec ( A , v , method , option ) result ( w ) #else pure function mat_vec ( A , v , method , option ) result ( w ) #endif !> Input matrix A and vector v. real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) !> Multiplication method ('coarray'). character ( * ), intent ( in ) :: method !> Optional method-specific option. character ( * ), intent ( in ), optional :: option !> Result vector w. real ( rk ) :: w ( size ( A , 1 )) select case ( method ) #if defined(USE_COARRAY) case ( 'coarray' ) ! Coarray-based parallel multiplication. block integer :: i , im , nimg integer :: block_size ( num_images ()), start_elem ( num_images ()), end_elem ( num_images ()) real ( rk ), allocatable :: w_block (:)[:] im = this_image () nimg = num_images () call compute_block_ranges ( size ( A , 1 ), nimg , block_size , start_elem , end_elem ) allocate ( w_block ( block_size ( im ))[ * ]) w_block (:)[ im ] = matmul_opts ( A ( start_elem ( im ): end_elem ( im ), :), v , option ) sync all if ( im == 1 ) then do i = 1 , nimg w ( start_elem ( i ): end_elem ( i )) = w_block (:)[ i ] end do end if end block #endif case ( 'default' ) w = matmul_opts ( A , v , option ) end select end function mat_vec !> Calculate block sizes and ranges. !> author: Seyed Ali Ghasemi pure subroutine compute_block_ranges ( d , nimg , block_size , start_elem , end_elem ) integer , intent ( in ) :: d , nimg integer , intent ( out ) :: block_size ( nimg ), start_elem ( nimg ), end_elem ( nimg ) integer :: i , remainder block_size = d / nimg remainder = mod ( d , nimg ) block_size ( 1 : remainder ) = block_size ( 1 : remainder ) + 1 start_elem ( 1 ) = 1 end_elem ( 1 ) = block_size ( 1 ) do i = 2 , nimg start_elem ( i ) = start_elem ( i - 1 ) + block_size ( i - 1 ) end_elem ( i ) = start_elem ( i ) + block_size ( i ) - 1 end do ! Check if the block sizes are valid. if ( minval ( block_size ) <= 0 ) error stop 'ForMatmul: reduce the number of images of coarray.' end subroutine compute_block_ranges end module formatmul","tags":"","loc":"sourcefile/formatmul.f90.html"},{"title":"example4.f90 – ForMatmul","text":"This file depends on sourcefile~~example4.f90~~EfferentGraph sourcefile~example4.f90 example4.f90 sourcefile~formatmul.f90 formatmul.f90 sourcefile~example4.f90->sourcefile~formatmul.f90 sourcefile~formatmul_opts.f90 formatmul_opts.f90 sourcefile~formatmul.f90->sourcefile~formatmul_opts.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program example4 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), v (:) real ( rk ), allocatable :: w (:) type ( timer ) :: t integer :: m , n ! w(m) = A(m,n).v(n) m = 64 * 2 * 100 n = 16 * 2 * 100 allocate ( A ( m , n ), v ( n )) call random_number ( A ) call random_number ( v ) #if defined(USE_COARRAY) sync all call t % timer_start () w = matmul ( A , v , 'coarray' ) call t % timer_stop ( message = ' Elapsed time (example4: mat_vec, coarray):' ) #else call t % timer_start () w = matmul ( A , v ) call t % timer_stop ( message = ' Elapsed time (example4: mat_vec):' ) #endif end program example4","tags":"","loc":"sourcefile/example4.f90.html"},{"title":"benchmark2.f90 – ForMatmul","text":"This file depends on sourcefile~~benchmark2.f90~~EfferentGraph sourcefile~benchmark2.f90 benchmark2.f90 sourcefile~formatmul.f90 formatmul.f90 sourcefile~benchmark2.f90->sourcefile~formatmul.f90 sourcefile~formatmul_opts.f90 formatmul_opts.f90 sourcefile~benchmark2.f90->sourcefile~formatmul_opts.f90 sourcefile~formatmul.f90->sourcefile~formatmul_opts.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program benchmark2 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul use formatmul_opts , only : matmul_blas implicit none real ( rk ), allocatable :: A (:,:), v (:) real ( rk ), allocatable :: w (:) type ( timer ) :: t integer :: m , n , i , l character ( 2 ) :: im ! w(m) = A(m,n).v(n) m = 64 * 2 * 100 n = 16 * 2 * 100 l = 5 allocate ( A ( m , n ), v ( n )) call random_number ( A ) call random_number ( v ) #if defined(USE_COARRAY) sync all if ( this_image () == 1 ) call t % timer_start () do i = 1 , l w = matmul ( A , v ) end do if ( this_image () == 1 ) call t % timer_stop ( message = ' Elapsed time (matmul):' , nloops = l ) #else call t % timer_start () do i = 1 , l w = matmul ( A , v ) end do call t % timer_stop ( message = ' Elapsed time (matmul):' , nloops = l ) #endif #if defined(USE_COARRAY) sync all if ( this_image () == 1 ) call t % timer_start () do i = 1 , l w = matmul_blas ( A , v ) end do if ( this_image () == 1 ) call t % timer_stop ( message = ' Elapsed time (dgemv):' , nloops = l ) #else call t % timer_start () do i = 1 , l w = matmul_blas ( A , v ) end do call t % timer_stop ( message = ' Elapsed time (dgemv):' , nloops = l ) #endif #if defined(USE_COARRAY) sync all call t % timer_start () do i = 1 , l w = matmul ( A , v , 'coarray' , 'm1' ) end do write ( im , \"(I2)\" ) this_image () call t % timer_stop ( message = ' Elapsed time (coarray with matmul) image=' // trim ( im ) // ':' , nloops = l ) #else call t % timer_start () do i = 1 , l w = matmul ( A , v , 'default' , 'm1' ) end do call t % timer_stop ( message = ' Elapsed time (default with matmul) image=' // trim ( im ) // ':' , nloops = l ) #endif #if defined(USE_COARRAY) sync all call t % timer_start () do i = 1 , l w = matmul ( A , v , 'coarray' , 'm2' ) end do write ( im , \"(I2)\" ) this_image () call t % timer_stop ( message = ' Elapsed time (coarray with dgemv) image=' // trim ( im ) // ':' , nloops = l ) #else call t % timer_start () do i = 1 , l w = matmul ( A , v , 'default' , 'm2' ) end do call t % timer_stop ( message = ' Elapsed time (default with dgemv) image=' // trim ( im ) // ':' , nloops = l ) #endif end program benchmark2","tags":"","loc":"sourcefile/benchmark2.f90.html"},{"title":"test2.f90 – ForMatmul","text":"This file depends on sourcefile~~test2.f90~~EfferentGraph sourcefile~test2.f90 test2.f90 sourcefile~formatmul.f90 formatmul.f90 sourcefile~test2.f90->sourcefile~formatmul.f90 sourcefile~formatmul_opts.f90 formatmul_opts.f90 sourcefile~formatmul.f90->sourcefile~formatmul_opts.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program mat_vec use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), v (:) real ( rk ), allocatable :: w (:), w_co (:) type ( timer ) :: t integer :: m , n ! w(m) = A(m,n).v(n) m = 200 n = 100 allocate ( A ( m , n ), v ( n )) call random_number ( A ) call random_number ( v ) w = matmul ( A , v ) #if defined(USE_COARRAY) sync all w_co = matmul ( A , v , 'coarray' ) sync all if ( this_image () == 1 ) print * , 'test2: relative error:' , norm2 ( w - w_co ) / norm2 ( w ) #endif end program mat_vec","tags":"","loc":"sourcefile/test2.f90.html"},{"title":"benchmark1.f90 – ForMatmul","text":"This file depends on sourcefile~~benchmark1.f90~~EfferentGraph sourcefile~benchmark1.f90 benchmark1.f90 sourcefile~formatmul.f90 formatmul.f90 sourcefile~benchmark1.f90->sourcefile~formatmul.f90 sourcefile~formatmul_opts.f90 formatmul_opts.f90 sourcefile~benchmark1.f90->sourcefile~formatmul_opts.f90 sourcefile~formatmul.f90->sourcefile~formatmul_opts.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program benchmark1 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul use formatmul_opts , only : matmul_blas implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C (:,:) type ( timer ) :: t integer :: m , n , o , i , l character ( 2 ) :: im ! C(m,o) = A(m,n).B(n,o) m = 3000 n = 2000 o = 1000 l = 5 allocate ( A ( m , n ), B ( n , o )) call random_number ( A ) call random_number ( B ) #if defined(USE_COARRAY) sync all if ( this_image () == 1 ) call t % timer_start () do i = 1 , l C = matmul ( A , B ) end do if ( this_image () == 1 ) call t % timer_stop ( message = ' Elapsed time (matmul):' , nloops = l ) #else call t % timer_start () do i = 1 , l C = matmul ( A , B ) end do call t % timer_stop ( message = ' Elapsed time (matmul):' , nloops = l ) #endif #if defined(USE_COARRAY) sync all if ( this_image () == 1 ) call t % timer_start () do i = 1 , l C = matmul_blas ( A , B ) end do if ( this_image () == 1 ) call t % timer_stop ( message = ' Elapsed time (dgemm):' , nloops = l ) #else call t % timer_start () do i = 1 , l C = matmul_blas ( A , B ) end do call t % timer_stop ( message = ' Elapsed time (dgemm):' , nloops = l ) #endif #if defined(USE_COARRAY) sync all call t % timer_start () do i = 1 , l C = matmul ( A , B , 'coarray' , 'm1' ) end do write ( im , \"(I2)\" ) this_image () call t % timer_stop ( message = ' Elapsed time (coarray with matmul) image=' // trim ( im ) // ':' , nloops = l ) #else call t % timer_start () do i = 1 , l C = matmul ( A , B , 'default' , 'm1' ) end do call t % timer_stop ( message = ' Elapsed time (default with matmul) image=' // trim ( im ) // ':' , nloops = l ) #endif #if defined(USE_COARRAY) sync all call t % timer_start () do i = 1 , l C = matmul ( A , B , 'coarray' , 'm2' ) end do call t % timer_stop ( message = ' Elapsed time (coarray with dgemm) image=' // trim ( im ) // ':' , nloops = l ) #else call t % timer_start () do i = 1 , l C = matmul ( A , B , 'default' , 'm2' ) end do call t % timer_stop ( message = ' Elapsed time (default with dgemm) image=' // trim ( im ) // ':' , nloops = l ) #endif end program benchmark1","tags":"","loc":"sourcefile/benchmark1.f90.html"},{"title":"example3.f90 – ForMatmul","text":"This file depends on sourcefile~~example3.f90~~EfferentGraph sourcefile~example3.f90 example3.f90 sourcefile~formatmul.f90 formatmul.f90 sourcefile~example3.f90->sourcefile~formatmul.f90 sourcefile~formatmul_opts.f90 formatmul_opts.f90 sourcefile~formatmul.f90->sourcefile~formatmul_opts.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program example3 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), v (:) real ( rk ), allocatable :: w (:) type ( timer ) :: t integer :: m , n ! w(m) = A(m,n).v(n) m = 64 * 2 * 100 n = 16 * 2 * 100 allocate ( A ( m , n ), v ( n )) call random_number ( A ) call random_number ( v ) #if defined(USE_COARRAY) sync all if ( this_image () == 1 ) call t % timer_start () w = matmul ( A , v ) if ( this_image () == 1 ) call t % timer_stop ( message = ' Elapsed time (example3: mat_vec):' ) #else call t % timer_start () w = matmul ( A , v ) call t % timer_stop ( message = ' Elapsed time (example3: mat_vec):' ) #endif end program example3","tags":"","loc":"sourcefile/example3.f90.html"},{"title":"formatmul_benchmark.f90 – ForMatmul","text":"Files dependent on this one sourcefile~~formatmul_benchmark.f90~~AfferentGraph sourcefile~formatmul_benchmark.f90 formatmul_benchmark.f90 sourcefile~benchmark3.f90 benchmark3.f90 sourcefile~benchmark3.f90->sourcefile~formatmul_benchmark.f90 sourcefile~benchmark4.f90 benchmark4.f90 sourcefile~benchmark4.f90->sourcefile~formatmul_benchmark.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module formatmul_benchmark use kinds , only : rk use fortime , only : timer implicit none private public start_benchmark , stop_benchmark , write_benchmark contains !> author: Seyed Ali Ghasemi subroutine start_benchmark ( t , m , n , o , msg ) type ( timer ), intent ( out ) :: t character ( * ), intent ( in ) :: msg integer , intent ( in ) :: m , n , o #if defined(USE_COARRAY) sync all if ( this_image () == 1 ) then print \"(a,', m=',g0,', n=',g0,', o=',g0)\" , msg , m , n , o end if call t % timer_start () #else print \"(a,', m=',g0,', n=',g0,', o=',g0)\" , msg , m , n , o call t % timer_start () #endif end subroutine start_benchmark !> author: Seyed Ali Ghasemi subroutine stop_benchmark ( t , m , n , o , nloops , Mat , Mat_ref , method , filename ) #if defined(USE_COARRAY) type ( timer ), intent ( inout ) :: t [ * ] #else type ( timer ), intent ( inout ) :: t #endif integer , intent ( in ) :: m , n , o , nloops real ( rk ), intent ( in ) :: Mat ( m , o ), Mat_ref ( m , o ) character ( * ), intent ( in ) :: method character ( * ), intent ( in ) :: filename integer :: nunit , i real ( rk ) :: elapsed_time_average #if defined(USE_COARRAY) real ( rk ), allocatable :: gflops [:] #else real ( rk ) :: gflops #endif real ( rk ) :: gflops_total #if defined(USE_COARRAY) allocate ( gflops [ * ]) call t [ this_image ()]% timer_stop ( message = ' Elapsed time :' , nloops = nloops ) gflops [ this_image ()] = real ( m , rk ) * real ( n , rk ) * real ( o , rk ) * 1e-9_rk / t [ this_image ()]% elapsed_time print '(a,f6.2,a)' , ' Performance  : ' , gflops [ this_image ()], ' [GFLOPS/image]' sync all if ( this_image () == 1 ) then elapsed_time_average = 0.0_rk gflops_total = 0.0_rk do i = 1 , num_images () elapsed_time_average = elapsed_time_average + t [ i ]% elapsed_time gflops_total = gflops_total + gflops [ i ] end do elapsed_time_average = elapsed_time_average / num_images () print '(a,3e13.6)' , ' Relative err.: ' , norm2 ( Mat_ref - Mat ) / norm2 ( Mat_ref ) print '(a,f7.3,a)' , ' Elapsed time (average) :' , elapsed_time_average , ' [s]' print '(a,f6.2,a)' , ' Performance  (total)   : ' , gflops_total , ' [GFLOPS]' print '(a)' , '' end if call co_broadcast ( elapsed_time_average , 1 ) call co_broadcast ( gflops_total , 1 ) call write_benchmark ( method , m , n , o , nloops , t , elapsed_time_average , gflops , gflops_total , filename ) #else call t % timer_stop ( message = ' Elapsed time :' , nloops = nloops ) gflops = real ( m , rk ) * real ( n , rk ) * real ( o , rk ) * 1e-9_rk / t % elapsed_time print '(a,f6.2,a)' , ' Performance  : ' , gflops , ' [GFLOPS]' print '(a,3e13.6)' , ' Relative err.: ' , norm2 ( Mat_ref - Mat ) / norm2 ( Mat_ref ) print '(a,f7.3,a)' , ' Elapsed time :' , t % elapsed_time , ' [s]' print '(a,f6.2,a)' , ' Performance  : ' , gflops , ' [GFLOPS]' print '(a)' , '' call write_benchmark ( method , m , n , o , nloops , t , elapsed_time_average , gflops , gflops_total , filename ) #endif end subroutine stop_benchmark !> author: Seyed Ali Ghasemi subroutine write_benchmark ( method , m , n , o , nloops , t , elapsed_time_average , gflops , gflops_total , filename ) character ( * ), intent ( in ) :: method integer , intent ( in ) :: m , n , o , nloops #if defined(USE_COARRAY) type ( timer ), intent ( in ) :: t [ * ] #else type ( timer ), intent ( in ) :: t #endif character ( * ), intent ( in ) :: filename real ( rk ), intent ( in ) :: elapsed_time_average real ( rk ), intent ( in ) :: gflops_total integer :: nunit #if defined(USE_COARRAY) real ( rk ) :: gflops [ * ] #else real ( rk ) :: gflops #endif #if defined(USE_COARRAY) open ( newunit = nunit , file = filename , access = 'append' ) write ( nunit , '(a,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0)' ) & method , m , n , o , nloops , t [ this_image ()]% elapsed_time , gflops [ this_image ()], elapsed_time_average , gflops_total close ( nunit ) #else open ( newunit = nunit , file = filename , access = 'append' ) write ( nunit , '(a,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0)' ) & method , m , n , o , nloops , t % elapsed_time , gflops , elapsed_time_average , gflops_total close ( nunit ) #endif end subroutine write_benchmark end module formatmul_benchmark","tags":"","loc":"sourcefile/formatmul_benchmark.f90.html"}]}