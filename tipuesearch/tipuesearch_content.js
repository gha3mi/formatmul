var tipuesearch = {"pages":[{"title":" ForMatmul ","text":"ForMatmul ForMatmul : A Fortran library that overloads the matmul function to enable efficient matrix multiplication with coarray. Usage use formatmul c = matmul ( a , b , method = 'coarray' ) fpm dependency If you want to use ForMatmul as a dependency in your own fpm project,\nyou can easily include it by adding the following line to your fpm.toml file: [dependencies] formatmul = { git = \"https://github.com/gha3mi/formatmul.git\" } How to run tests and examples Clone the repository: You can clone the ForMatmul repository from GitHub using the following command: git clone https://github.com/gha3mi/formatmul.git cd formatmul Run tests: fpm @ifort-test Run examples: fpm @ifort-example Results: Elapsed time ( example1: mat_mat ) : 1 .616 [ s ] Elapsed time ( example2: mat_mat, coarray ) : 0 .444 [ s ] Elapsed time ( example2: mat_mat, coarray ) : 0 .444 [ s ] Elapsed time ( example2: mat_mat, coarray ) : 0 .444 [ s ] Elapsed time ( example2: mat_mat, coarray ) : 0 .467 [ s ] Elapsed time ( example3: mat_vec ) : 0 .047 [ s ] Elapsed time ( example4: mat_vec, coarray ) : 0 .012 [ s ] Elapsed time ( example4: mat_vec, coarray ) : 0 .012 [ s ] Elapsed time ( example4: mat_vec, coarray ) : 0 .012 [ s ] Elapsed time ( example4: mat_vec, coarray ) : 0 .012 [ s ] API documentation The most up-to-date API documentation for the master branch is available here .\nTo generate the API documentation for the ForMatmul module using ford run the following\ncommand: ford ford.yml Contributing Contributions to ForMatmul are welcome! If you find any issues or would like to suggest improvements, please open an issue. Developer Info Seyed Ali Ghasemi","tags":"home","loc":"index.html"},{"title":"mat_mat – ForMatmul","text":"private pure function mat_mat(A, B, method) result(C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) character(len=*), intent(in) :: method Return Value real(kind=rk), allocatable, (:,:) Calls proc~~mat_mat~~CallsGraph proc~mat_mat formatmul::mat_mat c_block c_block proc~mat_mat->c_block Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~mat_mat~~CalledByGraph proc~mat_mat formatmul::mat_mat interface~matmul formatmul::matmul interface~matmul->proc~mat_mat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code mat_mat Source Code pure function mat_mat ( A , B , method ) result ( C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) character ( * ), intent ( in ) :: method real ( rk ), allocatable :: C (:,:) integer :: m , o , remainder_m m = size ( A , 1 ) o = size ( B , 2 ) if ( method == 'coarray' ) then block integer :: i , block_size , n , im , nimg real ( rk ), allocatable :: C_block (:,:)[:] im = this_image () nimg = num_images () n = size ( A , 2 ) block_size = m / nimg remainder_m = m - block_size * ( nimg - 1 ) if ( mod ( m , nimg ) == 0 ) then if (. not . allocated ( C_block )) allocate ( C_block ( block_size , o )[ * ]) C_block ( 1 : block_size , 1 : o )[ im ] = matmul ( A (( im - 1 ) * block_size + 1 : im * block_size , 1 : n ), B ( 1 : n , 1 : o )) else if (. not . allocated ( C_block )) allocate ( C_block ( remainder_m , o )[ * ]) C_block ( 1 : remainder_m , 1 : o )[ im ] = matmul ( A (( im - 1 ) * block_size + 1 : im * block_size + remainder_m , 1 : n ), B ( 1 : n , 1 : o )) end if sync all ! critical if ( im == 1 ) then if (. not . allocated ( C )) allocate ( C ( m , o )) do i = 1 , nimg - 1 C (( i - 1 ) * block_size + 1 : i * block_size , :) = C_block ( 1 : block_size , 1 : o )[ i ] end do C (( nimg - 1 ) * block_size + 1 : m , :) = C_block ( 1 : remainder_m , 1 : o )[ nimg ] end if ! end critical end block else error stop 'Error: The specified method is not available for matrix-matrix multiplication!' ! if (this_image() == 1) then !    ! if (.not. allocated(C)) allocate(C(m, o)) !    C = matmul(A, B) ! end if end if end function mat_mat","tags":"","loc":"proc/mat_mat.html"},{"title":"mat_vec – ForMatmul","text":"private pure function mat_vec(A, v, method) result(w) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) character(len=*), intent(in) :: method Return Value real(kind=rk), allocatable, (:) Calls proc~~mat_vec~~CallsGraph proc~mat_vec formatmul::mat_vec w_block w_block proc~mat_vec->w_block Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~mat_vec~~CalledByGraph proc~mat_vec formatmul::mat_vec interface~matmul formatmul::matmul interface~matmul->proc~mat_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code mat_vec Source Code pure function mat_vec ( A , v , method ) result ( w ) real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) character ( * ), intent ( in ) :: method real ( rk ), allocatable :: w (:) integer :: m , remainder_m m = size ( A , 1 ) if ( method == 'coarray' ) then block integer :: i , block_size , n , im , nimg real ( rk ), allocatable :: w_block (:)[:] im = this_image () nimg = num_images () m = size ( A , 1 ) n = size ( A , 2 ) block_size = m / nimg remainder_m = m - block_size * ( nimg - 1 ) if ( mod ( m , nimg ) == 0 ) then if (. not . allocated ( w_block )) allocate ( w_block ( block_size )[ * ]) w_block (:) = matmul ( A (( im - 1 ) * block_size + 1 : im * block_size , 1 : n ), v ) else if (. not . allocated ( w_block )) allocate ( w_block ( remainder_m )[ * ]) w_block (:) = matmul ( A (( im - 1 ) * block_size + 1 : im * block_size + remainder_m , 1 : n ), v ) end if sync all ! critical if ( im == 1 ) then if (. not . allocated ( w )) allocate ( w ( m )) do i = 1 , nimg - 1 w (( i - 1 ) * block_size + 1 : i * block_size ) = w_block (:)[ i ] end do w (( nimg - 1 ) * block_size + 1 : m ) = w_block (:)[ nimg ] end if ! end critical end block else error stop 'Error: The specified method is not available for matrix-vector multiplication!' ! if (this_image() == 1) then !    ! if (.not. allocated(w)) allocate(w(m)) !    w = matmul(A, v) ! end if end if end function mat_vec","tags":"","loc":"proc/mat_vec.html"},{"title":"matmul – ForMatmul","text":"public interface matmul Calls interface~~matmul~~CallsGraph interface~matmul formatmul::matmul proc~mat_mat formatmul::mat_mat interface~matmul->proc~mat_mat proc~mat_vec formatmul::mat_vec interface~matmul->proc~mat_vec c_block c_block proc~mat_mat->c_block w_block w_block proc~mat_vec->w_block Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Module Procedures mat_mat mat_vec Module Procedures private pure function mat_mat (A, B, method) result(C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) character(len=*), intent(in) :: method Return Value real(kind=rk), allocatable, (:,:) private pure function mat_vec (A, v, method) result(w) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) character(len=*), intent(in) :: method Return Value real(kind=rk), allocatable, (:)","tags":"","loc":"interface/matmul.html"},{"title":"formatmul – ForMatmul","text":"Uses kinds module~~formatmul~~UsesGraph module~formatmul formatmul kinds kinds module~formatmul->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~formatmul~~UsedByGraph module~formatmul formatmul program~mat_mat mat_mat program~mat_mat->module~formatmul program~mat_vec mat_vec program~mat_vec->module~formatmul Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Interfaces matmul Functions mat_mat mat_vec Interfaces public        interface matmul private pure function mat_mat (A, B, method) result(C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) character(len=*), intent(in) :: method Return Value real(kind=rk), allocatable, (:,:) private pure function mat_vec (A, v, method) result(w) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) character(len=*), intent(in) :: method Return Value real(kind=rk), allocatable, (:) Functions private pure function mat_mat (A, B, method) result(C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) character(len=*), intent(in) :: method Return Value real(kind=rk), allocatable, (:,:) private pure function mat_vec (A, v, method) result(w) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) character(len=*), intent(in) :: method Return Value real(kind=rk), allocatable, (:)","tags":"","loc":"module/formatmul.html"},{"title":"mat_vec – ForMatmul","text":"Uses fortime kinds formatmul program~~mat_vec~~UsesGraph program~mat_vec mat_vec fortime fortime program~mat_vec->fortime kinds kinds program~mat_vec->kinds module~formatmul formatmul program~mat_vec->module~formatmul module~formatmul->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables A v w w_co t m n Source Code mat_vec Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:,:) real(kind=rk), allocatable :: v (:) real(kind=rk), allocatable :: w (:) real(kind=rk), allocatable :: w_co (:) type(timer) :: t integer :: m integer :: n Source Code program mat_vec use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), v (:) real ( rk ), allocatable :: w (:), w_co (:) type ( timer ) :: t integer :: m , n ! w(m) = A(m,n).v(n) m = 200 n = 100 allocate ( A ( m , n ), v ( n )) call random_number ( A ) call random_number ( v ) w = matmul ( A , v ) sync all w_co = matmul ( A , v , 'coarray' ) sync all if ( this_image () == 1 ) print * , 'realtive error:' , norm2 ( w - w_co ) / norm2 ( w ) end program mat_vec","tags":"","loc":"program/mat_vec.html"},{"title":"mat_mat – ForMatmul","text":"Uses fortime kinds formatmul program~~mat_mat~~UsesGraph program~mat_mat mat_mat fortime fortime program~mat_mat->fortime kinds kinds program~mat_mat->kinds module~formatmul formatmul program~mat_mat->module~formatmul module~formatmul->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables A B C C_co t m n o Source Code mat_mat Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:,:) real(kind=rk), allocatable :: B (:,:) real(kind=rk), allocatable :: C (:,:) real(kind=rk), allocatable :: C_co (:,:) type(timer) :: t integer :: m integer :: n integer :: o Source Code program mat_mat use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C (:,:), C_co (:,:) type ( timer ) :: t integer :: m , n , o ! C(m,o) = A(m,n).B(n,o) m = 200 n = 100 o = 10 allocate ( A ( m , n ), B ( n , o )) call random_number ( A ) call random_number ( B ) sync all C = matmul ( A , B ) sync all C_co = matmul ( A , B , 'coarray' ) sync all if ( this_image () == 1 ) print * , 'realtive error:' , norm2 ( C - C_co ) / norm2 ( C ) end program mat_mat","tags":"","loc":"program/mat_mat.html"},{"title":"formatmul.f90 – ForMatmul","text":"Files dependent on this one sourcefile~~formatmul.f90~~AfferentGraph sourcefile~formatmul.f90 formatmul.f90 sourcefile~test1.f90 test1.f90 sourcefile~test1.f90->sourcefile~formatmul.f90 sourcefile~test2.f90 test2.f90 sourcefile~test2.f90->sourcefile~formatmul.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Modules formatmul Source Code formatmul.f90 Source Code module formatmul use kinds implicit none private public matmul !=============================================================================== interface matmul procedure :: mat_mat procedure :: mat_vec end interface !=============================================================================== contains !=============================================================================== !> author: Seyed Ali Ghasemi pure function mat_mat ( A , B , method ) result ( C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) character ( * ), intent ( in ) :: method real ( rk ), allocatable :: C (:,:) integer :: m , o , remainder_m m = size ( A , 1 ) o = size ( B , 2 ) if ( method == 'coarray' ) then block integer :: i , block_size , n , im , nimg real ( rk ), allocatable :: C_block (:,:)[:] im = this_image () nimg = num_images () n = size ( A , 2 ) block_size = m / nimg remainder_m = m - block_size * ( nimg - 1 ) if ( mod ( m , nimg ) == 0 ) then if (. not . allocated ( C_block )) allocate ( C_block ( block_size , o )[ * ]) C_block ( 1 : block_size , 1 : o )[ im ] = matmul ( A (( im - 1 ) * block_size + 1 : im * block_size , 1 : n ), B ( 1 : n , 1 : o )) else if (. not . allocated ( C_block )) allocate ( C_block ( remainder_m , o )[ * ]) C_block ( 1 : remainder_m , 1 : o )[ im ] = matmul ( A (( im - 1 ) * block_size + 1 : im * block_size + remainder_m , 1 : n ), B ( 1 : n , 1 : o )) end if sync all ! critical if ( im == 1 ) then if (. not . allocated ( C )) allocate ( C ( m , o )) do i = 1 , nimg - 1 C (( i - 1 ) * block_size + 1 : i * block_size , :) = C_block ( 1 : block_size , 1 : o )[ i ] end do C (( nimg - 1 ) * block_size + 1 : m , :) = C_block ( 1 : remainder_m , 1 : o )[ nimg ] end if ! end critical end block else error stop 'Error: The specified method is not available for matrix-matrix multiplication!' ! if (this_image() == 1) then !    ! if (.not. allocated(C)) allocate(C(m, o)) !    C = matmul(A, B) ! end if end if end function mat_mat !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure function mat_vec ( A , v , method ) result ( w ) real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) character ( * ), intent ( in ) :: method real ( rk ), allocatable :: w (:) integer :: m , remainder_m m = size ( A , 1 ) if ( method == 'coarray' ) then block integer :: i , block_size , n , im , nimg real ( rk ), allocatable :: w_block (:)[:] im = this_image () nimg = num_images () m = size ( A , 1 ) n = size ( A , 2 ) block_size = m / nimg remainder_m = m - block_size * ( nimg - 1 ) if ( mod ( m , nimg ) == 0 ) then if (. not . allocated ( w_block )) allocate ( w_block ( block_size )[ * ]) w_block (:) = matmul ( A (( im - 1 ) * block_size + 1 : im * block_size , 1 : n ), v ) else if (. not . allocated ( w_block )) allocate ( w_block ( remainder_m )[ * ]) w_block (:) = matmul ( A (( im - 1 ) * block_size + 1 : im * block_size + remainder_m , 1 : n ), v ) end if sync all ! critical if ( im == 1 ) then if (. not . allocated ( w )) allocate ( w ( m )) do i = 1 , nimg - 1 w (( i - 1 ) * block_size + 1 : i * block_size ) = w_block (:)[ i ] end do w (( nimg - 1 ) * block_size + 1 : m ) = w_block (:)[ nimg ] end if ! end critical end block else error stop 'Error: The specified method is not available for matrix-vector multiplication!' ! if (this_image() == 1) then !    ! if (.not. allocated(w)) allocate(w(m)) !    w = matmul(A, v) ! end if end if end function mat_vec !=============================================================================== end module formatmul","tags":"","loc":"sourcefile/formatmul.f90.html"},{"title":"test2.f90 – ForMatmul","text":"This file depends on sourcefile~~test2.f90~~EfferentGraph sourcefile~test2.f90 test2.f90 sourcefile~formatmul.f90 formatmul.f90 sourcefile~test2.f90->sourcefile~formatmul.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Programs mat_vec Source Code test2.f90 Source Code program mat_vec use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), v (:) real ( rk ), allocatable :: w (:), w_co (:) type ( timer ) :: t integer :: m , n ! w(m) = A(m,n).v(n) m = 200 n = 100 allocate ( A ( m , n ), v ( n )) call random_number ( A ) call random_number ( v ) w = matmul ( A , v ) sync all w_co = matmul ( A , v , 'coarray' ) sync all if ( this_image () == 1 ) print * , 'realtive error:' , norm2 ( w - w_co ) / norm2 ( w ) end program mat_vec","tags":"","loc":"sourcefile/test2.f90.html"},{"title":"test1.f90 – ForMatmul","text":"This file depends on sourcefile~~test1.f90~~EfferentGraph sourcefile~test1.f90 test1.f90 sourcefile~formatmul.f90 formatmul.f90 sourcefile~test1.f90->sourcefile~formatmul.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Programs mat_mat Source Code test1.f90 Source Code program mat_mat use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C (:,:), C_co (:,:) type ( timer ) :: t integer :: m , n , o ! C(m,o) = A(m,n).B(n,o) m = 200 n = 100 o = 10 allocate ( A ( m , n ), B ( n , o )) call random_number ( A ) call random_number ( B ) sync all C = matmul ( A , B ) sync all C_co = matmul ( A , B , 'coarray' ) sync all if ( this_image () == 1 ) print * , 'realtive error:' , norm2 ( C - C_co ) / norm2 ( C ) end program mat_mat","tags":"","loc":"sourcefile/test1.f90.html"}]}