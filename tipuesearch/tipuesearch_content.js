var tipuesearch = {"pages":[{"title":" ForMatmul ","text":"ForMatmul ForMatmul : A Fortran library that overloads the matmul function to enable efficient matrix multiplication with coarray. Usage use formatmul c = matmul ( a , b , method = 'coarray' ) fpm dependency If you want to use ForMatmul as a dependency in your own fpm project,\nyou can easily include it by adding the following line to your fpm.toml file: [dependencies] formatmul = { git = \"https://github.com/gha3mi/formatmul.git\" } How to run tests and examples Clone the repository: You can clone the ForMatmul repository from GitHub using the following command: git clone https://github.com/gha3mi/formatmul.git cd formatmul Run tests: Tested with Intel compiler: ifort (IFORT) 2021.10.0 20230609 fpm @ifort-test Tested with Intel compiler: ifx (IFX) 2023.2.0 20230622 fpm @ifx-test Run examples: To set the stack size to unlimited, use the following command: ulimit -s unlimited . You have the option to modify the number of images in the fpm.rsp file by using the flag -coarray-num-images=N . fpm @ifort-example fpm @ifx-example Results with -coarray-num-images=4 : Elapsed time ( example1: mat_mat ) : 1 .175 [ s ] Elapsed time ( example2: mat_mat, coarray ) : 0 .269 [ s ] Elapsed time ( example2: mat_mat, coarray ) : 0 .272 [ s ] Elapsed time ( example2: mat_mat, coarray ) : 0 .274 [ s ] Elapsed time ( example2: mat_mat, coarray ) : 0 .275 [ s ] Elapsed time ( example3: mat_vec ) : 0 .047 [ s ] Elapsed time ( example4: mat_vec, coarray ) : 0 .012 [ s ] Elapsed time ( example4: mat_vec, coarray ) : 0 .012 [ s ] Elapsed time ( example4: mat_vec, coarray ) : 0 .012 [ s ] Elapsed time ( example4: mat_vec, coarray ) : 0 .012 [ s ] API documentation The most up-to-date API documentation for the master branch is available here .\nTo generate the API documentation for ForMatmul using ford run the following\ncommand: ford ford.yml Contributing Contributions to ForMatmul are welcome!\nIf you find any issues or would like to suggest improvements, please open an issue. Developer Info Seyed Ali Ghasemi","tags":"home","loc":"index.html"},{"title":"mat_mat – ForMatmul","text":"private pure function mat_mat(A, B, method, option) result(C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) character(len=*), intent(in) :: method character(len=*), intent(in), optional :: option Return Value real(kind=rk), (size(A,1),size(B,2)) Calls proc~~mat_mat~~CallsGraph proc~mat_mat formatmul::mat_mat a_block a_block proc~mat_mat->a_block b_block b_block proc~mat_mat->b_block c_block c_block proc~mat_mat->c_block interface~matmul_blas formatmul::matmul_blas proc~mat_mat->interface~matmul_blas proc~gemm_mat_mat_rel formatmul::gemm_mat_mat_rel interface~matmul_blas->proc~gemm_mat_mat_rel proc~gemv_mat_vec_rel formatmul::gemv_mat_vec_rel interface~matmul_blas->proc~gemv_mat_vec_rel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~mat_mat~~CalledByGraph proc~mat_mat formatmul::mat_mat interface~matmul formatmul::matmul interface~matmul->proc~mat_mat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code mat_mat Source Code pure function mat_mat ( A , B , method , option ) result ( C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) character ( * ), intent ( in ) :: method character ( * ), intent ( in ), optional :: option ! real(rk), allocatable                :: C(:,:) real ( rk ) :: C ( size ( A , 1 ), size ( B , 2 )) if ( method == 'coarray' ) then if ( size ( A , 1 ) >= size ( B , 2 )) then block integer :: i , block_size , n , im , nimg real ( rk ), allocatable :: C_block (:,:)[:] integer :: m , o , remainder_m real ( rk ), allocatable :: A_block (:,:) im = this_image () nimg = num_images () m = size ( A , 1 ) o = size ( B , 2 ) n = size ( A , 2 ) block_size = m / nimg if ( mod ( m , nimg ) == 0 ) then if (. not . allocated ( C_block )) allocate ( C_block ( block_size , o )[ * ]) A_block = A (( im - 1 ) * block_size + 1 : im * block_size , :) else remainder_m = m - block_size * ( nimg - 1 ) if (. not . allocated ( C_block )) allocate ( C_block ( remainder_m , m )[ * ]) A_block = A (( im - 1 ) * block_size + 1 : im * block_size + remainder_m , :) end if select case ( option ) case ( 'matmul' ) C_block (:, :)[ im ] = matmul ( A_block , B ) case ( 'blas' ) C_block (:, :)[ im ] = matmul_blas ( A_block , B ) case default C_block (:, :)[ im ] = matmul ( A_block , B ) end select sync all ! critical if ( im == 1 ) then ! if (.not. allocated(C)) allocate(C(m, o)) do i = 1 , nimg - 1 C (( i - 1 ) * block_size + 1 : i * block_size , :) = C_block (:,:)[ i ] end do C (( nimg - 1 ) * block_size + 1 : m , :) = C_block (:,:)[ nimg ] end if ! end critical end block else block integer :: i , block_size , n , im , nimg real ( rk ), allocatable :: C_block (:,:)[:] integer :: m , o , remainder_m real ( rk ), allocatable :: B_block (:,:) im = this_image () nimg = num_images () m = size ( A , 1 ) o = size ( B , 2 ) n = size ( A , 2 ) block_size = o / nimg if ( mod ( o , nimg ) == 0 ) then if (. not . allocated ( C_block )) allocate ( C_block ( m , block_size )[ * ]) B_block = B (:, ( im - 1 ) * block_size + 1 : im * block_size ) else remainder_m = o - block_size * ( nimg - 1 ) if (. not . allocated ( C_block )) allocate ( C_block ( m , remainder_m )[ * ]) B_block = B (:, ( im - 1 ) * block_size + 1 : im * block_size + remainder_m ) end if select case ( option ) case ( 'matmul' ) C_block (:, :)[ im ] = matmul ( A , B_block ) case ( 'blas' ) C_block (:, :)[ im ] = matmul_blas ( A , B_block ) case default C_block (:, :)[ im ] = matmul ( A , B_block ) end select sync all ! critical if ( im == 1 ) then ! if (.not. allocated(C)) allocate(C(m, o)) do i = 1 , nimg - 1 C (:, ( i - 1 ) * block_size + 1 : i * block_size ) = C_block (:,:)[ i ] end do C (:, ( nimg - 1 ) * block_size + 1 : o ) = C_block (:,:)[ nimg ] end if ! end critical end block end if else error stop 'Error: The specified method is not available for matrix-matrix multiplication!' ! if (this_image() == 1) then !    ! if (.not. allocated(C)) allocate(C(m, o)) !    C = matmul(A, B) ! end if end if end function mat_mat","tags":"","loc":"proc/mat_mat.html"},{"title":"mat_vec – ForMatmul","text":"private pure function mat_vec(A, v, method, option) result(w) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) character(len=*), intent(in) :: method character(len=*), intent(in), optional :: option Return Value real(kind=rk), allocatable, (:) Calls proc~~mat_vec~~CallsGraph proc~mat_vec formatmul::mat_vec interface~matmul_blas formatmul::matmul_blas proc~mat_vec->interface~matmul_blas w_block w_block proc~mat_vec->w_block proc~gemm_mat_mat_rel formatmul::gemm_mat_mat_rel interface~matmul_blas->proc~gemm_mat_mat_rel proc~gemv_mat_vec_rel formatmul::gemv_mat_vec_rel interface~matmul_blas->proc~gemv_mat_vec_rel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~mat_vec~~CalledByGraph proc~mat_vec formatmul::mat_vec interface~matmul formatmul::matmul interface~matmul->proc~mat_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code mat_vec Source Code pure function mat_vec ( A , v , method , option ) result ( w ) real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) character ( * ), intent ( in ) :: method character ( * ), intent ( in ), optional :: option real ( rk ), allocatable :: w (:) if ( method == 'coarray' ) then block integer :: i , block_size , n , im , nimg real ( rk ), allocatable :: w_block (:)[:] integer :: m , remainder_m im = this_image () nimg = num_images () m = size ( A , 1 ) n = size ( A , 2 ) block_size = m / nimg remainder_m = m - block_size * ( nimg - 1 ) if ( mod ( m , nimg ) == 0 ) then if (. not . allocated ( w_block )) allocate ( w_block ( block_size )[ * ]) select case ( option ) case ( 'matmul' ) w_block (:) = matmul ( A (( im - 1 ) * block_size + 1 : im * block_size , 1 : n ), v ) case ( 'blas' ) w_block (:) = matmul_blas ( A (( im - 1 ) * block_size + 1 : im * block_size , 1 : n ), v ) case default w_block (:) = matmul ( A (( im - 1 ) * block_size + 1 : im * block_size , 1 : n ), v ) end select else if (. not . allocated ( w_block )) allocate ( w_block ( remainder_m )[ * ]) select case ( option ) case ( 'matmul' ) w_block (:) = matmul ( A (( im - 1 ) * block_size + 1 : im * block_size + remainder_m , 1 : n ), v ) case ( 'blas' ) w_block (:) = matmul_blas ( A (( im - 1 ) * block_size + 1 : im * block_size + remainder_m , 1 : n ), v ) case default w_block (:) = matmul ( A (( im - 1 ) * block_size + 1 : im * block_size + remainder_m , 1 : n ), v ) end select end if sync all ! critical if ( im == 1 ) then if (. not . allocated ( w )) allocate ( w ( m )) do i = 1 , nimg - 1 w (( i - 1 ) * block_size + 1 : i * block_size ) = w_block (:)[ i ] end do w (( nimg - 1 ) * block_size + 1 : m ) = w_block (:)[ nimg ] end if ! end critical end block else error stop 'Error: The specified method is not available for matrix-vector multiplication!' ! if (this_image() == 1) then !    ! if (.not. allocated(w)) allocate(w(m)) !    w = matmul(A, v) ! end if end if end function mat_vec","tags":"","loc":"proc/mat_vec.html"},{"title":"gemm_mat_mat_rel – ForMatmul","text":"private pure function gemm_mat_mat_rel(A, B) result(C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A real(kind=rk), intent(in), dimension(:, :), contiguous :: B Return Value real(kind=rk), dimension(size(A,1), size(B,2)) Called by proc~~gemm_mat_mat_rel~~CalledByGraph proc~gemm_mat_mat_rel formatmul::gemm_mat_mat_rel interface~matmul_blas formatmul::matmul_blas interface~matmul_blas->proc~gemm_mat_mat_rel proc~mat_mat formatmul::mat_mat proc~mat_mat->interface~matmul_blas proc~mat_vec formatmul::mat_vec proc~mat_vec->interface~matmul_blas program~example5 example5 program~example5->interface~matmul_blas program~example7 example7 program~example7->interface~matmul_blas interface~matmul formatmul::matmul interface~matmul->proc~mat_mat interface~matmul->proc~mat_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code gemm_mat_mat_rel Source Code pure function gemm_mat_mat_rel ( A , B ) result ( C ) real ( rk ), dimension (:, :), contiguous , intent ( in ) :: A real ( rk ), dimension (:, :), contiguous , intent ( in ) :: B real ( rk ), dimension ( size ( A , 1 ), size ( B , 2 )) :: C ! real(rk), dimension(:,:), allocatable             :: C integer :: m , n , k interface pure subroutine dgemm ( f_transa , f_transb , f_m , f_n , f_k , f_alpha , f_a , f_lda , f_b , f_ldb , f_beta , f_c , f_ldc ) import rk integer , intent ( in ) :: f_ldc integer , intent ( in ) :: f_ldb integer , intent ( in ) :: f_lda character , intent ( in ) :: f_transa character , intent ( in ) :: f_transb integer , intent ( in ) :: f_m integer , intent ( in ) :: f_n integer , intent ( in ) :: f_k real ( rk ), intent ( in ) :: f_alpha real ( rk ), intent ( in ) :: f_a ( f_lda , * ) real ( rk ), intent ( in ) :: f_b ( f_ldb , * ) real ( rk ), intent ( in ) :: f_beta real ( rk ), intent ( inout ) :: f_c ( f_ldc , * ) end subroutine dgemm end interface m = size ( A , 1 ) n = size ( B , 2 ) k = size ( A , 2 ) call dgemm ( 'N' , 'N' , m , n , k , 1.0_rk , A , m , B , k , 0.0_rk , C , m ) end function gemm_mat_mat_rel","tags":"","loc":"proc/gemm_mat_mat_rel.html"},{"title":"gemv_mat_vec_rel – ForMatmul","text":"private pure function gemv_mat_vec_rel(A, x) result(y) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A real(kind=rk), intent(in), dimension(:), contiguous :: x Return Value real(kind=rk), dimension(size(A,1)) Called by proc~~gemv_mat_vec_rel~~CalledByGraph proc~gemv_mat_vec_rel formatmul::gemv_mat_vec_rel interface~matmul_blas formatmul::matmul_blas interface~matmul_blas->proc~gemv_mat_vec_rel proc~mat_mat formatmul::mat_mat proc~mat_mat->interface~matmul_blas proc~mat_vec formatmul::mat_vec proc~mat_vec->interface~matmul_blas program~example5 example5 program~example5->interface~matmul_blas program~example7 example7 program~example7->interface~matmul_blas interface~matmul formatmul::matmul interface~matmul->proc~mat_mat interface~matmul->proc~mat_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code gemv_mat_vec_rel Source Code pure function gemv_mat_vec_rel ( A , x ) result ( y ) real ( rk ), dimension (:, :), contiguous , intent ( in ) :: A real ( rk ), dimension (:), contiguous , intent ( in ) :: x real ( rk ), dimension ( size ( A , 1 )) :: y ! real(rk), dimension(:), allocatable               :: y integer :: m , n interface pure subroutine dgemv ( f_trans , f_m , f_n , f_alpha , f_a , f_lda , f_x , f_incx , f_beta , f_y , f_incy ) import rk integer , intent ( in ) :: f_m integer , intent ( in ) :: f_n integer , intent ( in ) :: f_lda character , intent ( in ) :: f_trans real ( rk ), intent ( in ) :: f_alpha real ( rk ), intent ( in ) :: f_a ( f_lda , * ) real ( rk ), intent ( in ) :: f_x ( * ) integer , intent ( in ) :: f_incx real ( rk ), intent ( in ) :: f_beta real ( rk ), intent ( inout ) :: f_y ( * ) integer , intent ( in ) :: f_incy end subroutine dgemv end interface m = size ( A , 1 ) n = size ( A , 2 ) call dgemv ( 'N' , m , n , 1.0_rk , A , m , x , 1 , 0.0_rk , y , 1 ) !=============================================================================== end function gemv_mat_vec_rel","tags":"","loc":"proc/gemv_mat_vec_rel.html"},{"title":"matmul – ForMatmul","text":"public interface matmul Calls interface~~matmul~~CallsGraph interface~matmul formatmul::matmul proc~mat_mat formatmul::mat_mat interface~matmul->proc~mat_mat proc~mat_vec formatmul::mat_vec interface~matmul->proc~mat_vec a_block a_block proc~mat_mat->a_block b_block b_block proc~mat_mat->b_block c_block c_block proc~mat_mat->c_block interface~matmul_blas formatmul::matmul_blas proc~mat_mat->interface~matmul_blas proc~mat_vec->interface~matmul_blas w_block w_block proc~mat_vec->w_block proc~gemm_mat_mat_rel formatmul::gemm_mat_mat_rel interface~matmul_blas->proc~gemm_mat_mat_rel proc~gemv_mat_vec_rel formatmul::gemv_mat_vec_rel interface~matmul_blas->proc~gemv_mat_vec_rel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Module Procedures mat_mat mat_vec Module Procedures private pure function mat_mat (A, B, method, option) result(C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) character(len=*), intent(in) :: method character(len=*), intent(in), optional :: option Return Value real(kind=rk), (size(A,1),size(B,2)) private pure function mat_vec (A, v, method, option) result(w) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) character(len=*), intent(in) :: method character(len=*), intent(in), optional :: option Return Value real(kind=rk), allocatable, (:)","tags":"","loc":"interface/matmul.html"},{"title":"matmul_blas – ForMatmul","text":"public interface matmul_blas Calls interface~~matmul_blas~~CallsGraph interface~matmul_blas formatmul::matmul_blas proc~gemm_mat_mat_rel formatmul::gemm_mat_mat_rel interface~matmul_blas->proc~gemm_mat_mat_rel proc~gemv_mat_vec_rel formatmul::gemv_mat_vec_rel interface~matmul_blas->proc~gemv_mat_vec_rel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~matmul_blas~~CalledByGraph interface~matmul_blas formatmul::matmul_blas proc~mat_mat formatmul::mat_mat proc~mat_mat->interface~matmul_blas proc~mat_vec formatmul::mat_vec proc~mat_vec->interface~matmul_blas program~example5 example5 program~example5->interface~matmul_blas program~example7 example7 program~example7->interface~matmul_blas interface~matmul formatmul::matmul interface~matmul->proc~mat_mat interface~matmul->proc~mat_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Module Procedures gemm_mat_mat_rel gemv_mat_vec_rel Module Procedures private pure function gemm_mat_mat_rel (A, B) result(C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A real(kind=rk), intent(in), dimension(:, :), contiguous :: B Return Value real(kind=rk), dimension(size(A,1), size(B,2)) private pure function gemv_mat_vec_rel (A, x) result(y) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A real(kind=rk), intent(in), dimension(:), contiguous :: x Return Value real(kind=rk), dimension(size(A,1))","tags":"","loc":"interface/matmul_blas.html"},{"title":"formatmul – ForMatmul","text":"Uses kinds module~~formatmul~~UsesGraph module~formatmul formatmul kinds kinds module~formatmul->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~formatmul~~UsedByGraph module~formatmul formatmul program~example1 example1 program~example1->module~formatmul program~example2 example2 program~example2->module~formatmul program~example3 example3 program~example3->module~formatmul program~example4 example4 program~example4->module~formatmul program~example5 example5 program~example5->module~formatmul program~example6 example6 program~example6->module~formatmul program~example7 example7 program~example7->module~formatmul program~example8 example8 program~example8->module~formatmul program~mat_mat mat_mat program~mat_mat->module~formatmul program~mat_vec mat_vec program~mat_vec->module~formatmul Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Interfaces matmul matmul_blas Functions mat_mat mat_vec gemm_mat_mat_rel gemv_mat_vec_rel Interfaces public        interface matmul private pure function mat_mat (A, B, method, option) result(C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) character(len=*), intent(in) :: method character(len=*), intent(in), optional :: option Return Value real(kind=rk), (size(A,1),size(B,2)) private pure function mat_vec (A, v, method, option) result(w) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) character(len=*), intent(in) :: method character(len=*), intent(in), optional :: option Return Value real(kind=rk), allocatable, (:) public        interface matmul_blas private pure function gemm_mat_mat_rel (A, B) result(C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A real(kind=rk), intent(in), dimension(:, :), contiguous :: B Return Value real(kind=rk), dimension(size(A,1), size(B,2)) private pure function gemv_mat_vec_rel (A, x) result(y) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A real(kind=rk), intent(in), dimension(:), contiguous :: x Return Value real(kind=rk), dimension(size(A,1)) Functions private pure function mat_mat (A, B, method, option) result(C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) character(len=*), intent(in) :: method character(len=*), intent(in), optional :: option Return Value real(kind=rk), (size(A,1),size(B,2)) private pure function mat_vec (A, v, method, option) result(w) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) character(len=*), intent(in) :: method character(len=*), intent(in), optional :: option Return Value real(kind=rk), allocatable, (:) private pure function gemm_mat_mat_rel (A, B) result(C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A real(kind=rk), intent(in), dimension(:, :), contiguous :: B Return Value real(kind=rk), dimension(size(A,1), size(B,2)) private pure function gemv_mat_vec_rel (A, x) result(y) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A real(kind=rk), intent(in), dimension(:), contiguous :: x Return Value real(kind=rk), dimension(size(A,1))","tags":"","loc":"module/formatmul.html"},{"title":"mat_mat – ForMatmul","text":"Uses formatmul kinds fortime program~~mat_mat~~UsesGraph program~mat_mat mat_mat fortime fortime program~mat_mat->fortime kinds kinds program~mat_mat->kinds module~formatmul formatmul program~mat_mat->module~formatmul module~formatmul->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables A B C C_co t m n o Source Code mat_mat Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:,:) real(kind=rk), allocatable :: B (:,:) real(kind=rk), allocatable :: C (:,:) real(kind=rk), allocatable :: C_co (:,:) type(timer) :: t integer :: m integer :: n integer :: o Source Code program mat_mat use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C (:,:), C_co (:,:) type ( timer ) :: t integer :: m , n , o ! C(m,o) = A(m,n).B(n,o) m = 200 n = 100 o = 10 allocate ( A ( m , n ), B ( n , o )) call random_number ( A ) call random_number ( B ) sync all C = matmul ( A , B ) sync all C_co = matmul ( A , B , 'coarray' ) sync all if ( this_image () == 1 ) print * , 'relative error:' , norm2 ( C - C_co ) / norm2 ( C ) end program mat_mat","tags":"","loc":"program/mat_mat.html"},{"title":"mat_vec – ForMatmul","text":"Uses formatmul kinds fortime program~~mat_vec~~UsesGraph program~mat_vec mat_vec fortime fortime program~mat_vec->fortime kinds kinds program~mat_vec->kinds module~formatmul formatmul program~mat_vec->module~formatmul module~formatmul->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables A v w w_co t m n Source Code mat_vec Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:,:) real(kind=rk), allocatable :: v (:) real(kind=rk), allocatable :: w (:) real(kind=rk), allocatable :: w_co (:) type(timer) :: t integer :: m integer :: n Source Code program mat_vec use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), v (:) real ( rk ), allocatable :: w (:), w_co (:) type ( timer ) :: t integer :: m , n ! w(m) = A(m,n).v(n) m = 200 n = 100 allocate ( A ( m , n ), v ( n )) call random_number ( A ) call random_number ( v ) w = matmul ( A , v ) sync all w_co = matmul ( A , v , 'coarray' ) sync all if ( this_image () == 1 ) print * , 'relative error:' , norm2 ( w - w_co ) / norm2 ( w ) end program mat_vec","tags":"","loc":"program/mat_vec.html"},{"title":"example8 – ForMatmul","text":"Uses formatmul kinds fortime program~~example8~~UsesGraph program~example8 example8 fortime fortime program~example8->fortime kinds kinds program~example8->kinds module~formatmul formatmul program~example8->module~formatmul module~formatmul->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables A v w t m n Source Code example8 Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:,:) real(kind=rk), allocatable :: v (:) real(kind=rk), allocatable :: w (:) type(timer) :: t integer :: m integer :: n Source Code program example8 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), v (:) real ( rk ), allocatable :: w (:) type ( timer ) :: t integer :: m , n ! w(m) = A(m,n).v(n) m = 64 * 2 * 100 n = 16 * 2 * 100 allocate ( A ( m , n ), v ( n )) call random_number ( A ) call random_number ( v ) sync all call t % timer_start () w = matmul ( A , v , 'coarray' , option = 'blas' ) call t % timer_stop ( message = ' Elapsed time (example8: mat_vec, coarray with blas):' ) end program example8","tags":"","loc":"program/example8.html"},{"title":"example3 – ForMatmul","text":"Uses formatmul kinds fortime program~~example3~~UsesGraph program~example3 example3 fortime fortime program~example3->fortime kinds kinds program~example3->kinds module~formatmul formatmul program~example3->module~formatmul module~formatmul->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables A v w t m n Source Code example3 Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:,:) real(kind=rk), allocatable :: v (:) real(kind=rk), allocatable :: w (:) type(timer) :: t integer :: m integer :: n Source Code program example3 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), v (:) real ( rk ), allocatable :: w (:) type ( timer ) :: t integer :: m , n ! w(m) = A(m,n).v(n) m = 64 * 2 * 100 n = 16 * 2 * 100 allocate ( A ( m , n ), v ( n )) call random_number ( A ) call random_number ( v ) sync all if ( this_image () == 1 ) call t % timer_start () w = matmul ( A , v ) if ( this_image () == 1 ) call t % timer_stop ( message = ' Elapsed time (example3: mat_vec):' ) end program example3","tags":"","loc":"program/example3.html"},{"title":"example5 – ForMatmul","text":"Uses formatmul kinds fortime program~~example5~~UsesGraph program~example5 example5 fortime fortime program~example5->fortime kinds kinds program~example5->kinds module~formatmul formatmul program~example5->module~formatmul module~formatmul->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~example5~~CallsGraph program~example5 example5 interface~matmul_blas formatmul::matmul_blas program~example5->interface~matmul_blas proc~gemm_mat_mat_rel formatmul::gemm_mat_mat_rel interface~matmul_blas->proc~gemm_mat_mat_rel proc~gemv_mat_vec_rel formatmul::gemv_mat_vec_rel interface~matmul_blas->proc~gemv_mat_vec_rel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables A B C t m n o Source Code example5 Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:,:) real(kind=rk), allocatable :: B (:,:) real(kind=rk), allocatable :: C (:,:) type(timer) :: t integer :: m integer :: n integer :: o Source Code program example5 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul_blas implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C (:,:) type ( timer ) :: t integer :: m , n , o ! C(m,o) = A(m,n).B(n,o) m = 64 * 2 * 100 n = 16 * 100 o = 64 * 10 allocate ( A ( m , n ), B ( n , o )) call random_number ( A ) call random_number ( B ) sync all if ( this_image () == 1 ) call t % timer_start () C = matmul_blas ( A , B ) if ( this_image () == 1 ) call t % timer_stop ( message = ' Elapsed time (example5: mat_mat with blas):' ) end program example5","tags":"","loc":"program/example5.html"},{"title":"example7 – ForMatmul","text":"Uses formatmul kinds fortime program~~example7~~UsesGraph program~example7 example7 fortime fortime program~example7->fortime kinds kinds program~example7->kinds module~formatmul formatmul program~example7->module~formatmul module~formatmul->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~example7~~CallsGraph program~example7 example7 interface~matmul_blas formatmul::matmul_blas program~example7->interface~matmul_blas proc~gemm_mat_mat_rel formatmul::gemm_mat_mat_rel interface~matmul_blas->proc~gemm_mat_mat_rel proc~gemv_mat_vec_rel formatmul::gemv_mat_vec_rel interface~matmul_blas->proc~gemv_mat_vec_rel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables A v w t m n Source Code example7 Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:,:) real(kind=rk), allocatable :: v (:) real(kind=rk), allocatable :: w (:) type(timer) :: t integer :: m integer :: n Source Code program example7 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul_blas implicit none real ( rk ), allocatable :: A (:,:), v (:) real ( rk ), allocatable :: w (:) type ( timer ) :: t integer :: m , n ! w(m) = A(m,n).v(n) m = 64 * 2 * 100 n = 16 * 2 * 100 allocate ( A ( m , n ), v ( n )) call random_number ( A ) call random_number ( v ) sync all if ( this_image () == 1 ) call t % timer_start () w = matmul_blas ( A , v ) if ( this_image () == 1 ) call t % timer_stop ( message = ' Elapsed time (example7: mat_vec with blas):' ) end program example7","tags":"","loc":"program/example7.html"},{"title":"example2 – ForMatmul","text":"Uses formatmul kinds fortime program~~example2~~UsesGraph program~example2 example2 fortime fortime program~example2->fortime kinds kinds program~example2->kinds module~formatmul formatmul program~example2->module~formatmul module~formatmul->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables A B C t m n o Source Code example2 Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:,:) real(kind=rk), allocatable :: B (:,:) real(kind=rk), allocatable :: C (:,:) type(timer) :: t integer :: m integer :: n integer :: o Source Code program example2 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C (:,:) type ( timer ) :: t integer :: m , n , o ! C(m,o) = A(m,n).B(n,o) m = 64 * 2 * 100 n = 16 * 100 o = 64 * 10 allocate ( A ( m , n ), B ( n , o )) call random_number ( A ) call random_number ( B ) sync all call t % timer_start () C = matmul ( A , B , 'coarray' ) call t % timer_stop ( message = ' Elapsed time (example2: mat_mat, coarray):' ) end program example2","tags":"","loc":"program/example2.html"},{"title":"example4 – ForMatmul","text":"Uses formatmul kinds fortime program~~example4~~UsesGraph program~example4 example4 fortime fortime program~example4->fortime kinds kinds program~example4->kinds module~formatmul formatmul program~example4->module~formatmul module~formatmul->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables A v w t m n Source Code example4 Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:,:) real(kind=rk), allocatable :: v (:) real(kind=rk), allocatable :: w (:) type(timer) :: t integer :: m integer :: n Source Code program example4 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), v (:) real ( rk ), allocatable :: w (:) type ( timer ) :: t integer :: m , n ! w(m) = A(m,n).v(n) m = 64 * 2 * 100 n = 16 * 2 * 100 allocate ( A ( m , n ), v ( n )) call random_number ( A ) call random_number ( v ) sync all call t % timer_start () w = matmul ( A , v , 'coarray' ) call t % timer_stop ( message = ' Elapsed time (example4: mat_vec, coarray):' ) end program example4","tags":"","loc":"program/example4.html"},{"title":"example6 – ForMatmul","text":"Uses formatmul kinds fortime program~~example6~~UsesGraph program~example6 example6 fortime fortime program~example6->fortime kinds kinds program~example6->kinds module~formatmul formatmul program~example6->module~formatmul module~formatmul->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables A B C t m n o Source Code example6 Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:,:) real(kind=rk), allocatable :: B (:,:) real(kind=rk), allocatable :: C (:,:) type(timer) :: t integer :: m integer :: n integer :: o Source Code program example6 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C (:,:) type ( timer ) :: t integer :: m , n , o ! C(m,o) = A(m,n).B(n,o) m = 64 * 2 * 100 n = 16 * 100 o = 64 * 10 allocate ( A ( m , n ), B ( n , o )) call random_number ( A ) call random_number ( B ) sync all call t % timer_start () C = matmul ( A , B , 'coarray' , option = 'blas' ) call t % timer_stop ( message = ' Elapsed time (example6: mat_mat, coarray with blas):' ) end program example6","tags":"","loc":"program/example6.html"},{"title":"example1 – ForMatmul","text":"Uses formatmul kinds fortime program~~example1~~UsesGraph program~example1 example1 fortime fortime program~example1->fortime kinds kinds program~example1->kinds module~formatmul formatmul program~example1->module~formatmul module~formatmul->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables A B C t m n o Source Code example1 Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:,:) real(kind=rk), allocatable :: B (:,:) real(kind=rk), allocatable :: C (:,:) type(timer) :: t integer :: m integer :: n integer :: o Source Code program example1 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C (:,:) type ( timer ) :: t integer :: m , n , o ! C(m,o) = A(m,n).B(n,o) m = 64 * 2 * 100 n = 16 * 100 o = 64 * 10 allocate ( A ( m , n ), B ( n , o )) call random_number ( A ) call random_number ( B ) sync all if ( this_image () == 1 ) call t % timer_start () C = matmul ( A , B ) if ( this_image () == 1 ) call t % timer_stop ( message = ' Elapsed time (example1: mat_mat):' ) end program example1","tags":"","loc":"program/example1.html"},{"title":"formatmul.f90 – ForMatmul","text":"Files dependent on this one sourcefile~~formatmul.f90~~AfferentGraph sourcefile~formatmul.f90 formatmul.f90 sourcefile~example1.f90 example1.f90 sourcefile~example1.f90->sourcefile~formatmul.f90 sourcefile~example2.f90 example2.f90 sourcefile~example2.f90->sourcefile~formatmul.f90 sourcefile~example3.f90 example3.f90 sourcefile~example3.f90->sourcefile~formatmul.f90 sourcefile~example4.f90 example4.f90 sourcefile~example4.f90->sourcefile~formatmul.f90 sourcefile~example5.f90 example5.f90 sourcefile~example5.f90->sourcefile~formatmul.f90 sourcefile~example6.f90 example6.f90 sourcefile~example6.f90->sourcefile~formatmul.f90 sourcefile~example7.f90 example7.f90 sourcefile~example7.f90->sourcefile~formatmul.f90 sourcefile~example8.f90 example8.f90 sourcefile~example8.f90->sourcefile~formatmul.f90 sourcefile~test1.f90 test1.f90 sourcefile~test1.f90->sourcefile~formatmul.f90 sourcefile~test2.f90 test2.f90 sourcefile~test2.f90->sourcefile~formatmul.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Modules formatmul Source Code formatmul.f90 Source Code module formatmul use kinds implicit none private public matmul , matmul_blas !=============================================================================== interface matmul procedure :: mat_mat procedure :: mat_vec end interface !=============================================================================== !=============================================================================== interface matmul_blas procedure :: gemm_mat_mat_rel procedure :: gemv_mat_vec_rel end interface !=============================================================================== contains !=============================================================================== !> author: Seyed Ali Ghasemi pure function mat_mat ( A , B , method , option ) result ( C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) character ( * ), intent ( in ) :: method character ( * ), intent ( in ), optional :: option ! real(rk), allocatable                :: C(:,:) real ( rk ) :: C ( size ( A , 1 ), size ( B , 2 )) if ( method == 'coarray' ) then if ( size ( A , 1 ) >= size ( B , 2 )) then block integer :: i , block_size , n , im , nimg real ( rk ), allocatable :: C_block (:,:)[:] integer :: m , o , remainder_m real ( rk ), allocatable :: A_block (:,:) im = this_image () nimg = num_images () m = size ( A , 1 ) o = size ( B , 2 ) n = size ( A , 2 ) block_size = m / nimg if ( mod ( m , nimg ) == 0 ) then if (. not . allocated ( C_block )) allocate ( C_block ( block_size , o )[ * ]) A_block = A (( im - 1 ) * block_size + 1 : im * block_size , :) else remainder_m = m - block_size * ( nimg - 1 ) if (. not . allocated ( C_block )) allocate ( C_block ( remainder_m , m )[ * ]) A_block = A (( im - 1 ) * block_size + 1 : im * block_size + remainder_m , :) end if select case ( option ) case ( 'matmul' ) C_block (:, :)[ im ] = matmul ( A_block , B ) case ( 'blas' ) C_block (:, :)[ im ] = matmul_blas ( A_block , B ) case default C_block (:, :)[ im ] = matmul ( A_block , B ) end select sync all ! critical if ( im == 1 ) then ! if (.not. allocated(C)) allocate(C(m, o)) do i = 1 , nimg - 1 C (( i - 1 ) * block_size + 1 : i * block_size , :) = C_block (:,:)[ i ] end do C (( nimg - 1 ) * block_size + 1 : m , :) = C_block (:,:)[ nimg ] end if ! end critical end block else block integer :: i , block_size , n , im , nimg real ( rk ), allocatable :: C_block (:,:)[:] integer :: m , o , remainder_m real ( rk ), allocatable :: B_block (:,:) im = this_image () nimg = num_images () m = size ( A , 1 ) o = size ( B , 2 ) n = size ( A , 2 ) block_size = o / nimg if ( mod ( o , nimg ) == 0 ) then if (. not . allocated ( C_block )) allocate ( C_block ( m , block_size )[ * ]) B_block = B (:, ( im - 1 ) * block_size + 1 : im * block_size ) else remainder_m = o - block_size * ( nimg - 1 ) if (. not . allocated ( C_block )) allocate ( C_block ( m , remainder_m )[ * ]) B_block = B (:, ( im - 1 ) * block_size + 1 : im * block_size + remainder_m ) end if select case ( option ) case ( 'matmul' ) C_block (:, :)[ im ] = matmul ( A , B_block ) case ( 'blas' ) C_block (:, :)[ im ] = matmul_blas ( A , B_block ) case default C_block (:, :)[ im ] = matmul ( A , B_block ) end select sync all ! critical if ( im == 1 ) then ! if (.not. allocated(C)) allocate(C(m, o)) do i = 1 , nimg - 1 C (:, ( i - 1 ) * block_size + 1 : i * block_size ) = C_block (:,:)[ i ] end do C (:, ( nimg - 1 ) * block_size + 1 : o ) = C_block (:,:)[ nimg ] end if ! end critical end block end if else error stop 'Error: The specified method is not available for matrix-matrix multiplication!' ! if (this_image() == 1) then !    ! if (.not. allocated(C)) allocate(C(m, o)) !    C = matmul(A, B) ! end if end if end function mat_mat !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure function mat_vec ( A , v , method , option ) result ( w ) real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) character ( * ), intent ( in ) :: method character ( * ), intent ( in ), optional :: option real ( rk ), allocatable :: w (:) if ( method == 'coarray' ) then block integer :: i , block_size , n , im , nimg real ( rk ), allocatable :: w_block (:)[:] integer :: m , remainder_m im = this_image () nimg = num_images () m = size ( A , 1 ) n = size ( A , 2 ) block_size = m / nimg remainder_m = m - block_size * ( nimg - 1 ) if ( mod ( m , nimg ) == 0 ) then if (. not . allocated ( w_block )) allocate ( w_block ( block_size )[ * ]) select case ( option ) case ( 'matmul' ) w_block (:) = matmul ( A (( im - 1 ) * block_size + 1 : im * block_size , 1 : n ), v ) case ( 'blas' ) w_block (:) = matmul_blas ( A (( im - 1 ) * block_size + 1 : im * block_size , 1 : n ), v ) case default w_block (:) = matmul ( A (( im - 1 ) * block_size + 1 : im * block_size , 1 : n ), v ) end select else if (. not . allocated ( w_block )) allocate ( w_block ( remainder_m )[ * ]) select case ( option ) case ( 'matmul' ) w_block (:) = matmul ( A (( im - 1 ) * block_size + 1 : im * block_size + remainder_m , 1 : n ), v ) case ( 'blas' ) w_block (:) = matmul_blas ( A (( im - 1 ) * block_size + 1 : im * block_size + remainder_m , 1 : n ), v ) case default w_block (:) = matmul ( A (( im - 1 ) * block_size + 1 : im * block_size + remainder_m , 1 : n ), v ) end select end if sync all ! critical if ( im == 1 ) then if (. not . allocated ( w )) allocate ( w ( m )) do i = 1 , nimg - 1 w (( i - 1 ) * block_size + 1 : i * block_size ) = w_block (:)[ i ] end do w (( nimg - 1 ) * block_size + 1 : m ) = w_block (:)[ nimg ] end if ! end critical end block else error stop 'Error: The specified method is not available for matrix-vector multiplication!' ! if (this_image() == 1) then !    ! if (.not. allocated(w)) allocate(w(m)) !    w = matmul(A, v) ! end if end if end function mat_vec !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure function gemm_mat_mat_rel ( A , B ) result ( C ) real ( rk ), dimension (:, :), contiguous , intent ( in ) :: A real ( rk ), dimension (:, :), contiguous , intent ( in ) :: B real ( rk ), dimension ( size ( A , 1 ), size ( B , 2 )) :: C ! real(rk), dimension(:,:), allocatable             :: C integer :: m , n , k interface pure subroutine dgemm ( f_transa , f_transb , f_m , f_n , f_k , f_alpha , f_a , f_lda , f_b , f_ldb , f_beta , f_c , f_ldc ) import rk integer , intent ( in ) :: f_ldc integer , intent ( in ) :: f_ldb integer , intent ( in ) :: f_lda character , intent ( in ) :: f_transa character , intent ( in ) :: f_transb integer , intent ( in ) :: f_m integer , intent ( in ) :: f_n integer , intent ( in ) :: f_k real ( rk ), intent ( in ) :: f_alpha real ( rk ), intent ( in ) :: f_a ( f_lda , * ) real ( rk ), intent ( in ) :: f_b ( f_ldb , * ) real ( rk ), intent ( in ) :: f_beta real ( rk ), intent ( inout ) :: f_c ( f_ldc , * ) end subroutine dgemm end interface m = size ( A , 1 ) n = size ( B , 2 ) k = size ( A , 2 ) call dgemm ( 'N' , 'N' , m , n , k , 1.0_rk , A , m , B , k , 0.0_rk , C , m ) end function gemm_mat_mat_rel !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure function gemv_mat_vec_rel ( A , x ) result ( y ) real ( rk ), dimension (:, :), contiguous , intent ( in ) :: A real ( rk ), dimension (:), contiguous , intent ( in ) :: x real ( rk ), dimension ( size ( A , 1 )) :: y ! real(rk), dimension(:), allocatable               :: y integer :: m , n interface pure subroutine dgemv ( f_trans , f_m , f_n , f_alpha , f_a , f_lda , f_x , f_incx , f_beta , f_y , f_incy ) import rk integer , intent ( in ) :: f_m integer , intent ( in ) :: f_n integer , intent ( in ) :: f_lda character , intent ( in ) :: f_trans real ( rk ), intent ( in ) :: f_alpha real ( rk ), intent ( in ) :: f_a ( f_lda , * ) real ( rk ), intent ( in ) :: f_x ( * ) integer , intent ( in ) :: f_incx real ( rk ), intent ( in ) :: f_beta real ( rk ), intent ( inout ) :: f_y ( * ) integer , intent ( in ) :: f_incy end subroutine dgemv end interface m = size ( A , 1 ) n = size ( A , 2 ) call dgemv ( 'N' , m , n , 1.0_rk , A , m , x , 1 , 0.0_rk , y , 1 ) !=============================================================================== end function gemv_mat_vec_rel end module formatmul","tags":"","loc":"sourcefile/formatmul.f90.html"},{"title":"test1.f90 – ForMatmul","text":"This file depends on sourcefile~~test1.f90~~EfferentGraph sourcefile~test1.f90 test1.f90 sourcefile~formatmul.f90 formatmul.f90 sourcefile~test1.f90->sourcefile~formatmul.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Programs mat_mat Source Code test1.f90 Source Code program mat_mat use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C (:,:), C_co (:,:) type ( timer ) :: t integer :: m , n , o ! C(m,o) = A(m,n).B(n,o) m = 200 n = 100 o = 10 allocate ( A ( m , n ), B ( n , o )) call random_number ( A ) call random_number ( B ) sync all C = matmul ( A , B ) sync all C_co = matmul ( A , B , 'coarray' ) sync all if ( this_image () == 1 ) print * , 'relative error:' , norm2 ( C - C_co ) / norm2 ( C ) end program mat_mat","tags":"","loc":"sourcefile/test1.f90.html"},{"title":"test2.f90 – ForMatmul","text":"This file depends on sourcefile~~test2.f90~~EfferentGraph sourcefile~test2.f90 test2.f90 sourcefile~formatmul.f90 formatmul.f90 sourcefile~test2.f90->sourcefile~formatmul.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Programs mat_vec Source Code test2.f90 Source Code program mat_vec use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), v (:) real ( rk ), allocatable :: w (:), w_co (:) type ( timer ) :: t integer :: m , n ! w(m) = A(m,n).v(n) m = 200 n = 100 allocate ( A ( m , n ), v ( n )) call random_number ( A ) call random_number ( v ) w = matmul ( A , v ) sync all w_co = matmul ( A , v , 'coarray' ) sync all if ( this_image () == 1 ) print * , 'relative error:' , norm2 ( w - w_co ) / norm2 ( w ) end program mat_vec","tags":"","loc":"sourcefile/test2.f90.html"},{"title":"example8.f90 – ForMatmul","text":"This file depends on sourcefile~~example8.f90~~EfferentGraph sourcefile~example8.f90 example8.f90 sourcefile~formatmul.f90 formatmul.f90 sourcefile~example8.f90->sourcefile~formatmul.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Programs example8 Source Code example8.f90 Source Code program example8 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), v (:) real ( rk ), allocatable :: w (:) type ( timer ) :: t integer :: m , n ! w(m) = A(m,n).v(n) m = 64 * 2 * 100 n = 16 * 2 * 100 allocate ( A ( m , n ), v ( n )) call random_number ( A ) call random_number ( v ) sync all call t % timer_start () w = matmul ( A , v , 'coarray' , option = 'blas' ) call t % timer_stop ( message = ' Elapsed time (example8: mat_vec, coarray with blas):' ) end program example8","tags":"","loc":"sourcefile/example8.f90.html"},{"title":"example3.f90 – ForMatmul","text":"This file depends on sourcefile~~example3.f90~~EfferentGraph sourcefile~example3.f90 example3.f90 sourcefile~formatmul.f90 formatmul.f90 sourcefile~example3.f90->sourcefile~formatmul.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Programs example3 Source Code example3.f90 Source Code program example3 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), v (:) real ( rk ), allocatable :: w (:) type ( timer ) :: t integer :: m , n ! w(m) = A(m,n).v(n) m = 64 * 2 * 100 n = 16 * 2 * 100 allocate ( A ( m , n ), v ( n )) call random_number ( A ) call random_number ( v ) sync all if ( this_image () == 1 ) call t % timer_start () w = matmul ( A , v ) if ( this_image () == 1 ) call t % timer_stop ( message = ' Elapsed time (example3: mat_vec):' ) end program example3","tags":"","loc":"sourcefile/example3.f90.html"},{"title":"example5.f90 – ForMatmul","text":"This file depends on sourcefile~~example5.f90~~EfferentGraph sourcefile~example5.f90 example5.f90 sourcefile~formatmul.f90 formatmul.f90 sourcefile~example5.f90->sourcefile~formatmul.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Programs example5 Source Code example5.f90 Source Code program example5 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul_blas implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C (:,:) type ( timer ) :: t integer :: m , n , o ! C(m,o) = A(m,n).B(n,o) m = 64 * 2 * 100 n = 16 * 100 o = 64 * 10 allocate ( A ( m , n ), B ( n , o )) call random_number ( A ) call random_number ( B ) sync all if ( this_image () == 1 ) call t % timer_start () C = matmul_blas ( A , B ) if ( this_image () == 1 ) call t % timer_stop ( message = ' Elapsed time (example5: mat_mat with blas):' ) end program example5","tags":"","loc":"sourcefile/example5.f90.html"},{"title":"example7.f90 – ForMatmul","text":"This file depends on sourcefile~~example7.f90~~EfferentGraph sourcefile~example7.f90 example7.f90 sourcefile~formatmul.f90 formatmul.f90 sourcefile~example7.f90->sourcefile~formatmul.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Programs example7 Source Code example7.f90 Source Code program example7 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul_blas implicit none real ( rk ), allocatable :: A (:,:), v (:) real ( rk ), allocatable :: w (:) type ( timer ) :: t integer :: m , n ! w(m) = A(m,n).v(n) m = 64 * 2 * 100 n = 16 * 2 * 100 allocate ( A ( m , n ), v ( n )) call random_number ( A ) call random_number ( v ) sync all if ( this_image () == 1 ) call t % timer_start () w = matmul_blas ( A , v ) if ( this_image () == 1 ) call t % timer_stop ( message = ' Elapsed time (example7: mat_vec with blas):' ) end program example7","tags":"","loc":"sourcefile/example7.f90.html"},{"title":"example2.f90 – ForMatmul","text":"This file depends on sourcefile~~example2.f90~~EfferentGraph sourcefile~example2.f90 example2.f90 sourcefile~formatmul.f90 formatmul.f90 sourcefile~example2.f90->sourcefile~formatmul.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Programs example2 Source Code example2.f90 Source Code program example2 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C (:,:) type ( timer ) :: t integer :: m , n , o ! C(m,o) = A(m,n).B(n,o) m = 64 * 2 * 100 n = 16 * 100 o = 64 * 10 allocate ( A ( m , n ), B ( n , o )) call random_number ( A ) call random_number ( B ) sync all call t % timer_start () C = matmul ( A , B , 'coarray' ) call t % timer_stop ( message = ' Elapsed time (example2: mat_mat, coarray):' ) end program example2","tags":"","loc":"sourcefile/example2.f90.html"},{"title":"example4.f90 – ForMatmul","text":"This file depends on sourcefile~~example4.f90~~EfferentGraph sourcefile~example4.f90 example4.f90 sourcefile~formatmul.f90 formatmul.f90 sourcefile~example4.f90->sourcefile~formatmul.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Programs example4 Source Code example4.f90 Source Code program example4 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), v (:) real ( rk ), allocatable :: w (:) type ( timer ) :: t integer :: m , n ! w(m) = A(m,n).v(n) m = 64 * 2 * 100 n = 16 * 2 * 100 allocate ( A ( m , n ), v ( n )) call random_number ( A ) call random_number ( v ) sync all call t % timer_start () w = matmul ( A , v , 'coarray' ) call t % timer_stop ( message = ' Elapsed time (example4: mat_vec, coarray):' ) end program example4","tags":"","loc":"sourcefile/example4.f90.html"},{"title":"example6.f90 – ForMatmul","text":"This file depends on sourcefile~~example6.f90~~EfferentGraph sourcefile~example6.f90 example6.f90 sourcefile~formatmul.f90 formatmul.f90 sourcefile~example6.f90->sourcefile~formatmul.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Programs example6 Source Code example6.f90 Source Code program example6 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C (:,:) type ( timer ) :: t integer :: m , n , o ! C(m,o) = A(m,n).B(n,o) m = 64 * 2 * 100 n = 16 * 100 o = 64 * 10 allocate ( A ( m , n ), B ( n , o )) call random_number ( A ) call random_number ( B ) sync all call t % timer_start () C = matmul ( A , B , 'coarray' , option = 'blas' ) call t % timer_stop ( message = ' Elapsed time (example6: mat_mat, coarray with blas):' ) end program example6","tags":"","loc":"sourcefile/example6.f90.html"},{"title":"example1.f90 – ForMatmul","text":"This file depends on sourcefile~~example1.f90~~EfferentGraph sourcefile~example1.f90 example1.f90 sourcefile~formatmul.f90 formatmul.f90 sourcefile~example1.f90->sourcefile~formatmul.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Programs example1 Source Code example1.f90 Source Code program example1 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C (:,:) type ( timer ) :: t integer :: m , n , o ! C(m,o) = A(m,n).B(n,o) m = 64 * 2 * 100 n = 16 * 100 o = 64 * 10 allocate ( A ( m , n ), B ( n , o )) call random_number ( A ) call random_number ( B ) sync all if ( this_image () == 1 ) call t % timer_start () C = matmul ( A , B ) if ( this_image () == 1 ) call t % timer_stop ( message = ' Elapsed time (example1: mat_mat):' ) end program example1","tags":"","loc":"sourcefile/example1.f90.html"}]}