var tipuesearch = {"pages":[{"title":" ForMatmul ","text":"ForMatmul ForMatmul : A Fortran library that overloads the matmul function to enable efficient matrix multiplication with coarray. Usage use formatmul c = matmul ( a , b , method = 'coarray' ) fpm dependency If you want to use ForMatmul as a dependency in your own fpm project,\nyou can easily include it by adding the following line to your fpm.toml file: [dependencies] formatmul = { git = \"https://github.com/gha3mi/formatmul.git\" } How to run tests and examples Clone the repository: You can clone the ForMatmul repository from GitHub using the following command: git clone https://github.com/gha3mi/formatmul.git cd formatmul Run tests: Tested with Intel compiler: ifort (IFORT) 2021.10.0 20230609 fpm @ifort-test Tested with Intel compiler: ifx (IFX) 2023.2.0 20230622 fpm @ifx-test Run examples: To set the stack size to unlimited, use the following command: ulimit -s unlimited . You have the option to modify the number of images in the fpm.rsp file by using the flag -coarray-num-images=N . fpm @ifort-example fpm @ifx-example Results with -coarray-num-images=4 : Elapsed time ( example1: mat_mat ) : 1 .175 [ s ] Elapsed time ( example2: mat_mat, coarray ) : 0 .269 [ s ] Elapsed time ( example2: mat_mat, coarray ) : 0 .272 [ s ] Elapsed time ( example2: mat_mat, coarray ) : 0 .274 [ s ] Elapsed time ( example2: mat_mat, coarray ) : 0 .275 [ s ] Elapsed time ( example3: mat_vec ) : 0 .047 [ s ] Elapsed time ( example4: mat_vec, coarray ) : 0 .012 [ s ] Elapsed time ( example4: mat_vec, coarray ) : 0 .012 [ s ] Elapsed time ( example4: mat_vec, coarray ) : 0 .012 [ s ] Elapsed time ( example4: mat_vec, coarray ) : 0 .012 [ s ] Benchmark: To set the stack size to unlimited, use the following command: ulimit -s unlimited . fpm run --example benchmark3 --compiler ifort --flag \"-Ofast -xHost -qopenmp -qmkl -coarray -coarray-num-images=4\" fpm run --example benchmark3 --compiler ifx --flag \"-Ofast -xHost -qopenmp -qmkl -coarray -coarray-num-images=4\" python benchmark3.py Results with -coarray-num-images=4 : API documentation The most up-to-date API documentation for the master branch is available here .\nTo generate the API documentation for ForMatmul using ford run the following\ncommand: ford ford.yml Contributing Contributions to ForMatmul are welcome!\nIf you find any issues or would like to suggest improvements, please open an issue. Developer Info Seyed Ali Ghasemi","tags":"home","loc":"index.html"},{"title":"matmul_mat_mat_rel_opts – ForMatmul","text":"private pure function matmul_mat_mat_rel_opts(A, B, option) result(C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) character(len=*), intent(in) :: option Return Value real(kind=rk), (size(A,1),size(B,2)) Calls proc~~matmul_mat_mat_rel_opts~~CallsGraph proc~matmul_mat_mat_rel_opts formatmul_opts::matmul_mat_mat_rel_opts interface~matmul_blas formatmul_opts::matmul_blas proc~matmul_mat_mat_rel_opts->interface~matmul_blas proc~mm_10 formatmul_opts::mm_10 proc~matmul_mat_mat_rel_opts->proc~mm_10 proc~mm_11 formatmul_opts::mm_11 proc~matmul_mat_mat_rel_opts->proc~mm_11 proc~mm_9 formatmul_opts::mm_9 proc~matmul_mat_mat_rel_opts->proc~mm_9 proc~mm_mnp formatmul_opts::mm_mnp proc~matmul_mat_mat_rel_opts->proc~mm_mnp proc~mm_mpn formatmul_opts::mm_mpn proc~matmul_mat_mat_rel_opts->proc~mm_mpn proc~mm_nmp formatmul_opts::mm_nmp proc~matmul_mat_mat_rel_opts->proc~mm_nmp proc~mm_npm formatmul_opts::mm_npm proc~matmul_mat_mat_rel_opts->proc~mm_npm proc~mm_pmn formatmul_opts::mm_pmn proc~matmul_mat_mat_rel_opts->proc~mm_pmn proc~mm_pnm formatmul_opts::mm_pnm proc~matmul_mat_mat_rel_opts->proc~mm_pnm proc~gemm_mat_mat_rel formatmul_opts::gemm_mat_mat_rel interface~matmul_blas->proc~gemm_mat_mat_rel proc~gemv_mat_vec_rel formatmul_opts::gemv_mat_vec_rel interface~matmul_blas->proc~gemv_mat_vec_rel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~matmul_mat_mat_rel_opts~~CalledByGraph proc~matmul_mat_mat_rel_opts formatmul_opts::matmul_mat_mat_rel_opts interface~matmul_opts formatmul_opts::matmul_opts interface~matmul_opts->proc~matmul_mat_mat_rel_opts proc~mat_mat formatmul::mat_mat proc~mat_mat->interface~matmul_opts proc~mat_vec formatmul::mat_vec proc~mat_vec->interface~matmul_opts interface~matmul formatmul::matmul interface~matmul->proc~mat_mat interface~matmul->proc~mat_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code matmul_mat_mat_rel_opts Source Code pure function matmul_mat_mat_rel_opts ( A , B , option ) result ( C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) character ( * ), intent ( in ) :: option real ( rk ) :: C ( size ( A , 1 ), size ( B , 2 )) integer :: m , n , k select case ( option ) case ( 'm1' ) C = matmul ( A , B ) case ( 'm2' ) C = matmul_blas ( A , B ) case ( 'm3' ) m = size ( A , 1 ) n = size ( B , 2 ) k = size ( B , 1 ) call mm_mnp ( m , k , n , a , b , c ) case ( 'm4' ) m = size ( A , 1 ) n = size ( B , 2 ) k = size ( B , 1 ) call mm_mpn ( m , k , n , a , b , c ) case ( 'm5' ) m = size ( A , 1 ) n = size ( B , 2 ) k = size ( B , 1 ) call mm_nmp ( m , k , n , a , b , c ) case ( 'm6' ) m = size ( A , 1 ) n = size ( B , 2 ) k = size ( B , 1 ) call mm_npm ( m , k , n , a , b , c ) case ( 'm7' ) m = size ( A , 1 ) n = size ( B , 2 ) k = size ( B , 1 ) call mm_pmn ( m , k , n , a , b , c ) case ( 'm8' ) m = size ( A , 1 ) n = size ( B , 2 ) k = size ( B , 1 ) call mm_pnm ( m , k , n , a , b , c ) case ( 'm9' ) m = size ( A , 1 ) n = size ( B , 2 ) k = size ( B , 1 ) call mm_9 ( m , k , n , a , b , c ) case ( 'm10' ) m = size ( A , 1 ) n = size ( B , 2 ) k = size ( B , 1 ) call mm_10 ( m , k , n , a , b , c ) case ( 'm11' ) m = size ( A , 1 ) n = size ( B , 2 ) k = size ( B , 1 ) call mm_11 ( m , k , n , a , b , c ) case default C = matmul ( A , B ) end select end function matmul_mat_mat_rel_opts","tags":"","loc":"proc/matmul_mat_mat_rel_opts.html"},{"title":"matmul_mat_vec_rel_opts – ForMatmul","text":"private pure function matmul_mat_vec_rel_opts(A, v, option) result(w) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) character(len=*), intent(in) :: option Return Value real(kind=rk), (size(A,1)) Calls proc~~matmul_mat_vec_rel_opts~~CallsGraph proc~matmul_mat_vec_rel_opts formatmul_opts::matmul_mat_vec_rel_opts interface~matmul_blas formatmul_opts::matmul_blas proc~matmul_mat_vec_rel_opts->interface~matmul_blas proc~gemm_mat_mat_rel formatmul_opts::gemm_mat_mat_rel interface~matmul_blas->proc~gemm_mat_mat_rel proc~gemv_mat_vec_rel formatmul_opts::gemv_mat_vec_rel interface~matmul_blas->proc~gemv_mat_vec_rel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~matmul_mat_vec_rel_opts~~CalledByGraph proc~matmul_mat_vec_rel_opts formatmul_opts::matmul_mat_vec_rel_opts interface~matmul_opts formatmul_opts::matmul_opts interface~matmul_opts->proc~matmul_mat_vec_rel_opts proc~mat_mat formatmul::mat_mat proc~mat_mat->interface~matmul_opts proc~mat_vec formatmul::mat_vec proc~mat_vec->interface~matmul_opts interface~matmul formatmul::matmul interface~matmul->proc~mat_mat interface~matmul->proc~mat_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code matmul_mat_vec_rel_opts Source Code pure function matmul_mat_vec_rel_opts ( A , v , option ) result ( w ) real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) character ( * ), intent ( in ) :: option real ( rk ) :: w ( size ( A , 1 )) select case ( option ) case ( 'm1' ) w = matmul ( A , v ) case ( 'm2' ) w = matmul_blas ( A , v ) case default w = matmul ( A , v ) end select end function matmul_mat_vec_rel_opts","tags":"","loc":"proc/matmul_mat_vec_rel_opts.html"},{"title":"gemm_mat_mat_rel – ForMatmul","text":"private pure function gemm_mat_mat_rel(A, B) result(C) Matrix-matrix multiplication using BLAS.\nauthor: Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A Input matrices A and B. real(kind=rk), intent(in), dimension(:, :), contiguous :: B Return Value real(kind=rk), dimension(size(A,1), size(B,2)) Result matrix C. Called by proc~~gemm_mat_mat_rel~~CalledByGraph proc~gemm_mat_mat_rel formatmul_opts::gemm_mat_mat_rel interface~matmul_blas formatmul_opts::matmul_blas interface~matmul_blas->proc~gemm_mat_mat_rel proc~matmul_mat_mat_rel_opts formatmul_opts::matmul_mat_mat_rel_opts proc~matmul_mat_mat_rel_opts->interface~matmul_blas proc~matmul_mat_vec_rel_opts formatmul_opts::matmul_mat_vec_rel_opts proc~matmul_mat_vec_rel_opts->interface~matmul_blas program~benchmark1 benchmark1 program~benchmark1->interface~matmul_blas program~benchmark2 benchmark2 program~benchmark2->interface~matmul_blas program~example5 example5 program~example5->interface~matmul_blas program~example7 example7 program~example7->interface~matmul_blas interface~matmul_opts formatmul_opts::matmul_opts interface~matmul_opts->proc~matmul_mat_mat_rel_opts interface~matmul_opts->proc~matmul_mat_vec_rel_opts proc~mat_mat formatmul::mat_mat proc~mat_mat->interface~matmul_opts proc~mat_vec formatmul::mat_vec proc~mat_vec->interface~matmul_opts interface~matmul formatmul::matmul interface~matmul->proc~mat_mat interface~matmul->proc~mat_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code gemm_mat_mat_rel Source Code pure function gemm_mat_mat_rel ( A , B ) result ( C ) !> Input matrices A and B. real ( rk ), dimension (:, :), contiguous , intent ( in ) :: A real ( rk ), dimension (:, :), contiguous , intent ( in ) :: B !> Result matrix C. real ( rk ), dimension ( size ( A , 1 ), size ( B , 2 )) :: C ! real(rk), dimension(:,:), allocatable             :: C integer :: m , n , k interface !> BLAS subroutine for matrix-matrix multiplication. pure subroutine dgemm ( f_transa , f_transb , f_m , f_n , f_k , f_alpha , f_a , f_lda , f_b , f_ldb , f_beta , f_c , f_ldc ) import rk integer , intent ( in ) :: f_ldc integer , intent ( in ) :: f_ldb integer , intent ( in ) :: f_lda character , intent ( in ) :: f_transa character , intent ( in ) :: f_transb integer , intent ( in ) :: f_m integer , intent ( in ) :: f_n integer , intent ( in ) :: f_k real ( rk ), intent ( in ) :: f_alpha real ( rk ), intent ( in ) :: f_a ( f_lda , * ) real ( rk ), intent ( in ) :: f_b ( f_ldb , * ) real ( rk ), intent ( in ) :: f_beta real ( rk ), intent ( inout ) :: f_c ( f_ldc , * ) end subroutine dgemm end interface m = size ( A , 1 ) n = size ( B , 2 ) k = size ( A , 2 ) C = 0.0_rk ! Call BLAS dgemm subroutine for matrix-matrix multiplication. call dgemm ( 'N' , 'N' , m , n , k , 1.0_rk , A , m , B , k , 0.0_rk , C , m ) end function gemm_mat_mat_rel","tags":"","loc":"proc/gemm_mat_mat_rel.html"},{"title":"gemv_mat_vec_rel – ForMatmul","text":"private pure function gemv_mat_vec_rel(A, x) result(y) Matrix-vector multiplication using BLAS.\nauthor: Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A Input matrix A and vector x. real(kind=rk), intent(in), dimension(:), contiguous :: x Return Value real(kind=rk), dimension(size(A,1)) Result vector y. Called by proc~~gemv_mat_vec_rel~~CalledByGraph proc~gemv_mat_vec_rel formatmul_opts::gemv_mat_vec_rel interface~matmul_blas formatmul_opts::matmul_blas interface~matmul_blas->proc~gemv_mat_vec_rel proc~matmul_mat_mat_rel_opts formatmul_opts::matmul_mat_mat_rel_opts proc~matmul_mat_mat_rel_opts->interface~matmul_blas proc~matmul_mat_vec_rel_opts formatmul_opts::matmul_mat_vec_rel_opts proc~matmul_mat_vec_rel_opts->interface~matmul_blas program~benchmark1 benchmark1 program~benchmark1->interface~matmul_blas program~benchmark2 benchmark2 program~benchmark2->interface~matmul_blas program~example5 example5 program~example5->interface~matmul_blas program~example7 example7 program~example7->interface~matmul_blas interface~matmul_opts formatmul_opts::matmul_opts interface~matmul_opts->proc~matmul_mat_mat_rel_opts interface~matmul_opts->proc~matmul_mat_vec_rel_opts proc~mat_mat formatmul::mat_mat proc~mat_mat->interface~matmul_opts proc~mat_vec formatmul::mat_vec proc~mat_vec->interface~matmul_opts interface~matmul formatmul::matmul interface~matmul->proc~mat_mat interface~matmul->proc~mat_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code gemv_mat_vec_rel Source Code pure function gemv_mat_vec_rel ( A , x ) result ( y ) !> Input matrix A and vector x. real ( rk ), dimension (:, :), contiguous , intent ( in ) :: A real ( rk ), dimension (:), contiguous , intent ( in ) :: x !> Result vector y. real ( rk ), dimension ( size ( A , 1 )) :: y ! real(rk), dimension(:), allocatable               :: y integer :: m , n interface !> BLAS subroutine for matrix-vector multiplication. pure subroutine dgemv ( f_trans , f_m , f_n , f_alpha , f_a , f_lda , f_x , f_incx , f_beta , f_y , f_incy ) import rk integer , intent ( in ) :: f_m integer , intent ( in ) :: f_n integer , intent ( in ) :: f_lda character , intent ( in ) :: f_trans real ( rk ), intent ( in ) :: f_alpha real ( rk ), intent ( in ) :: f_a ( f_lda , * ) real ( rk ), intent ( in ) :: f_x ( * ) integer , intent ( in ) :: f_incx real ( rk ), intent ( in ) :: f_beta real ( rk ), intent ( inout ) :: f_y ( * ) integer , intent ( in ) :: f_incy end subroutine dgemv end interface m = size ( A , 1 ) n = size ( A , 2 ) y = 0.0_rk ! Call BLAS dgemv subroutine for matrix-vector multiplication. call dgemv ( 'N' , m , n , 1.0_rk , A , m , x , 1 , 0.0_rk , y , 1 ) end function gemv_mat_vec_rel","tags":"","loc":"proc/gemv_mat_vec_rel.html"},{"title":"mm_mnp – ForMatmul","text":"private pure subroutine mm_mnp(m, n, p, a, b, c) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: p real(kind=rk), intent(in) :: a (m,n) real(kind=rk), intent(in) :: b (n,p) real(kind=rk), intent(out) :: c (m,p) Called by proc~~mm_mnp~~CalledByGraph proc~mm_mnp formatmul_opts::mm_mnp proc~matmul_mat_mat_rel_opts formatmul_opts::matmul_mat_mat_rel_opts proc~matmul_mat_mat_rel_opts->proc~mm_mnp interface~matmul_opts formatmul_opts::matmul_opts interface~matmul_opts->proc~matmul_mat_mat_rel_opts proc~mat_mat formatmul::mat_mat proc~mat_mat->interface~matmul_opts proc~mat_vec formatmul::mat_vec proc~mat_vec->interface~matmul_opts interface~matmul formatmul::matmul interface~matmul->proc~mat_mat interface~matmul->proc~mat_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code mm_mnp Source Code pure subroutine mm_mnp ( m , n , p , a , b , c ) integer , intent ( in ) :: m , n , p real ( rk ), intent ( in ) :: a ( m , n ), b ( n , p ) real ( rk ), intent ( out ) :: c ( m , p ) integer :: i , j , k c = 0.0_rk do i = 1 , m do j = 1 , n do k = 1 , p c ( i , k ) = c ( i , k ) + a ( i , j ) * b ( j , k ) end do end do end do end subroutine mm_mnp","tags":"","loc":"proc/mm_mnp.html"},{"title":"mm_mpn – ForMatmul","text":"private pure subroutine mm_mpn(m, n, p, a, b, c) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: p real(kind=rk), intent(in) :: a (m,n) real(kind=rk), intent(in) :: b (n,p) real(kind=rk), intent(out) :: c (m,p) Called by proc~~mm_mpn~~CalledByGraph proc~mm_mpn formatmul_opts::mm_mpn proc~matmul_mat_mat_rel_opts formatmul_opts::matmul_mat_mat_rel_opts proc~matmul_mat_mat_rel_opts->proc~mm_mpn interface~matmul_opts formatmul_opts::matmul_opts interface~matmul_opts->proc~matmul_mat_mat_rel_opts proc~mat_mat formatmul::mat_mat proc~mat_mat->interface~matmul_opts proc~mat_vec formatmul::mat_vec proc~mat_vec->interface~matmul_opts interface~matmul formatmul::matmul interface~matmul->proc~mat_mat interface~matmul->proc~mat_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code mm_mpn Source Code pure subroutine mm_mpn ( m , n , p , a , b , c ) integer , intent ( in ) :: m , n , p real ( rk ), intent ( in ) :: a ( m , n ), b ( n , p ) real ( rk ), intent ( out ) :: c ( m , p ) integer :: i , j , k c = 0.0_rk do i = 1 , m do j = 1 , p do k = 1 , n c ( i , j ) = c ( i , j ) + a ( i , k ) * b ( k , j ) end do end do end do end subroutine mm_mpn","tags":"","loc":"proc/mm_mpn.html"},{"title":"mm_nmp – ForMatmul","text":"private pure subroutine mm_nmp(m, n, p, a, b, c) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: p real(kind=rk), intent(in) :: a (m,n) real(kind=rk), intent(in) :: b (n,p) real(kind=rk), intent(out) :: c (m,p) Called by proc~~mm_nmp~~CalledByGraph proc~mm_nmp formatmul_opts::mm_nmp proc~matmul_mat_mat_rel_opts formatmul_opts::matmul_mat_mat_rel_opts proc~matmul_mat_mat_rel_opts->proc~mm_nmp interface~matmul_opts formatmul_opts::matmul_opts interface~matmul_opts->proc~matmul_mat_mat_rel_opts proc~mat_mat formatmul::mat_mat proc~mat_mat->interface~matmul_opts proc~mat_vec formatmul::mat_vec proc~mat_vec->interface~matmul_opts interface~matmul formatmul::matmul interface~matmul->proc~mat_mat interface~matmul->proc~mat_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code mm_nmp Source Code pure subroutine mm_nmp ( m , n , p , a , b , c ) integer , intent ( in ) :: m , n , p real ( rk ), intent ( in ) :: a ( m , n ), b ( n , p ) real ( rk ), intent ( out ) :: c ( m , p ) integer :: i , j , k c = 0.0_rk do i = 1 , n do j = 1 , m do k = 1 , p c ( j , k ) = c ( j , k ) + a ( j , i ) * b ( i , k ) end do end do end do end subroutine mm_nmp","tags":"","loc":"proc/mm_nmp.html"},{"title":"mm_npm – ForMatmul","text":"private pure subroutine mm_npm(m, n, p, a, b, c) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: p real(kind=rk), intent(in) :: a (m,n) real(kind=rk), intent(in) :: b (n,p) real(kind=rk), intent(out) :: c (m,p) Called by proc~~mm_npm~~CalledByGraph proc~mm_npm formatmul_opts::mm_npm proc~matmul_mat_mat_rel_opts formatmul_opts::matmul_mat_mat_rel_opts proc~matmul_mat_mat_rel_opts->proc~mm_npm interface~matmul_opts formatmul_opts::matmul_opts interface~matmul_opts->proc~matmul_mat_mat_rel_opts proc~mat_mat formatmul::mat_mat proc~mat_mat->interface~matmul_opts proc~mat_vec formatmul::mat_vec proc~mat_vec->interface~matmul_opts interface~matmul formatmul::matmul interface~matmul->proc~mat_mat interface~matmul->proc~mat_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code mm_npm Source Code pure subroutine mm_npm ( m , n , p , a , b , c ) integer , intent ( in ) :: m , n , p real ( rk ), intent ( in ) :: a ( m , n ), b ( n , p ) real ( rk ), intent ( out ) :: c ( m , p ) integer :: i , j , k c = 0.0_rk do i = 1 , n do j = 1 , p do k = 1 , m c ( k , j ) = c ( k , j ) + a ( k , i ) * b ( i , j ) end do end do end do end subroutine mm_npm","tags":"","loc":"proc/mm_npm.html"},{"title":"mm_pmn – ForMatmul","text":"private pure subroutine mm_pmn(m, n, p, a, b, c) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: p real(kind=rk), intent(in) :: a (m,n) real(kind=rk), intent(in) :: b (n,p) real(kind=rk), intent(out) :: c (m,p) Called by proc~~mm_pmn~~CalledByGraph proc~mm_pmn formatmul_opts::mm_pmn proc~matmul_mat_mat_rel_opts formatmul_opts::matmul_mat_mat_rel_opts proc~matmul_mat_mat_rel_opts->proc~mm_pmn interface~matmul_opts formatmul_opts::matmul_opts interface~matmul_opts->proc~matmul_mat_mat_rel_opts proc~mat_mat formatmul::mat_mat proc~mat_mat->interface~matmul_opts proc~mat_vec formatmul::mat_vec proc~mat_vec->interface~matmul_opts interface~matmul formatmul::matmul interface~matmul->proc~mat_mat interface~matmul->proc~mat_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code mm_pmn Source Code pure subroutine mm_pmn ( m , n , p , a , b , c ) integer , intent ( in ) :: m , n , p real ( rk ), intent ( in ) :: a ( m , n ), b ( n , p ) real ( rk ), intent ( out ) :: c ( m , p ) integer :: i , j , k c = 0.0_rk do i = 1 , p do j = 1 , m do k = 1 , n c ( j , i ) = c ( j , i ) + a ( j , k ) * b ( k , i ) end do end do end do end subroutine mm_pmn","tags":"","loc":"proc/mm_pmn.html"},{"title":"mm_pnm – ForMatmul","text":"private pure subroutine mm_pnm(m, n, p, a, b, c) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: p real(kind=rk), intent(in) :: a (m,n) real(kind=rk), intent(in) :: b (n,p) real(kind=rk), intent(out) :: c (m,p) Called by proc~~mm_pnm~~CalledByGraph proc~mm_pnm formatmul_opts::mm_pnm proc~matmul_mat_mat_rel_opts formatmul_opts::matmul_mat_mat_rel_opts proc~matmul_mat_mat_rel_opts->proc~mm_pnm interface~matmul_opts formatmul_opts::matmul_opts interface~matmul_opts->proc~matmul_mat_mat_rel_opts proc~mat_mat formatmul::mat_mat proc~mat_mat->interface~matmul_opts proc~mat_vec formatmul::mat_vec proc~mat_vec->interface~matmul_opts interface~matmul formatmul::matmul interface~matmul->proc~mat_mat interface~matmul->proc~mat_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code mm_pnm Source Code pure subroutine mm_pnm ( m , n , p , a , b , c ) integer , intent ( in ) :: m , n , p real ( rk ), intent ( in ) :: a ( m , n ), b ( n , p ) real ( rk ), intent ( out ) :: c ( m , p ) integer :: i , j , k c = 0.0_rk do i = 1 , p do j = 1 , n do k = 1 , m c ( k , i ) = c ( k , i ) + a ( k , j ) * b ( j , i ) end do end do end do end subroutine mm_pnm","tags":"","loc":"proc/mm_pnm.html"},{"title":"mm_9 – ForMatmul","text":"private pure subroutine mm_9(m, n, p, a, b, c) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: p real(kind=rk), intent(in) :: a (m,n) real(kind=rk), intent(in) :: b (n,p) real(kind=rk), intent(out) :: c (m,p) Called by proc~~mm_9~~CalledByGraph proc~mm_9 formatmul_opts::mm_9 proc~matmul_mat_mat_rel_opts formatmul_opts::matmul_mat_mat_rel_opts proc~matmul_mat_mat_rel_opts->proc~mm_9 interface~matmul_opts formatmul_opts::matmul_opts interface~matmul_opts->proc~matmul_mat_mat_rel_opts proc~mat_mat formatmul::mat_mat proc~mat_mat->interface~matmul_opts proc~mat_vec formatmul::mat_vec proc~mat_vec->interface~matmul_opts interface~matmul formatmul::matmul interface~matmul->proc~mat_mat interface~matmul->proc~mat_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code mm_9 Source Code pure subroutine mm_9 ( m , n , p , a , b , c ) integer , intent ( in ) :: m , n , p real ( rk ), intent ( in ) :: a ( m , n ), b ( n , p ) real ( rk ), intent ( out ) :: c ( m , p ) integer :: i , j , k c = 0.0_rk do i = 1 , p do k = 1 , m c ( k , i ) = dot_product ( a ( k ,:), b (:, i )) end do end do end subroutine mm_9","tags":"","loc":"proc/mm_9.html"},{"title":"mm_10 – ForMatmul","text":"private pure subroutine mm_10(m, n, p, a, b, c) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: p real(kind=rk), intent(in) :: a (m,n) real(kind=rk), intent(in) :: b (n,p) real(kind=rk), intent(out) :: c (m,p) Called by proc~~mm_10~~CalledByGraph proc~mm_10 formatmul_opts::mm_10 proc~matmul_mat_mat_rel_opts formatmul_opts::matmul_mat_mat_rel_opts proc~matmul_mat_mat_rel_opts->proc~mm_10 interface~matmul_opts formatmul_opts::matmul_opts interface~matmul_opts->proc~matmul_mat_mat_rel_opts proc~mat_mat formatmul::mat_mat proc~mat_mat->interface~matmul_opts proc~mat_vec formatmul::mat_vec proc~mat_vec->interface~matmul_opts interface~matmul formatmul::matmul interface~matmul->proc~mat_mat interface~matmul->proc~mat_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code mm_10 Source Code pure subroutine mm_10 ( m , n , p , a , b , c ) integer , intent ( in ) :: m , n , p real ( rk ), intent ( in ) :: a ( m , n ), b ( n , p ) real ( rk ), intent ( out ) :: c ( m , p ) integer :: i , j , k c = 0.0_rk do concurrent ( i = 1 : p ) do k = 1 , m c ( k , i ) = dot_product ( a ( k ,:), b (:, i )) end do end do end subroutine mm_10","tags":"","loc":"proc/mm_10.html"},{"title":"mm_11 – ForMatmul","text":"private pure subroutine mm_11(m, n, p, a, b, c) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: p real(kind=rk), intent(in) :: a (m,n) real(kind=rk), intent(in) :: b (n,p) real(kind=rk), intent(out) :: c (m,p) Called by proc~~mm_11~~CalledByGraph proc~mm_11 formatmul_opts::mm_11 proc~matmul_mat_mat_rel_opts formatmul_opts::matmul_mat_mat_rel_opts proc~matmul_mat_mat_rel_opts->proc~mm_11 interface~matmul_opts formatmul_opts::matmul_opts interface~matmul_opts->proc~matmul_mat_mat_rel_opts proc~mat_mat formatmul::mat_mat proc~mat_mat->interface~matmul_opts proc~mat_vec formatmul::mat_vec proc~mat_vec->interface~matmul_opts interface~matmul formatmul::matmul interface~matmul->proc~mat_mat interface~matmul->proc~mat_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code mm_11 Source Code pure subroutine mm_11 ( m , n , p , a , b , c ) integer , intent ( in ) :: m , n , p real ( rk ), intent ( in ) :: a ( m , n ), b ( n , p ) real ( rk ), intent ( out ) :: c ( m , p ) integer :: i , j , k c = 0.0_rk do concurrent ( i = 1 : p ) do j = 1 , n do k = 1 , m c ( k , i ) = c ( k , i ) + a ( k , j ) * b ( j , i ) end do end do end do end subroutine mm_11","tags":"","loc":"proc/mm_11.html"},{"title":"matmul_opts – ForMatmul","text":"public interface matmul_opts Calls interface~~matmul_opts~~CallsGraph interface~matmul_opts formatmul_opts::matmul_opts proc~matmul_mat_mat_rel_opts formatmul_opts::matmul_mat_mat_rel_opts interface~matmul_opts->proc~matmul_mat_mat_rel_opts proc~matmul_mat_vec_rel_opts formatmul_opts::matmul_mat_vec_rel_opts interface~matmul_opts->proc~matmul_mat_vec_rel_opts interface~matmul_blas formatmul_opts::matmul_blas proc~matmul_mat_mat_rel_opts->interface~matmul_blas proc~mm_10 formatmul_opts::mm_10 proc~matmul_mat_mat_rel_opts->proc~mm_10 proc~mm_11 formatmul_opts::mm_11 proc~matmul_mat_mat_rel_opts->proc~mm_11 proc~mm_9 formatmul_opts::mm_9 proc~matmul_mat_mat_rel_opts->proc~mm_9 proc~mm_mnp formatmul_opts::mm_mnp proc~matmul_mat_mat_rel_opts->proc~mm_mnp proc~mm_mpn formatmul_opts::mm_mpn proc~matmul_mat_mat_rel_opts->proc~mm_mpn proc~mm_nmp formatmul_opts::mm_nmp proc~matmul_mat_mat_rel_opts->proc~mm_nmp proc~mm_npm formatmul_opts::mm_npm proc~matmul_mat_mat_rel_opts->proc~mm_npm proc~mm_pmn formatmul_opts::mm_pmn proc~matmul_mat_mat_rel_opts->proc~mm_pmn proc~mm_pnm formatmul_opts::mm_pnm proc~matmul_mat_mat_rel_opts->proc~mm_pnm proc~matmul_mat_vec_rel_opts->interface~matmul_blas proc~gemm_mat_mat_rel formatmul_opts::gemm_mat_mat_rel interface~matmul_blas->proc~gemm_mat_mat_rel proc~gemv_mat_vec_rel formatmul_opts::gemv_mat_vec_rel interface~matmul_blas->proc~gemv_mat_vec_rel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~matmul_opts~~CalledByGraph interface~matmul_opts formatmul_opts::matmul_opts proc~mat_mat formatmul::mat_mat proc~mat_mat->interface~matmul_opts proc~mat_vec formatmul::mat_vec proc~mat_vec->interface~matmul_opts interface~matmul formatmul::matmul interface~matmul->proc~mat_mat interface~matmul->proc~mat_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Module Procedures matmul_mat_mat_rel_opts matmul_mat_vec_rel_opts Module Procedures private pure function matmul_mat_mat_rel_opts (A, B, option) result(C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) character(len=*), intent(in) :: option Return Value real(kind=rk), (size(A,1),size(B,2)) private pure function matmul_mat_vec_rel_opts (A, v, option) result(w) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) character(len=*), intent(in) :: option Return Value real(kind=rk), (size(A,1))","tags":"","loc":"interface/matmul_opts.html"},{"title":"matmul_blas – ForMatmul","text":"public interface matmul_blas Interface for BLAS-based matrix multiplication functions. Calls interface~~matmul_blas~~CallsGraph interface~matmul_blas formatmul_opts::matmul_blas proc~gemm_mat_mat_rel formatmul_opts::gemm_mat_mat_rel interface~matmul_blas->proc~gemm_mat_mat_rel proc~gemv_mat_vec_rel formatmul_opts::gemv_mat_vec_rel interface~matmul_blas->proc~gemv_mat_vec_rel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~matmul_blas~~CalledByGraph interface~matmul_blas formatmul_opts::matmul_blas proc~matmul_mat_mat_rel_opts formatmul_opts::matmul_mat_mat_rel_opts proc~matmul_mat_mat_rel_opts->interface~matmul_blas proc~matmul_mat_vec_rel_opts formatmul_opts::matmul_mat_vec_rel_opts proc~matmul_mat_vec_rel_opts->interface~matmul_blas program~benchmark1 benchmark1 program~benchmark1->interface~matmul_blas program~benchmark2 benchmark2 program~benchmark2->interface~matmul_blas program~example5 example5 program~example5->interface~matmul_blas program~example7 example7 program~example7->interface~matmul_blas interface~matmul_opts formatmul_opts::matmul_opts interface~matmul_opts->proc~matmul_mat_mat_rel_opts interface~matmul_opts->proc~matmul_mat_vec_rel_opts proc~mat_mat formatmul::mat_mat proc~mat_mat->interface~matmul_opts proc~mat_vec formatmul::mat_vec proc~mat_vec->interface~matmul_opts interface~matmul formatmul::matmul interface~matmul->proc~mat_mat interface~matmul->proc~mat_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Module Procedures gemm_mat_mat_rel gemv_mat_vec_rel Module Procedures private pure function gemm_mat_mat_rel (A, B) result(C) Matrix-matrix multiplication using BLAS.\nauthor: Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A Input matrices A and B. real(kind=rk), intent(in), dimension(:, :), contiguous :: B Return Value real(kind=rk), dimension(size(A,1), size(B,2)) Result matrix C. private pure function gemv_mat_vec_rel (A, x) result(y) Matrix-vector multiplication using BLAS.\nauthor: Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A Input matrix A and vector x. real(kind=rk), intent(in), dimension(:), contiguous :: x Return Value real(kind=rk), dimension(size(A,1)) Result vector y.","tags":"","loc":"interface/matmul_blas.html"},{"title":"mat_mat – ForMatmul","text":"private pure function mat_mat(A, B, method, option) result(C) Matrix-matrix multiplication using coarray parallelism.\nauthor: Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) Input matrices A and B. real(kind=rk), intent(in), contiguous :: B (:,:) Input matrices A and B. character(len=*), intent(in) :: method Multiplication method ('coarray'). character(len=*), intent(in), optional :: option Optional method-specific option. Return Value real(kind=rk), (size(A,1),size(B,2)) Result matrix C. Calls proc~~mat_mat~~CallsGraph proc~mat_mat formatmul::mat_mat a_block a_block proc~mat_mat->a_block b_block b_block proc~mat_mat->b_block block_size block_size proc~mat_mat->block_size c_block c_block proc~mat_mat->c_block interface~matmul_opts formatmul_opts::matmul_opts proc~mat_mat->interface~matmul_opts offsets offsets proc~mat_mat->offsets proc~calc_block_offsets formatmul::calc_block_offsets proc~mat_mat->proc~calc_block_offsets proc~matmul_mat_mat_rel_opts formatmul_opts::matmul_mat_mat_rel_opts interface~matmul_opts->proc~matmul_mat_mat_rel_opts proc~matmul_mat_vec_rel_opts formatmul_opts::matmul_mat_vec_rel_opts interface~matmul_opts->proc~matmul_mat_vec_rel_opts interface~matmul_blas formatmul_opts::matmul_blas proc~matmul_mat_mat_rel_opts->interface~matmul_blas proc~mm_10 formatmul_opts::mm_10 proc~matmul_mat_mat_rel_opts->proc~mm_10 proc~mm_11 formatmul_opts::mm_11 proc~matmul_mat_mat_rel_opts->proc~mm_11 proc~mm_9 formatmul_opts::mm_9 proc~matmul_mat_mat_rel_opts->proc~mm_9 proc~mm_mnp formatmul_opts::mm_mnp proc~matmul_mat_mat_rel_opts->proc~mm_mnp proc~mm_mpn formatmul_opts::mm_mpn proc~matmul_mat_mat_rel_opts->proc~mm_mpn proc~mm_nmp formatmul_opts::mm_nmp proc~matmul_mat_mat_rel_opts->proc~mm_nmp proc~mm_npm formatmul_opts::mm_npm proc~matmul_mat_mat_rel_opts->proc~mm_npm proc~mm_pmn formatmul_opts::mm_pmn proc~matmul_mat_mat_rel_opts->proc~mm_pmn proc~mm_pnm formatmul_opts::mm_pnm proc~matmul_mat_mat_rel_opts->proc~mm_pnm proc~matmul_mat_vec_rel_opts->interface~matmul_blas proc~gemm_mat_mat_rel formatmul_opts::gemm_mat_mat_rel interface~matmul_blas->proc~gemm_mat_mat_rel proc~gemv_mat_vec_rel formatmul_opts::gemv_mat_vec_rel interface~matmul_blas->proc~gemv_mat_vec_rel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~mat_mat~~CalledByGraph proc~mat_mat formatmul::mat_mat interface~matmul formatmul::matmul interface~matmul->proc~mat_mat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code mat_mat Source Code pure function mat_mat ( A , B , method , option ) result ( C ) !> Input matrices A and B. real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) !> Multiplication method ('coarray'). character ( * ), intent ( in ) :: method !> Optional method-specific option. character ( * ), intent ( in ), optional :: option !> Result matrix C. ! real(rk), allocatable                :: C(:,:) real ( rk ) :: C ( size ( A , 1 ), size ( B , 2 )) if ( method == 'coarray' ) then ! Coarray-based parallel multiplication. if ( size ( A , 1 ) >= size ( B , 2 )) then ! Handle A's columns > B's rows. block integer :: i , m , n , o , im , nimg , base_value , remainder integer :: block_size ( num_images ()) integer :: offsets ( num_images ()) real ( rk ), allocatable :: C_block (:,:)[:], A_block (:,:)[:] im = this_image () nimg = num_images () m = size ( A , 1 ) o = size ( B , 2 ) n = size ( A , 2 ) call calc_block_offsets ( m , nimg , block_size , offsets ) allocate ( A_block ( block_size ( im ), n )[ * ]) allocate ( C_block ( block_size ( im ), o )[ * ]) A_block (:,:)[ im ] = A ( offsets ( im ) : offsets ( im ) + block_size ( im ) - 1 , :) C_block (:,:)[ im ] = matmul_opts ( A_block (:,:)[ im ], B , option ) sync all if ( im == 1 ) then do i = 1 , nimg C ( offsets ( i ) : offsets ( i ) + block_size ( i ) - 1 , :) = C_block (:,:)[ i ] end do end if end block else ! Handle B's columns > A's rows. block integer :: i , m , n , o , im , nimg , base_value , remainder integer :: block_size ( num_images ()) integer :: offsets ( num_images ()) real ( rk ), allocatable :: C_block (:,:)[:], B_block (:,:)[:] im = this_image () nimg = num_images () m = size ( A , 1 ) o = size ( B , 2 ) n = size ( A , 2 ) call calc_block_offsets ( o , nimg , block_size , offsets ) allocate ( B_block ( n , block_size ( im ))[ * ]) allocate ( C_block ( m , block_size ( im ))[ * ]) B_block (:,:)[ im ] = B (:, offsets ( im ) : offsets ( im ) + block_size ( im ) - 1 ) C_block (:,:)[ im ] = matmul_opts ( A , B_block (:,:)[ im ], option ) sync all if ( im == 1 ) then do i = 1 , nimg C (:, offsets ( i ) : offsets ( i ) + block_size ( i ) - 1 ) = C_block (:,:)[ i ] end do end if end block end if else ! Unsupported multiplication method. error stop 'Error: The specified method is not available for matrix-matrix multiplication!' ! if (this_image() == 1) then !    ! if (.not. allocated(C)) allocate(C(m, o)) !    C = matmul(A, B) ! end if end if end function mat_mat","tags":"","loc":"proc/mat_mat.html"},{"title":"mat_vec – ForMatmul","text":"private pure function mat_vec(A, v, method, option) result(w) Matrix-vector multiplication using coarray parallelism.\nauthor: Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) Input matrix A and vector v. real(kind=rk), intent(in), contiguous :: v (:) Input matrix A and vector v. character(len=*), intent(in) :: method Multiplication method ('coarray'). character(len=*), intent(in), optional :: option Optional method-specific option. Return Value real(kind=rk), allocatable, (:) Result vector w. Calls proc~~mat_vec~~CallsGraph proc~mat_vec formatmul::mat_vec interface~matmul_opts formatmul_opts::matmul_opts proc~mat_vec->interface~matmul_opts w_block w_block proc~mat_vec->w_block proc~matmul_mat_mat_rel_opts formatmul_opts::matmul_mat_mat_rel_opts interface~matmul_opts->proc~matmul_mat_mat_rel_opts proc~matmul_mat_vec_rel_opts formatmul_opts::matmul_mat_vec_rel_opts interface~matmul_opts->proc~matmul_mat_vec_rel_opts interface~matmul_blas formatmul_opts::matmul_blas proc~matmul_mat_mat_rel_opts->interface~matmul_blas proc~mm_10 formatmul_opts::mm_10 proc~matmul_mat_mat_rel_opts->proc~mm_10 proc~mm_11 formatmul_opts::mm_11 proc~matmul_mat_mat_rel_opts->proc~mm_11 proc~mm_9 formatmul_opts::mm_9 proc~matmul_mat_mat_rel_opts->proc~mm_9 proc~mm_mnp formatmul_opts::mm_mnp proc~matmul_mat_mat_rel_opts->proc~mm_mnp proc~mm_mpn formatmul_opts::mm_mpn proc~matmul_mat_mat_rel_opts->proc~mm_mpn proc~mm_nmp formatmul_opts::mm_nmp proc~matmul_mat_mat_rel_opts->proc~mm_nmp proc~mm_npm formatmul_opts::mm_npm proc~matmul_mat_mat_rel_opts->proc~mm_npm proc~mm_pmn formatmul_opts::mm_pmn proc~matmul_mat_mat_rel_opts->proc~mm_pmn proc~mm_pnm formatmul_opts::mm_pnm proc~matmul_mat_mat_rel_opts->proc~mm_pnm proc~matmul_mat_vec_rel_opts->interface~matmul_blas proc~gemm_mat_mat_rel formatmul_opts::gemm_mat_mat_rel interface~matmul_blas->proc~gemm_mat_mat_rel proc~gemv_mat_vec_rel formatmul_opts::gemv_mat_vec_rel interface~matmul_blas->proc~gemv_mat_vec_rel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~mat_vec~~CalledByGraph proc~mat_vec formatmul::mat_vec interface~matmul formatmul::matmul interface~matmul->proc~mat_vec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code mat_vec Source Code pure function mat_vec ( A , v , method , option ) result ( w ) !> Input matrix A and vector v. real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) !> Multiplication method ('coarray'). character ( * ), intent ( in ) :: method !> Optional method-specific option. character ( * ), intent ( in ), optional :: option !> Result vector w. real ( rk ), allocatable :: w (:) if ( method == 'coarray' ) then ! Coarray-based parallel multiplication. block integer :: i , block_size , n , im , nimg real ( rk ), allocatable :: w_block (:)[:] integer :: m , remainder_m im = this_image () nimg = num_images () m = size ( A , 1 ) n = size ( A , 2 ) block_size = m / nimg remainder_m = m - block_size * ( nimg - 1 ) if ( mod ( m , nimg ) == 0 ) then if (. not . allocated ( w_block )) allocate ( w_block ( block_size )[ * ]) w_block (:) = matmul_opts ( A (( im - 1 ) * block_size + 1 : im * block_size , 1 : n ), v , option ) else if (. not . allocated ( w_block )) allocate ( w_block ( remainder_m )[ * ]) w_block (:) = matmul_opts ( A (( im - 1 ) * block_size + 1 : im * block_size + remainder_m , 1 : n ), v , option ) end if sync all ! critical if ( im == 1 ) then if (. not . allocated ( w )) allocate ( w ( m )) do i = 1 , nimg - 1 w (( i - 1 ) * block_size + 1 : i * block_size ) = w_block (:)[ i ] end do w (( nimg - 1 ) * block_size + 1 : m ) = w_block (:)[ nimg ] end if ! end critical end block else ! Unsupported multiplication method. error stop 'Error: The specified method is not available for matrix-vector multiplication!' ! if (this_image() == 1) then !    ! if (.not. allocated(w)) allocate(w(m)) !    w = matmul(A, v) ! end if end if end function mat_vec","tags":"","loc":"proc/mat_vec.html"},{"title":"calc_block_offsets – ForMatmul","text":"private pure subroutine calc_block_offsets(d, nimg, block_size, offsets) Calculate block sizes and offsets.\nauthor: Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name integer, intent(in) :: d integer, intent(in) :: nimg integer, intent(out) :: block_size (nimg) integer, intent(out) :: offsets (nimg) Called by proc~~calc_block_offsets~~CalledByGraph proc~calc_block_offsets formatmul::calc_block_offsets proc~mat_mat formatmul::mat_mat proc~mat_mat->proc~calc_block_offsets interface~matmul formatmul::matmul interface~matmul->proc~mat_mat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code calc_block_offsets Source Code pure subroutine calc_block_offsets ( d , nimg , block_size , offsets ) integer , intent ( in ) :: d , nimg integer , intent ( out ) :: block_size ( nimg ), offsets ( nimg ) integer :: i , base_value , remainder base_value = d / nimg remainder = d - base_value * nimg block_size ( 1 : nimg ) = base_value if ( remainder > 0 ) block_size ( 1 : remainder ) = base_value + 1 offsets = [( sum ( block_size ( 1 : i - 1 )) + 1 , i = 1 , nimg )] end subroutine calc_block_offsets","tags":"","loc":"proc/calc_block_offsets.html"},{"title":"matmul – ForMatmul","text":"public interface matmul Interface for matrix multiplication functions. Calls interface~~matmul~~CallsGraph interface~matmul formatmul::matmul proc~mat_mat formatmul::mat_mat interface~matmul->proc~mat_mat proc~mat_vec formatmul::mat_vec interface~matmul->proc~mat_vec a_block a_block proc~mat_mat->a_block b_block b_block proc~mat_mat->b_block block_size block_size proc~mat_mat->block_size c_block c_block proc~mat_mat->c_block interface~matmul_opts formatmul_opts::matmul_opts proc~mat_mat->interface~matmul_opts offsets offsets proc~mat_mat->offsets proc~calc_block_offsets formatmul::calc_block_offsets proc~mat_mat->proc~calc_block_offsets proc~mat_vec->interface~matmul_opts w_block w_block proc~mat_vec->w_block proc~matmul_mat_mat_rel_opts formatmul_opts::matmul_mat_mat_rel_opts interface~matmul_opts->proc~matmul_mat_mat_rel_opts proc~matmul_mat_vec_rel_opts formatmul_opts::matmul_mat_vec_rel_opts interface~matmul_opts->proc~matmul_mat_vec_rel_opts interface~matmul_blas formatmul_opts::matmul_blas proc~matmul_mat_mat_rel_opts->interface~matmul_blas proc~mm_10 formatmul_opts::mm_10 proc~matmul_mat_mat_rel_opts->proc~mm_10 proc~mm_11 formatmul_opts::mm_11 proc~matmul_mat_mat_rel_opts->proc~mm_11 proc~mm_9 formatmul_opts::mm_9 proc~matmul_mat_mat_rel_opts->proc~mm_9 proc~mm_mnp formatmul_opts::mm_mnp proc~matmul_mat_mat_rel_opts->proc~mm_mnp proc~mm_mpn formatmul_opts::mm_mpn proc~matmul_mat_mat_rel_opts->proc~mm_mpn proc~mm_nmp formatmul_opts::mm_nmp proc~matmul_mat_mat_rel_opts->proc~mm_nmp proc~mm_npm formatmul_opts::mm_npm proc~matmul_mat_mat_rel_opts->proc~mm_npm proc~mm_pmn formatmul_opts::mm_pmn proc~matmul_mat_mat_rel_opts->proc~mm_pmn proc~mm_pnm formatmul_opts::mm_pnm proc~matmul_mat_mat_rel_opts->proc~mm_pnm proc~matmul_mat_vec_rel_opts->interface~matmul_blas proc~gemm_mat_mat_rel formatmul_opts::gemm_mat_mat_rel interface~matmul_blas->proc~gemm_mat_mat_rel proc~gemv_mat_vec_rel formatmul_opts::gemv_mat_vec_rel interface~matmul_blas->proc~gemv_mat_vec_rel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Module Procedures mat_mat mat_vec Module Procedures private pure function mat_mat (A, B, method, option) result(C) Matrix-matrix multiplication using coarray parallelism.\nauthor: Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) Input matrices A and B. real(kind=rk), intent(in), contiguous :: B (:,:) Input matrices A and B. character(len=*), intent(in) :: method Multiplication method ('coarray'). character(len=*), intent(in), optional :: option Optional method-specific option. Return Value real(kind=rk), (size(A,1),size(B,2)) Result matrix C. private pure function mat_vec (A, v, method, option) result(w) Matrix-vector multiplication using coarray parallelism.\nauthor: Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) Input matrix A and vector v. real(kind=rk), intent(in), contiguous :: v (:) Input matrix A and vector v. character(len=*), intent(in) :: method Multiplication method ('coarray'). character(len=*), intent(in), optional :: option Optional method-specific option. Return Value real(kind=rk), allocatable, (:) Result vector w.","tags":"","loc":"interface/matmul.html"},{"title":"start_benchmark – ForMatmul","text":"subroutine start_benchmark(ti, im, msg) Arguments Type Intent Optional Attributes Name type(timer), intent(out) :: ti integer, intent(in) :: im character(len=*), intent(in) :: msg Calls proc~~start_benchmark~~CallsGraph proc~start_benchmark benchmark3::start_benchmark timer_start timer_start proc~start_benchmark->timer_start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~start_benchmark~~CalledByGraph proc~start_benchmark benchmark3::start_benchmark program~benchmark3 benchmark3 program~benchmark3->proc~start_benchmark Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code start_benchmark Source Code subroutine start_benchmark ( ti , im , msg ) type ( timer ), intent ( out ) :: ti integer , intent ( in ) :: im character ( * ), intent ( in ) :: msg sync all if ( this_image () == im ) then print '(a)' , msg print '(a,i2)' , ' Image        :' , im call ti % timer_start () end if end subroutine start_benchmark","tags":"","loc":"proc/start_benchmark.html"},{"title":"stop_benchmark – ForMatmul","text":"subroutine stop_benchmark(ti, im, s1, s2, s3, nloops, Mat, Mat_ref, method, filename) Arguments Type Intent Optional Attributes Name type(timer), intent(inout) :: ti integer, intent(in) :: im integer, intent(in) :: s1 integer, intent(in) :: s2 integer, intent(in) :: s3 integer, intent(in) :: nloops real(kind=rk), intent(in) :: Mat (s1,s3) real(kind=rk), intent(in) :: Mat_ref (s1,s3) character(len=*), intent(in) :: method character(len=*), intent(in) :: filename Calls proc~~stop_benchmark~~CallsGraph proc~stop_benchmark benchmark3::stop_benchmark proc~write_benchmark benchmark3::write_benchmark proc~stop_benchmark->proc~write_benchmark timer_stop timer_stop proc~stop_benchmark->timer_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~stop_benchmark~~CalledByGraph proc~stop_benchmark benchmark3::stop_benchmark program~benchmark3 benchmark3 program~benchmark3->proc~stop_benchmark Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code stop_benchmark Source Code subroutine stop_benchmark ( ti , im , s1 , s2 , s3 , nloops , Mat , Mat_ref , method , filename ) type ( timer ), intent ( inout ) :: ti integer , intent ( in ) :: im integer , intent ( in ) :: s1 , s2 , s3 , nloops real ( rk ), intent ( in ) :: Mat ( s1 , s3 ), Mat_ref ( s1 , s3 ) character ( * ), intent ( in ) :: method character ( * ), intent ( in ) :: filename integer :: nunit if ( this_image () == im ) then call ti % timer_stop ( message = ' Elapsed time :' , nloops = l ) print '(a,f6.2,a)' , ' Performance  : ' , real ( nloops , rk ) * real ( s1 , rk ) * real ( s2 , rk ) * real ( s3 , rk ) * 1e-9_rk / ti % elapsed_time , ' [GFLOPS]' print '(a,3e13.6)' , ' Relative err.: ' , norm2 ( Mat_ref - Mat ) / norm2 ( Mat_ref ) print '(a)' , '' call write_benchmark ( method , s1 , s2 , s3 , nloops , ti , num_images (), filename ) end if end subroutine stop_benchmark","tags":"","loc":"proc/stop_benchmark.html"},{"title":"start_benchmark2 – ForMatmul","text":"subroutine start_benchmark2(ti, im, msg) Arguments Type Intent Optional Attributes Name type(timer), intent(out) :: ti integer, intent(in) :: im character(len=*), intent(in) :: msg Calls proc~~start_benchmark2~~CallsGraph proc~start_benchmark2 benchmark3::start_benchmark2 timer_start timer_start proc~start_benchmark2->timer_start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~start_benchmark2~~CalledByGraph proc~start_benchmark2 benchmark3::start_benchmark2 program~benchmark3 benchmark3 program~benchmark3->proc~start_benchmark2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code start_benchmark2 Source Code subroutine start_benchmark2 ( ti , im , msg ) type ( timer ), intent ( out ) :: ti integer , intent ( in ) :: im character ( * ), intent ( in ) :: msg sync all if ( this_image () == im ) then print '(a)' , msg call ti % timer_start () end if end subroutine start_benchmark2","tags":"","loc":"proc/start_benchmark2.html"},{"title":"stop_benchmark2 – ForMatmul","text":"subroutine stop_benchmark2(ti, im, s1, s2, s3, nloops, Mat, method, filename) Arguments Type Intent Optional Attributes Name type(timer), intent(inout) :: ti integer, intent(in) :: im integer, intent(in) :: s1 integer, intent(in) :: s2 integer, intent(in) :: s3 integer, intent(in) :: nloops real(kind=rk), intent(in) :: Mat (s1,s3) character(len=*), intent(in) :: method character(len=*), intent(in) :: filename Calls proc~~stop_benchmark2~~CallsGraph proc~stop_benchmark2 benchmark3::stop_benchmark2 proc~write_benchmark benchmark3::write_benchmark proc~stop_benchmark2->proc~write_benchmark timer_stop timer_stop proc~stop_benchmark2->timer_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~stop_benchmark2~~CalledByGraph proc~stop_benchmark2 benchmark3::stop_benchmark2 program~benchmark3 benchmark3 program~benchmark3->proc~stop_benchmark2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code stop_benchmark2 Source Code subroutine stop_benchmark2 ( ti , im , s1 , s2 , s3 , nloops , Mat , method , filename ) type ( timer ), intent ( inout ) :: ti integer , intent ( in ) :: im integer , intent ( in ) :: s1 , s2 , s3 , nloops real ( rk ), intent ( in ) :: Mat ( s1 , s3 ) character ( * ), intent ( in ) :: method character ( * ), intent ( in ) :: filename if ( this_image () == im ) then call ti % timer_stop ( message = ' Elapsed time :' , nloops = l ) print '(a,f6.2,a)' , ' Performance  : ' , real ( nloops , rk ) * real ( s1 , rk ) * real ( s2 , rk ) * real ( s3 , rk ) * 1e-9_rk / ti % elapsed_time , ' [GFLOPS]' print '(a)' , '' call write_benchmark ( method , s1 , s2 , s3 , nloops , ti , num_images (), filename ) end if end subroutine stop_benchmark2","tags":"","loc":"proc/stop_benchmark2.html"},{"title":"write_benchmark – ForMatmul","text":"subroutine write_benchmark(method, s1, s2, s3, nloops, ti, nimg, filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: method integer, intent(in) :: s1 integer, intent(in) :: s2 integer, intent(in) :: s3 integer, intent(in) :: nloops type(timer), intent(in) :: ti integer, intent(in) :: nimg character(len=*), intent(in) :: filename Called by proc~~write_benchmark~~CalledByGraph proc~write_benchmark benchmark3::write_benchmark proc~stop_benchmark benchmark3::stop_benchmark proc~stop_benchmark->proc~write_benchmark proc~stop_benchmark2 benchmark3::stop_benchmark2 proc~stop_benchmark2->proc~write_benchmark program~benchmark3 benchmark3 program~benchmark3->proc~stop_benchmark program~benchmark3->proc~stop_benchmark2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Source Code write_benchmark Source Code subroutine write_benchmark ( method , s1 , s2 , s3 , nloops , ti , nimg , filename ) character ( * ), intent ( in ) :: method integer , intent ( in ) :: s1 , s2 , s3 , nloops type ( timer ), intent ( in ) :: ti integer , intent ( in ) :: nimg character ( * ), intent ( in ) :: filename integer :: nunit open ( newunit = nunit , file = filename , access = 'append' ) write ( nunit , '(a,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0)' ) method , nimg , s1 , s2 , s3 , nloops , ti % elapsed_time , real ( nloops , rk ) * real ( s1 , rk ) * real ( s2 , rk ) * real ( s3 , rk ) * 1e-9_rk / ti % elapsed_time close ( nunit ) end subroutine write_benchmark","tags":"","loc":"proc/write_benchmark.html"},{"title":"formatmul_opts – ForMatmul","text":"Uses kinds module~~formatmul_opts~~UsesGraph module~formatmul_opts formatmul_opts kinds kinds module~formatmul_opts->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~formatmul_opts~~UsedByGraph module~formatmul_opts formatmul_opts module~formatmul formatmul module~formatmul->module~formatmul_opts program~benchmark1 benchmark1 program~benchmark1->module~formatmul_opts program~benchmark1->module~formatmul program~benchmark2 benchmark2 program~benchmark2->module~formatmul_opts program~benchmark2->module~formatmul program~example5 example5 program~example5->module~formatmul_opts program~example7 example7 program~example7->module~formatmul_opts program~benchmark3 benchmark3 program~benchmark3->module~formatmul program~example1 example1 program~example1->module~formatmul program~example2 example2 program~example2->module~formatmul program~example3 example3 program~example3->module~formatmul program~example4 example4 program~example4->module~formatmul program~example6 example6 program~example6->module~formatmul program~example8 example8 program~example8->module~formatmul program~mat_mat mat_mat program~mat_mat->module~formatmul program~mat_vec mat_vec program~mat_vec->module~formatmul Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Interfaces matmul_opts matmul_blas Functions matmul_mat_mat_rel_opts matmul_mat_vec_rel_opts gemm_mat_mat_rel gemv_mat_vec_rel Subroutines mm_mnp mm_mpn mm_nmp mm_npm mm_pmn mm_pnm mm_9 mm_10 mm_11 Interfaces public        interface matmul_opts private pure function matmul_mat_mat_rel_opts (A, B, option) result(C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) character(len=*), intent(in) :: option Return Value real(kind=rk), (size(A,1),size(B,2)) private pure function matmul_mat_vec_rel_opts (A, v, option) result(w) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) character(len=*), intent(in) :: option Return Value real(kind=rk), (size(A,1)) public        interface matmul_blas Interface for BLAS-based matrix multiplication functions. private pure function gemm_mat_mat_rel (A, B) result(C) Matrix-matrix multiplication using BLAS.\nauthor: Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A Input matrices A and B. real(kind=rk), intent(in), dimension(:, :), contiguous :: B Return Value real(kind=rk), dimension(size(A,1), size(B,2)) Result matrix C. private pure function gemv_mat_vec_rel (A, x) result(y) Matrix-vector multiplication using BLAS.\nauthor: Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A Input matrix A and vector x. real(kind=rk), intent(in), dimension(:), contiguous :: x Return Value real(kind=rk), dimension(size(A,1)) Result vector y. Functions private pure function matmul_mat_mat_rel_opts (A, B, option) result(C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) character(len=*), intent(in) :: option Return Value real(kind=rk), (size(A,1),size(B,2)) private pure function matmul_mat_vec_rel_opts (A, v, option) result(w) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) character(len=*), intent(in) :: option Return Value real(kind=rk), (size(A,1)) private pure function gemm_mat_mat_rel (A, B) result(C) Matrix-matrix multiplication using BLAS.\nauthor: Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A Input matrices A and B. real(kind=rk), intent(in), dimension(:, :), contiguous :: B Return Value real(kind=rk), dimension(size(A,1), size(B,2)) Result matrix C. private pure function gemv_mat_vec_rel (A, x) result(y) Matrix-vector multiplication using BLAS.\nauthor: Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A Input matrix A and vector x. real(kind=rk), intent(in), dimension(:), contiguous :: x Return Value real(kind=rk), dimension(size(A,1)) Result vector y. Subroutines private pure subroutine mm_mnp (m, n, p, a, b, c) Author @tyrandis Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: p real(kind=rk), intent(in) :: a (m,n) real(kind=rk), intent(in) :: b (n,p) real(kind=rk), intent(out) :: c (m,p) private pure subroutine mm_mpn (m, n, p, a, b, c) Author @tyrandis Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: p real(kind=rk), intent(in) :: a (m,n) real(kind=rk), intent(in) :: b (n,p) real(kind=rk), intent(out) :: c (m,p) private pure subroutine mm_nmp (m, n, p, a, b, c) Author @tyrandis Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: p real(kind=rk), intent(in) :: a (m,n) real(kind=rk), intent(in) :: b (n,p) real(kind=rk), intent(out) :: c (m,p) private pure subroutine mm_npm (m, n, p, a, b, c) Author @tyrandis Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: p real(kind=rk), intent(in) :: a (m,n) real(kind=rk), intent(in) :: b (n,p) real(kind=rk), intent(out) :: c (m,p) private pure subroutine mm_pmn (m, n, p, a, b, c) Author @tyrandis Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: p real(kind=rk), intent(in) :: a (m,n) real(kind=rk), intent(in) :: b (n,p) real(kind=rk), intent(out) :: c (m,p) private pure subroutine mm_pnm (m, n, p, a, b, c) Author @tyrandis Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: p real(kind=rk), intent(in) :: a (m,n) real(kind=rk), intent(in) :: b (n,p) real(kind=rk), intent(out) :: c (m,p) private pure subroutine mm_9 (m, n, p, a, b, c) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: p real(kind=rk), intent(in) :: a (m,n) real(kind=rk), intent(in) :: b (n,p) real(kind=rk), intent(out) :: c (m,p) private pure subroutine mm_10 (m, n, p, a, b, c) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: p real(kind=rk), intent(in) :: a (m,n) real(kind=rk), intent(in) :: b (n,p) real(kind=rk), intent(out) :: c (m,p) private pure subroutine mm_11 (m, n, p, a, b, c) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: p real(kind=rk), intent(in) :: a (m,n) real(kind=rk), intent(in) :: b (n,p) real(kind=rk), intent(out) :: c (m,p)","tags":"","loc":"module/formatmul_opts.html"},{"title":"formatmul – ForMatmul","text":"This module provides matrix and vector multiplication functions using different methods. Use the kinds module for real(kind) type. Uses formatmul_opts kinds module~~formatmul~~UsesGraph module~formatmul formatmul kinds kinds module~formatmul->kinds module~formatmul_opts formatmul_opts module~formatmul->module~formatmul_opts module~formatmul_opts->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~formatmul~~UsedByGraph module~formatmul formatmul program~benchmark1 benchmark1 program~benchmark1->module~formatmul program~benchmark2 benchmark2 program~benchmark2->module~formatmul program~benchmark3 benchmark3 program~benchmark3->module~formatmul program~example1 example1 program~example1->module~formatmul program~example2 example2 program~example2->module~formatmul program~example3 example3 program~example3->module~formatmul program~example4 example4 program~example4->module~formatmul program~example6 example6 program~example6->module~formatmul program~example8 example8 program~example8->module~formatmul program~mat_mat mat_mat program~mat_mat->module~formatmul program~mat_vec mat_vec program~mat_vec->module~formatmul Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Interfaces matmul Functions mat_mat mat_vec Subroutines calc_block_offsets Interfaces public        interface matmul Interface for matrix multiplication functions. private pure function mat_mat (A, B, method, option) result(C) Matrix-matrix multiplication using coarray parallelism.\nauthor: Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) Input matrices A and B. real(kind=rk), intent(in), contiguous :: B (:,:) Input matrices A and B. character(len=*), intent(in) :: method Multiplication method ('coarray'). character(len=*), intent(in), optional :: option Optional method-specific option. Return Value real(kind=rk), (size(A,1),size(B,2)) Result matrix C. private pure function mat_vec (A, v, method, option) result(w) Matrix-vector multiplication using coarray parallelism.\nauthor: Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) Input matrix A and vector v. real(kind=rk), intent(in), contiguous :: v (:) Input matrix A and vector v. character(len=*), intent(in) :: method Multiplication method ('coarray'). character(len=*), intent(in), optional :: option Optional method-specific option. Return Value real(kind=rk), allocatable, (:) Result vector w. Functions private pure function mat_mat (A, B, method, option) result(C) Matrix-matrix multiplication using coarray parallelism.\nauthor: Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) Input matrices A and B. real(kind=rk), intent(in), contiguous :: B (:,:) Input matrices A and B. character(len=*), intent(in) :: method Multiplication method ('coarray'). character(len=*), intent(in), optional :: option Optional method-specific option. Return Value real(kind=rk), (size(A,1),size(B,2)) Result matrix C. private pure function mat_vec (A, v, method, option) result(w) Matrix-vector multiplication using coarray parallelism.\nauthor: Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) Input matrix A and vector v. real(kind=rk), intent(in), contiguous :: v (:) Input matrix A and vector v. character(len=*), intent(in) :: method Multiplication method ('coarray'). character(len=*), intent(in), optional :: option Optional method-specific option. Return Value real(kind=rk), allocatable, (:) Result vector w. Subroutines private pure subroutine calc_block_offsets (d, nimg, block_size, offsets) Calculate block sizes and offsets.\nauthor: Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name integer, intent(in) :: d integer, intent(in) :: nimg integer, intent(out) :: block_size (nimg) integer, intent(out) :: offsets (nimg)","tags":"","loc":"module/formatmul.html"},{"title":"mat_mat – ForMatmul","text":"Uses formatmul kinds fortime program~~mat_mat~~UsesGraph program~mat_mat mat_mat fortime fortime program~mat_mat->fortime kinds kinds program~mat_mat->kinds module~formatmul formatmul program~mat_mat->module~formatmul module~formatmul->kinds module~formatmul_opts formatmul_opts module~formatmul->module~formatmul_opts module~formatmul_opts->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables A B C C_co t m n o Source Code mat_mat Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:,:) real(kind=rk), allocatable :: B (:,:) real(kind=rk), allocatable :: C (:,:) real(kind=rk), allocatable :: C_co (:,:) type(timer) :: t integer :: m integer :: n integer :: o Source Code program mat_mat use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C (:,:), C_co (:,:) type ( timer ) :: t integer :: m , n , o ! C(m,o) = A(m,n).B(n,o) m = 200 n = 100 o = 10 allocate ( A ( m , n ), B ( n , o )) call random_number ( A ) call random_number ( B ) sync all C = matmul ( A , B ) sync all C_co = matmul ( A , B , 'coarray' ) sync all if ( this_image () == 1 ) print * , 'relative error:' , norm2 ( C - C_co ) / norm2 ( C ) end program mat_mat","tags":"","loc":"program/mat_mat.html"},{"title":"mat_vec – ForMatmul","text":"Uses formatmul kinds fortime program~~mat_vec~~UsesGraph program~mat_vec mat_vec fortime fortime program~mat_vec->fortime kinds kinds program~mat_vec->kinds module~formatmul formatmul program~mat_vec->module~formatmul module~formatmul->kinds module~formatmul_opts formatmul_opts module~formatmul->module~formatmul_opts module~formatmul_opts->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables A v w w_co t m n Source Code mat_vec Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:,:) real(kind=rk), allocatable :: v (:) real(kind=rk), allocatable :: w (:) real(kind=rk), allocatable :: w_co (:) type(timer) :: t integer :: m integer :: n Source Code program mat_vec use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), v (:) real ( rk ), allocatable :: w (:), w_co (:) type ( timer ) :: t integer :: m , n ! w(m) = A(m,n).v(n) m = 200 n = 100 allocate ( A ( m , n ), v ( n )) call random_number ( A ) call random_number ( v ) w = matmul ( A , v ) sync all w_co = matmul ( A , v , 'coarray' ) sync all if ( this_image () == 1 ) print * , 'relative error:' , norm2 ( w - w_co ) / norm2 ( w ) end program mat_vec","tags":"","loc":"program/mat_vec.html"},{"title":"example8 – ForMatmul","text":"Uses formatmul kinds fortime program~~example8~~UsesGraph program~example8 example8 fortime fortime program~example8->fortime kinds kinds program~example8->kinds module~formatmul formatmul program~example8->module~formatmul module~formatmul->kinds module~formatmul_opts formatmul_opts module~formatmul->module~formatmul_opts module~formatmul_opts->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables A v w t m n Source Code example8 Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:,:) real(kind=rk), allocatable :: v (:) real(kind=rk), allocatable :: w (:) type(timer) :: t integer :: m integer :: n Source Code program example8 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), v (:) real ( rk ), allocatable :: w (:) type ( timer ) :: t integer :: m , n ! w(m) = A(m,n).v(n) m = 64 * 2 * 100 n = 16 * 2 * 100 allocate ( A ( m , n ), v ( n )) call random_number ( A ) call random_number ( v ) sync all call t % timer_start () w = matmul ( A , v , 'coarray' , option = 'm2' ) call t % timer_stop ( message = ' Elapsed time (example8: mat_vec, coarray with blas):' ) end program example8","tags":"","loc":"program/example8.html"},{"title":"benchmark2 – ForMatmul","text":"Uses formatmul_opts formatmul kinds fortime program~~benchmark2~~UsesGraph program~benchmark2 benchmark2 fortime fortime program~benchmark2->fortime kinds kinds program~benchmark2->kinds module~formatmul formatmul program~benchmark2->module~formatmul module~formatmul_opts formatmul_opts program~benchmark2->module~formatmul_opts module~formatmul->kinds module~formatmul->module~formatmul_opts module~formatmul_opts->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~benchmark2~~CallsGraph program~benchmark2 benchmark2 interface~matmul_blas formatmul_opts::matmul_blas program~benchmark2->interface~matmul_blas proc~gemm_mat_mat_rel formatmul_opts::gemm_mat_mat_rel interface~matmul_blas->proc~gemm_mat_mat_rel proc~gemv_mat_vec_rel formatmul_opts::gemv_mat_vec_rel interface~matmul_blas->proc~gemv_mat_vec_rel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables A v w t m n i l im Source Code benchmark2 Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:,:) real(kind=rk), allocatable :: v (:) real(kind=rk), allocatable :: w (:) type(timer) :: t integer :: m integer :: n integer :: i integer :: l character(len=2) :: im Source Code program benchmark2 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul use formatmul_opts , only : matmul_blas implicit none real ( rk ), allocatable :: A (:,:), v (:) real ( rk ), allocatable :: w (:) type ( timer ) :: t integer :: m , n , i , l character ( 2 ) :: im ! w(m) = A(m,n).v(n) m = 64 * 2 * 100 n = 16 * 2 * 100 l = 5 allocate ( A ( m , n ), v ( n )) call random_number ( A ) call random_number ( v ) sync all if ( this_image () == 1 ) call t % timer_start () do i = 1 , l w = matmul ( A , v ) end do if ( this_image () == 1 ) call t % timer_stop ( message = ' Elapsed time (matmul):' , nloops = l ) sync all if ( this_image () == 1 ) call t % timer_start () do i = 1 , l w = matmul_blas ( A , v ) end do if ( this_image () == 1 ) call t % timer_stop ( message = ' Elapsed time (dgemv):' , nloops = l ) sync all call t % timer_start () do i = 1 , l w = matmul ( A , v , 'coarray' , 'm1' ) end do write ( im , \"(I2)\" ) this_image () call t % timer_stop ( message = ' Elapsed time (coarray with matmul) image=' // trim ( im ) // ':' , nloops = l ) sync all call t % timer_start () do i = 1 , l w = matmul ( A , v , 'coarray' , 'm2' ) end do write ( im , \"(I2)\" ) this_image () call t % timer_stop ( message = ' Elapsed time (coarray with dgemv) image=' // trim ( im ) // ':' , nloops = l ) end program benchmark2","tags":"","loc":"program/benchmark2.html"},{"title":"example3 – ForMatmul","text":"Uses formatmul kinds fortime program~~example3~~UsesGraph program~example3 example3 fortime fortime program~example3->fortime kinds kinds program~example3->kinds module~formatmul formatmul program~example3->module~formatmul module~formatmul->kinds module~formatmul_opts formatmul_opts module~formatmul->module~formatmul_opts module~formatmul_opts->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables A v w t m n Source Code example3 Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:,:) real(kind=rk), allocatable :: v (:) real(kind=rk), allocatable :: w (:) type(timer) :: t integer :: m integer :: n Source Code program example3 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), v (:) real ( rk ), allocatable :: w (:) type ( timer ) :: t integer :: m , n ! w(m) = A(m,n).v(n) m = 64 * 2 * 100 n = 16 * 2 * 100 allocate ( A ( m , n ), v ( n )) call random_number ( A ) call random_number ( v ) sync all if ( this_image () == 1 ) call t % timer_start () w = matmul ( A , v ) if ( this_image () == 1 ) call t % timer_stop ( message = ' Elapsed time (example3: mat_vec):' ) end program example3","tags":"","loc":"program/example3.html"},{"title":"example5 – ForMatmul","text":"Uses formatmul_opts kinds fortime program~~example5~~UsesGraph program~example5 example5 fortime fortime program~example5->fortime kinds kinds program~example5->kinds module~formatmul_opts formatmul_opts program~example5->module~formatmul_opts module~formatmul_opts->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~example5~~CallsGraph program~example5 example5 interface~matmul_blas formatmul_opts::matmul_blas program~example5->interface~matmul_blas proc~gemm_mat_mat_rel formatmul_opts::gemm_mat_mat_rel interface~matmul_blas->proc~gemm_mat_mat_rel proc~gemv_mat_vec_rel formatmul_opts::gemv_mat_vec_rel interface~matmul_blas->proc~gemv_mat_vec_rel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables A B C t m n o Source Code example5 Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:,:) real(kind=rk), allocatable :: B (:,:) real(kind=rk), allocatable :: C (:,:) type(timer) :: t integer :: m integer :: n integer :: o Source Code program example5 use kinds , only : rk use fortime , only : timer use formatmul_opts , only : matmul_blas implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C (:,:) type ( timer ) :: t integer :: m , n , o ! C(m,o) = A(m,n).B(n,o) m = 64 * 2 * 100 n = 16 * 100 o = 64 * 10 allocate ( A ( m , n ), B ( n , o )) call random_number ( A ) call random_number ( B ) sync all if ( this_image () == 1 ) call t % timer_start () C = matmul_blas ( A , B ) if ( this_image () == 1 ) call t % timer_stop ( message = ' Elapsed time (example5: mat_mat with blas):' ) end program example5","tags":"","loc":"program/example5.html"},{"title":"example7 – ForMatmul","text":"Uses formatmul_opts kinds fortime program~~example7~~UsesGraph program~example7 example7 fortime fortime program~example7->fortime kinds kinds program~example7->kinds module~formatmul_opts formatmul_opts program~example7->module~formatmul_opts module~formatmul_opts->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~example7~~CallsGraph program~example7 example7 interface~matmul_blas formatmul_opts::matmul_blas program~example7->interface~matmul_blas proc~gemm_mat_mat_rel formatmul_opts::gemm_mat_mat_rel interface~matmul_blas->proc~gemm_mat_mat_rel proc~gemv_mat_vec_rel formatmul_opts::gemv_mat_vec_rel interface~matmul_blas->proc~gemv_mat_vec_rel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables A v w t m n Source Code example7 Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:,:) real(kind=rk), allocatable :: v (:) real(kind=rk), allocatable :: w (:) type(timer) :: t integer :: m integer :: n Source Code program example7 use kinds , only : rk use fortime , only : timer use formatmul_opts , only : matmul_blas implicit none real ( rk ), allocatable :: A (:,:), v (:) real ( rk ), allocatable :: w (:) type ( timer ) :: t integer :: m , n ! w(m) = A(m,n).v(n) m = 64 * 2 * 100 n = 16 * 2 * 100 allocate ( A ( m , n ), v ( n )) call random_number ( A ) call random_number ( v ) sync all if ( this_image () == 1 ) call t % timer_start () w = matmul_blas ( A , v ) if ( this_image () == 1 ) call t % timer_stop ( message = ' Elapsed time (example7: mat_vec with blas):' ) end program example7","tags":"","loc":"program/example7.html"},{"title":"benchmark1 – ForMatmul","text":"Uses formatmul_opts formatmul kinds fortime program~~benchmark1~~UsesGraph program~benchmark1 benchmark1 fortime fortime program~benchmark1->fortime kinds kinds program~benchmark1->kinds module~formatmul formatmul program~benchmark1->module~formatmul module~formatmul_opts formatmul_opts program~benchmark1->module~formatmul_opts module~formatmul->kinds module~formatmul->module~formatmul_opts module~formatmul_opts->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~benchmark1~~CallsGraph program~benchmark1 benchmark1 interface~matmul_blas formatmul_opts::matmul_blas program~benchmark1->interface~matmul_blas proc~gemm_mat_mat_rel formatmul_opts::gemm_mat_mat_rel interface~matmul_blas->proc~gemm_mat_mat_rel proc~gemv_mat_vec_rel formatmul_opts::gemv_mat_vec_rel interface~matmul_blas->proc~gemv_mat_vec_rel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables A B C t m n o i l im Source Code benchmark1 Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:,:) real(kind=rk), allocatable :: B (:,:) real(kind=rk), allocatable :: C (:,:) type(timer) :: t integer :: m integer :: n integer :: o integer :: i integer :: l character(len=2) :: im Source Code program benchmark1 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul use formatmul_opts , only : matmul_blas implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C (:,:) type ( timer ) :: t integer :: m , n , o , i , l character ( 2 ) :: im ! C(m,o) = A(m,n).B(n,o) m = 3000 n = 2000 o = 1000 l = 5 allocate ( A ( m , n ), B ( n , o )) call random_number ( A ) call random_number ( B ) sync all if ( this_image () == 1 ) call t % timer_start () do i = 1 , l C = matmul ( A , B ) end do if ( this_image () == 1 ) call t % timer_stop ( message = ' Elapsed time (matmul):' , nloops = l ) sync all if ( this_image () == 1 ) call t % timer_start () do i = 1 , l C = matmul_blas ( A , B ) end do if ( this_image () == 1 ) call t % timer_stop ( message = ' Elapsed time (dgemm):' , nloops = l ) sync all call t % timer_start () do i = 1 , l C = matmul ( A , B , 'coarray' , 'm1' ) end do write ( im , \"(I2)\" ) this_image () call t % timer_stop ( message = ' Elapsed time (coarray with matmul) image=' // trim ( im ) // ':' , nloops = l ) sync all call t % timer_start () do i = 1 , l C = matmul ( A , B , 'coarray' , 'm2' ) end do call t % timer_stop ( message = ' Elapsed time (coarray with dgemm) image=' // trim ( im ) // ':' , nloops = l ) end program benchmark1","tags":"","loc":"program/benchmark1.html"},{"title":"benchmark3 – ForMatmul","text":"Uses formatmul kinds fortime program~~benchmark3~~UsesGraph program~benchmark3 benchmark3 fortime fortime program~benchmark3->fortime kinds kinds program~benchmark3->kinds module~formatmul formatmul program~benchmark3->module~formatmul module~formatmul->kinds module~formatmul_opts formatmul_opts module~formatmul->module~formatmul_opts module~formatmul_opts->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~benchmark3~~CallsGraph program~benchmark3 benchmark3 proc~start_benchmark benchmark3::start_benchmark program~benchmark3->proc~start_benchmark proc~start_benchmark2 benchmark3::start_benchmark2 program~benchmark3->proc~start_benchmark2 proc~stop_benchmark benchmark3::stop_benchmark program~benchmark3->proc~stop_benchmark proc~stop_benchmark2 benchmark3::stop_benchmark2 program~benchmark3->proc~stop_benchmark2 timer_start timer_start proc~start_benchmark->timer_start proc~start_benchmark2->timer_start proc~write_benchmark benchmark3::write_benchmark proc~stop_benchmark->proc~write_benchmark timer_stop timer_stop proc~stop_benchmark->timer_stop proc~stop_benchmark2->proc~write_benchmark proc~stop_benchmark2->timer_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables A B C_ref C t m n o i l p unit_num file_name Subroutines start_benchmark stop_benchmark start_benchmark2 stop_benchmark2 write_benchmark Source Code benchmark3 Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:,:) real(kind=rk), allocatable :: B (:,:) real(kind=rk), allocatable :: C_ref (:,:) real(kind=rk), allocatable :: C (:,:) type(timer) :: t integer :: m integer :: n integer :: o integer :: i integer :: l integer :: p integer :: unit_num character(len=:), allocatable :: file_name Subroutines subroutine start_benchmark (ti, im, msg) Arguments Type Intent Optional Attributes Name type(timer), intent(out) :: ti integer, intent(in) :: im character(len=*), intent(in) :: msg subroutine stop_benchmark (ti, im, s1, s2, s3, nloops, Mat, Mat_ref, method, filename) Arguments Type Intent Optional Attributes Name type(timer), intent(inout) :: ti integer, intent(in) :: im integer, intent(in) :: s1 integer, intent(in) :: s2 integer, intent(in) :: s3 integer, intent(in) :: nloops real(kind=rk), intent(in) :: Mat (s1,s3) real(kind=rk), intent(in) :: Mat_ref (s1,s3) character(len=*), intent(in) :: method character(len=*), intent(in) :: filename subroutine start_benchmark2 (ti, im, msg) Arguments Type Intent Optional Attributes Name type(timer), intent(out) :: ti integer, intent(in) :: im character(len=*), intent(in) :: msg subroutine stop_benchmark2 (ti, im, s1, s2, s3, nloops, Mat, method, filename) Arguments Type Intent Optional Attributes Name type(timer), intent(inout) :: ti integer, intent(in) :: im integer, intent(in) :: s1 integer, intent(in) :: s2 integer, intent(in) :: s3 integer, intent(in) :: nloops real(kind=rk), intent(in) :: Mat (s1,s3) character(len=*), intent(in) :: method character(len=*), intent(in) :: filename subroutine write_benchmark (method, s1, s2, s3, nloops, ti, nimg, filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: method integer, intent(in) :: s1 integer, intent(in) :: s2 integer, intent(in) :: s3 integer, intent(in) :: nloops type(timer), intent(in) :: ti integer, intent(in) :: nimg character(len=*), intent(in) :: filename Source Code program benchmark3 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C_ref (:,:), C (:,:) type ( timer ) :: t integer :: m , n , o , i , l , p , unit_num character ( len = :), allocatable :: file_name ! number of loops l = 10 file_name = \"benchmark3\" open ( newunit = unit_num , file = file_name ) write ( unit_num , '(a)' ) 'Coarray Matmul Benchmark' close ( unit_num ) do p = 250 , 4000 , 250 ! C(m,o) = A(m,n).B(n,o) m = p n = p o = p if ( this_image () == 1 ) print * , '----------------------------------------' if ( this_image () == 1 ) print '(a,g0,a,g0,a,g0,a,g0,a,g0,a,g0,a)' , 'C(' , m , ',' , o , ') = A(' , m , ',' , n , ').B(' , n , ',' , o , ')' if ( this_image () == 1 ) print * , '' if ( allocated ( A )) deallocate ( A ) if ( allocated ( B )) deallocate ( B ) if ( allocated ( C )) deallocate ( C ) if ( allocated ( C_ref )) deallocate ( C_ref ) allocate ( A ( m , n )) allocate ( B ( n , o )) allocate ( C ( m , o )) allocate ( C_ref ( m , o )) call random_number ( A ) call random_number ( B ) call start_benchmark2 ( t , 1 , \"C_ref = matmul(A,B)\" ) do i = 1 , l C_ref = matmul ( A , B ) end do call stop_benchmark2 ( t , 1 , m , n , o , l , C , 'Matmul' , file_name ) call start_benchmark ( t , 1 , \"C = matmul(A,B,'coarray','m1')\" ) do i = 1 , l C = matmul ( A , B , 'coarray' , 'm1' ) end do call stop_benchmark ( t , 1 , m , n , o , l , C , C_ref , 'coarray_Matmul' , file_name ) call start_benchmark ( t , 1 , \"C = matmul(A,B,'coarray','m2')\" ) do i = 1 , l C = matmul ( A , B , 'coarray' , 'm2' ) end do call stop_benchmark ( t , 1 , m , n , o , l , C , C_ref , 'coarray_dgemm' , file_name ) call start_benchmark ( t , 1 , \"C = matmul(A,B,'coarray','m3')\" ) do i = 1 , l C = matmul ( A , B , 'coarray' , 'm3' ) end do call stop_benchmark ( t , 1 , m , n , o , l , C , C_ref , 'coarray_m3' , file_name ) call start_benchmark ( t , 1 , \"C = matmul(A,B,'coarray','m4')\" ) do i = 1 , l C = matmul ( A , B , 'coarray' , 'm4' ) end do call stop_benchmark ( t , 1 , m , n , o , l , C , C_ref , 'coarray_m4' , file_name ) call start_benchmark ( t , 1 , \"C = matmul(A,B,'coarray','m5')\" ) do i = 1 , l C = matmul ( A , B , 'coarray' , 'm5' ) end do call stop_benchmark ( t , 1 , m , n , o , l , C , C_ref , 'coarray_m5' , file_name ) call start_benchmark ( t , 1 , \"C = matmul(A,B,'coarray','m6')\" ) do i = 1 , l C = matmul ( A , B , 'coarray' , 'm6' ) end do call stop_benchmark ( t , 1 , m , n , o , l , C , C_ref , 'coarray_m6' , file_name ) call start_benchmark ( t , 1 , \"C = matmul(A,B,'coarray','m7')\" ) do i = 1 , l C = matmul ( A , B , 'coarray' , 'm7' ) end do call stop_benchmark ( t , 1 , m , n , o , l , C , C_ref , 'coarray_m7' , file_name ) call start_benchmark ( t , 1 , \"C = matmul(A,B,'coarray','m8')\" ) do i = 1 , l C = matmul ( A , B , 'coarray' , 'm8' ) end do call stop_benchmark ( t , 1 , m , n , o , l , C , C_ref , 'coarray_m8' , file_name ) call start_benchmark ( t , 1 , \"C = matmul(A,B,'coarray','m9')\" ) do i = 1 , l C = matmul ( A , B , 'coarray' , 'm9' ) end do call stop_benchmark ( t , 1 , m , n , o , l , C , C_ref , 'coarray_m9' , file_name ) call start_benchmark ( t , 1 , \"C = matmul(A,B,'coarray','m10')\" ) do i = 1 , l C = matmul ( A , B , 'coarray' , 'm10' ) end do call stop_benchmark ( t , 1 , m , n , o , l , C , C_ref , 'coarray_m10' , file_name ) call start_benchmark ( t , 1 , \"C = matmul(A,B,'coarray','m11')\" ) do i = 1 , l C = matmul ( A , B , 'coarray' , 'm11' ) end do call stop_benchmark ( t , 1 , m , n , o , l , C , C_ref , 'coarray_m11' , file_name ) end do contains subroutine start_benchmark ( ti , im , msg ) type ( timer ), intent ( out ) :: ti integer , intent ( in ) :: im character ( * ), intent ( in ) :: msg sync all if ( this_image () == im ) then print '(a)' , msg print '(a,i2)' , ' Image        :' , im call ti % timer_start () end if end subroutine start_benchmark subroutine stop_benchmark ( ti , im , s1 , s2 , s3 , nloops , Mat , Mat_ref , method , filename ) type ( timer ), intent ( inout ) :: ti integer , intent ( in ) :: im integer , intent ( in ) :: s1 , s2 , s3 , nloops real ( rk ), intent ( in ) :: Mat ( s1 , s3 ), Mat_ref ( s1 , s3 ) character ( * ), intent ( in ) :: method character ( * ), intent ( in ) :: filename integer :: nunit if ( this_image () == im ) then call ti % timer_stop ( message = ' Elapsed time :' , nloops = l ) print '(a,f6.2,a)' , ' Performance  : ' , real ( nloops , rk ) * real ( s1 , rk ) * real ( s2 , rk ) * real ( s3 , rk ) * 1e-9_rk / ti % elapsed_time , ' [GFLOPS]' print '(a,3e13.6)' , ' Relative err.: ' , norm2 ( Mat_ref - Mat ) / norm2 ( Mat_ref ) print '(a)' , '' call write_benchmark ( method , s1 , s2 , s3 , nloops , ti , num_images (), filename ) end if end subroutine stop_benchmark subroutine start_benchmark2 ( ti , im , msg ) type ( timer ), intent ( out ) :: ti integer , intent ( in ) :: im character ( * ), intent ( in ) :: msg sync all if ( this_image () == im ) then print '(a)' , msg call ti % timer_start () end if end subroutine start_benchmark2 subroutine stop_benchmark2 ( ti , im , s1 , s2 , s3 , nloops , Mat , method , filename ) type ( timer ), intent ( inout ) :: ti integer , intent ( in ) :: im integer , intent ( in ) :: s1 , s2 , s3 , nloops real ( rk ), intent ( in ) :: Mat ( s1 , s3 ) character ( * ), intent ( in ) :: method character ( * ), intent ( in ) :: filename if ( this_image () == im ) then call ti % timer_stop ( message = ' Elapsed time :' , nloops = l ) print '(a,f6.2,a)' , ' Performance  : ' , real ( nloops , rk ) * real ( s1 , rk ) * real ( s2 , rk ) * real ( s3 , rk ) * 1e-9_rk / ti % elapsed_time , ' [GFLOPS]' print '(a)' , '' call write_benchmark ( method , s1 , s2 , s3 , nloops , ti , num_images (), filename ) end if end subroutine stop_benchmark2 subroutine write_benchmark ( method , s1 , s2 , s3 , nloops , ti , nimg , filename ) character ( * ), intent ( in ) :: method integer , intent ( in ) :: s1 , s2 , s3 , nloops type ( timer ), intent ( in ) :: ti integer , intent ( in ) :: nimg character ( * ), intent ( in ) :: filename integer :: nunit open ( newunit = nunit , file = filename , access = 'append' ) write ( nunit , '(a,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0)' ) method , nimg , s1 , s2 , s3 , nloops , ti % elapsed_time , real ( nloops , rk ) * real ( s1 , rk ) * real ( s2 , rk ) * real ( s3 , rk ) * 1e-9_rk / ti % elapsed_time close ( nunit ) end subroutine write_benchmark end program benchmark3","tags":"","loc":"program/benchmark3.html"},{"title":"example2 – ForMatmul","text":"Uses formatmul kinds fortime program~~example2~~UsesGraph program~example2 example2 fortime fortime program~example2->fortime kinds kinds program~example2->kinds module~formatmul formatmul program~example2->module~formatmul module~formatmul->kinds module~formatmul_opts formatmul_opts module~formatmul->module~formatmul_opts module~formatmul_opts->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables A B C t m n o Source Code example2 Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:,:) real(kind=rk), allocatable :: B (:,:) real(kind=rk), allocatable :: C (:,:) type(timer) :: t integer :: m integer :: n integer :: o Source Code program example2 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C (:,:) type ( timer ) :: t integer :: m , n , o ! C(m,o) = A(m,n).B(n,o) m = 64 * 2 * 100 n = 16 * 100 o = 64 * 10 allocate ( A ( m , n ), B ( n , o )) call random_number ( A ) call random_number ( B ) sync all call t % timer_start () C = matmul ( A , B , 'coarray' ) call t % timer_stop ( message = ' Elapsed time (example2: mat_mat, coarray):' ) end program example2","tags":"","loc":"program/example2.html"},{"title":"example4 – ForMatmul","text":"Uses formatmul kinds fortime program~~example4~~UsesGraph program~example4 example4 fortime fortime program~example4->fortime kinds kinds program~example4->kinds module~formatmul formatmul program~example4->module~formatmul module~formatmul->kinds module~formatmul_opts formatmul_opts module~formatmul->module~formatmul_opts module~formatmul_opts->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables A v w t m n Source Code example4 Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:,:) real(kind=rk), allocatable :: v (:) real(kind=rk), allocatable :: w (:) type(timer) :: t integer :: m integer :: n Source Code program example4 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), v (:) real ( rk ), allocatable :: w (:) type ( timer ) :: t integer :: m , n ! w(m) = A(m,n).v(n) m = 64 * 2 * 100 n = 16 * 2 * 100 allocate ( A ( m , n ), v ( n )) call random_number ( A ) call random_number ( v ) sync all call t % timer_start () w = matmul ( A , v , 'coarray' ) call t % timer_stop ( message = ' Elapsed time (example4: mat_vec, coarray):' ) end program example4","tags":"","loc":"program/example4.html"},{"title":"example6 – ForMatmul","text":"Uses formatmul kinds fortime program~~example6~~UsesGraph program~example6 example6 fortime fortime program~example6->fortime kinds kinds program~example6->kinds module~formatmul formatmul program~example6->module~formatmul module~formatmul->kinds module~formatmul_opts formatmul_opts module~formatmul->module~formatmul_opts module~formatmul_opts->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables A B C t m n o Source Code example6 Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:,:) real(kind=rk), allocatable :: B (:,:) real(kind=rk), allocatable :: C (:,:) type(timer) :: t integer :: m integer :: n integer :: o Source Code program example6 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C (:,:) type ( timer ) :: t integer :: m , n , o ! C(m,o) = A(m,n).B(n,o) m = 64 * 2 * 100 n = 16 * 100 o = 64 * 10 allocate ( A ( m , n ), B ( n , o )) call random_number ( A ) call random_number ( B ) sync all call t % timer_start () C = matmul ( A , B , 'coarray' , option = 'm2' ) call t % timer_stop ( message = ' Elapsed time (example6: mat_mat, coarray with blas):' ) end program example6","tags":"","loc":"program/example6.html"},{"title":"example1 – ForMatmul","text":"Uses formatmul kinds fortime program~~example1~~UsesGraph program~example1 example1 fortime fortime program~example1->fortime kinds kinds program~example1->kinds module~formatmul formatmul program~example1->module~formatmul module~formatmul->kinds module~formatmul_opts formatmul_opts module~formatmul->module~formatmul_opts module~formatmul_opts->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Variables A B C t m n o Source Code example1 Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:,:) real(kind=rk), allocatable :: B (:,:) real(kind=rk), allocatable :: C (:,:) type(timer) :: t integer :: m integer :: n integer :: o Source Code program example1 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C (:,:) type ( timer ) :: t integer :: m , n , o ! C(m,o) = A(m,n).B(n,o) m = 64 * 2 * 100 n = 16 * 100 o = 64 * 10 allocate ( A ( m , n ), B ( n , o )) call random_number ( A ) call random_number ( B ) sync all if ( this_image () == 1 ) call t % timer_start () C = matmul ( A , B ) if ( this_image () == 1 ) call t % timer_stop ( message = ' Elapsed time (example1: mat_mat):' ) end program example1","tags":"","loc":"program/example1.html"},{"title":"formatmul_opts.f90 – ForMatmul","text":"Files dependent on this one sourcefile~~formatmul_opts.f90~~AfferentGraph sourcefile~formatmul_opts.f90 formatmul_opts.f90 sourcefile~benchmark1.f90 benchmark1.f90 sourcefile~benchmark1.f90->sourcefile~formatmul_opts.f90 sourcefile~formatmul.f90 formatmul.f90 sourcefile~benchmark1.f90->sourcefile~formatmul.f90 sourcefile~benchmark2.f90 benchmark2.f90 sourcefile~benchmark2.f90->sourcefile~formatmul_opts.f90 sourcefile~benchmark2.f90->sourcefile~formatmul.f90 sourcefile~example5.f90 example5.f90 sourcefile~example5.f90->sourcefile~formatmul_opts.f90 sourcefile~example7.f90 example7.f90 sourcefile~example7.f90->sourcefile~formatmul_opts.f90 sourcefile~formatmul.f90->sourcefile~formatmul_opts.f90 sourcefile~benchmark3.f90 benchmark3.f90 sourcefile~benchmark3.f90->sourcefile~formatmul.f90 sourcefile~example1.f90 example1.f90 sourcefile~example1.f90->sourcefile~formatmul.f90 sourcefile~example2.f90 example2.f90 sourcefile~example2.f90->sourcefile~formatmul.f90 sourcefile~example3.f90 example3.f90 sourcefile~example3.f90->sourcefile~formatmul.f90 sourcefile~example4.f90 example4.f90 sourcefile~example4.f90->sourcefile~formatmul.f90 sourcefile~example6.f90 example6.f90 sourcefile~example6.f90->sourcefile~formatmul.f90 sourcefile~example8.f90 example8.f90 sourcefile~example8.f90->sourcefile~formatmul.f90 sourcefile~test1.f90 test1.f90 sourcefile~test1.f90->sourcefile~formatmul.f90 sourcefile~test2.f90 test2.f90 sourcefile~test2.f90->sourcefile~formatmul.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Modules formatmul_opts Source Code formatmul_opts.f90 Source Code module formatmul_opts use kinds , only : rk implicit none private public :: matmul_opts , matmul_blas interface matmul_opts procedure :: matmul_mat_mat_rel_opts procedure :: matmul_mat_vec_rel_opts end interface !> Interface for BLAS-based matrix multiplication functions. interface matmul_blas procedure :: gemm_mat_mat_rel procedure :: gemv_mat_vec_rel end interface contains pure function matmul_mat_mat_rel_opts ( A , B , option ) result ( C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) character ( * ), intent ( in ) :: option real ( rk ) :: C ( size ( A , 1 ), size ( B , 2 )) integer :: m , n , k select case ( option ) case ( 'm1' ) C = matmul ( A , B ) case ( 'm2' ) C = matmul_blas ( A , B ) case ( 'm3' ) m = size ( A , 1 ) n = size ( B , 2 ) k = size ( B , 1 ) call mm_mnp ( m , k , n , a , b , c ) case ( 'm4' ) m = size ( A , 1 ) n = size ( B , 2 ) k = size ( B , 1 ) call mm_mpn ( m , k , n , a , b , c ) case ( 'm5' ) m = size ( A , 1 ) n = size ( B , 2 ) k = size ( B , 1 ) call mm_nmp ( m , k , n , a , b , c ) case ( 'm6' ) m = size ( A , 1 ) n = size ( B , 2 ) k = size ( B , 1 ) call mm_npm ( m , k , n , a , b , c ) case ( 'm7' ) m = size ( A , 1 ) n = size ( B , 2 ) k = size ( B , 1 ) call mm_pmn ( m , k , n , a , b , c ) case ( 'm8' ) m = size ( A , 1 ) n = size ( B , 2 ) k = size ( B , 1 ) call mm_pnm ( m , k , n , a , b , c ) case ( 'm9' ) m = size ( A , 1 ) n = size ( B , 2 ) k = size ( B , 1 ) call mm_9 ( m , k , n , a , b , c ) case ( 'm10' ) m = size ( A , 1 ) n = size ( B , 2 ) k = size ( B , 1 ) call mm_10 ( m , k , n , a , b , c ) case ( 'm11' ) m = size ( A , 1 ) n = size ( B , 2 ) k = size ( B , 1 ) call mm_11 ( m , k , n , a , b , c ) case default C = matmul ( A , B ) end select end function matmul_mat_mat_rel_opts pure function matmul_mat_vec_rel_opts ( A , v , option ) result ( w ) real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) character ( * ), intent ( in ) :: option real ( rk ) :: w ( size ( A , 1 )) select case ( option ) case ( 'm1' ) w = matmul ( A , v ) case ( 'm2' ) w = matmul_blas ( A , v ) case default w = matmul ( A , v ) end select end function matmul_mat_vec_rel_opts !> Matrix-matrix multiplication using BLAS. !> author: Seyed Ali Ghasemi pure function gemm_mat_mat_rel ( A , B ) result ( C ) !> Input matrices A and B. real ( rk ), dimension (:, :), contiguous , intent ( in ) :: A real ( rk ), dimension (:, :), contiguous , intent ( in ) :: B !> Result matrix C. real ( rk ), dimension ( size ( A , 1 ), size ( B , 2 )) :: C ! real(rk), dimension(:,:), allocatable             :: C integer :: m , n , k interface !> BLAS subroutine for matrix-matrix multiplication. pure subroutine dgemm ( f_transa , f_transb , f_m , f_n , f_k , f_alpha , f_a , f_lda , f_b , f_ldb , f_beta , f_c , f_ldc ) import rk integer , intent ( in ) :: f_ldc integer , intent ( in ) :: f_ldb integer , intent ( in ) :: f_lda character , intent ( in ) :: f_transa character , intent ( in ) :: f_transb integer , intent ( in ) :: f_m integer , intent ( in ) :: f_n integer , intent ( in ) :: f_k real ( rk ), intent ( in ) :: f_alpha real ( rk ), intent ( in ) :: f_a ( f_lda , * ) real ( rk ), intent ( in ) :: f_b ( f_ldb , * ) real ( rk ), intent ( in ) :: f_beta real ( rk ), intent ( inout ) :: f_c ( f_ldc , * ) end subroutine dgemm end interface m = size ( A , 1 ) n = size ( B , 2 ) k = size ( A , 2 ) C = 0.0_rk ! Call BLAS dgemm subroutine for matrix-matrix multiplication. call dgemm ( 'N' , 'N' , m , n , k , 1.0_rk , A , m , B , k , 0.0_rk , C , m ) end function gemm_mat_mat_rel !> Matrix-vector multiplication using BLAS. !> author: Seyed Ali Ghasemi pure function gemv_mat_vec_rel ( A , x ) result ( y ) !> Input matrix A and vector x. real ( rk ), dimension (:, :), contiguous , intent ( in ) :: A real ( rk ), dimension (:), contiguous , intent ( in ) :: x !> Result vector y. real ( rk ), dimension ( size ( A , 1 )) :: y ! real(rk), dimension(:), allocatable               :: y integer :: m , n interface !> BLAS subroutine for matrix-vector multiplication. pure subroutine dgemv ( f_trans , f_m , f_n , f_alpha , f_a , f_lda , f_x , f_incx , f_beta , f_y , f_incy ) import rk integer , intent ( in ) :: f_m integer , intent ( in ) :: f_n integer , intent ( in ) :: f_lda character , intent ( in ) :: f_trans real ( rk ), intent ( in ) :: f_alpha real ( rk ), intent ( in ) :: f_a ( f_lda , * ) real ( rk ), intent ( in ) :: f_x ( * ) integer , intent ( in ) :: f_incx real ( rk ), intent ( in ) :: f_beta real ( rk ), intent ( inout ) :: f_y ( * ) integer , intent ( in ) :: f_incy end subroutine dgemv end interface m = size ( A , 1 ) n = size ( A , 2 ) y = 0.0_rk ! Call BLAS dgemv subroutine for matrix-vector multiplication. call dgemv ( 'N' , m , n , 1.0_rk , A , m , x , 1 , 0.0_rk , y , 1 ) end function gemv_mat_vec_rel !> author: @tyrandis pure subroutine mm_mnp ( m , n , p , a , b , c ) integer , intent ( in ) :: m , n , p real ( rk ), intent ( in ) :: a ( m , n ), b ( n , p ) real ( rk ), intent ( out ) :: c ( m , p ) integer :: i , j , k c = 0.0_rk do i = 1 , m do j = 1 , n do k = 1 , p c ( i , k ) = c ( i , k ) + a ( i , j ) * b ( j , k ) end do end do end do end subroutine mm_mnp !> author: @tyrandis pure subroutine mm_mpn ( m , n , p , a , b , c ) integer , intent ( in ) :: m , n , p real ( rk ), intent ( in ) :: a ( m , n ), b ( n , p ) real ( rk ), intent ( out ) :: c ( m , p ) integer :: i , j , k c = 0.0_rk do i = 1 , m do j = 1 , p do k = 1 , n c ( i , j ) = c ( i , j ) + a ( i , k ) * b ( k , j ) end do end do end do end subroutine mm_mpn !> author: @tyrandis pure subroutine mm_nmp ( m , n , p , a , b , c ) integer , intent ( in ) :: m , n , p real ( rk ), intent ( in ) :: a ( m , n ), b ( n , p ) real ( rk ), intent ( out ) :: c ( m , p ) integer :: i , j , k c = 0.0_rk do i = 1 , n do j = 1 , m do k = 1 , p c ( j , k ) = c ( j , k ) + a ( j , i ) * b ( i , k ) end do end do end do end subroutine mm_nmp !> author: @tyrandis pure subroutine mm_npm ( m , n , p , a , b , c ) integer , intent ( in ) :: m , n , p real ( rk ), intent ( in ) :: a ( m , n ), b ( n , p ) real ( rk ), intent ( out ) :: c ( m , p ) integer :: i , j , k c = 0.0_rk do i = 1 , n do j = 1 , p do k = 1 , m c ( k , j ) = c ( k , j ) + a ( k , i ) * b ( i , j ) end do end do end do end subroutine mm_npm !> author: @tyrandis pure subroutine mm_pmn ( m , n , p , a , b , c ) integer , intent ( in ) :: m , n , p real ( rk ), intent ( in ) :: a ( m , n ), b ( n , p ) real ( rk ), intent ( out ) :: c ( m , p ) integer :: i , j , k c = 0.0_rk do i = 1 , p do j = 1 , m do k = 1 , n c ( j , i ) = c ( j , i ) + a ( j , k ) * b ( k , i ) end do end do end do end subroutine mm_pmn !> author: @tyrandis pure subroutine mm_pnm ( m , n , p , a , b , c ) integer , intent ( in ) :: m , n , p real ( rk ), intent ( in ) :: a ( m , n ), b ( n , p ) real ( rk ), intent ( out ) :: c ( m , p ) integer :: i , j , k c = 0.0_rk do i = 1 , p do j = 1 , n do k = 1 , m c ( k , i ) = c ( k , i ) + a ( k , j ) * b ( j , i ) end do end do end do end subroutine mm_pnm !> author: Seyed Ali Ghasemi pure subroutine mm_9 ( m , n , p , a , b , c ) integer , intent ( in ) :: m , n , p real ( rk ), intent ( in ) :: a ( m , n ), b ( n , p ) real ( rk ), intent ( out ) :: c ( m , p ) integer :: i , j , k c = 0.0_rk do i = 1 , p do k = 1 , m c ( k , i ) = dot_product ( a ( k ,:), b (:, i )) end do end do end subroutine mm_9 !> author: Seyed Ali Ghasemi pure subroutine mm_10 ( m , n , p , a , b , c ) integer , intent ( in ) :: m , n , p real ( rk ), intent ( in ) :: a ( m , n ), b ( n , p ) real ( rk ), intent ( out ) :: c ( m , p ) integer :: i , j , k c = 0.0_rk do concurrent ( i = 1 : p ) do k = 1 , m c ( k , i ) = dot_product ( a ( k ,:), b (:, i )) end do end do end subroutine mm_10 !> author: Seyed Ali Ghasemi pure subroutine mm_11 ( m , n , p , a , b , c ) integer , intent ( in ) :: m , n , p real ( rk ), intent ( in ) :: a ( m , n ), b ( n , p ) real ( rk ), intent ( out ) :: c ( m , p ) integer :: i , j , k c = 0.0_rk do concurrent ( i = 1 : p ) do j = 1 , n do k = 1 , m c ( k , i ) = c ( k , i ) + a ( k , j ) * b ( j , i ) end do end do end do end subroutine mm_11 end module formatmul_opts","tags":"","loc":"sourcefile/formatmul_opts.f90.html"},{"title":"formatmul.f90 – ForMatmul","text":"This file depends on sourcefile~~formatmul.f90~~EfferentGraph sourcefile~formatmul.f90 formatmul.f90 sourcefile~formatmul_opts.f90 formatmul_opts.f90 sourcefile~formatmul.f90->sourcefile~formatmul_opts.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~formatmul.f90~~AfferentGraph sourcefile~formatmul.f90 formatmul.f90 sourcefile~benchmark1.f90 benchmark1.f90 sourcefile~benchmark1.f90->sourcefile~formatmul.f90 sourcefile~benchmark2.f90 benchmark2.f90 sourcefile~benchmark2.f90->sourcefile~formatmul.f90 sourcefile~benchmark3.f90 benchmark3.f90 sourcefile~benchmark3.f90->sourcefile~formatmul.f90 sourcefile~example1.f90 example1.f90 sourcefile~example1.f90->sourcefile~formatmul.f90 sourcefile~example2.f90 example2.f90 sourcefile~example2.f90->sourcefile~formatmul.f90 sourcefile~example3.f90 example3.f90 sourcefile~example3.f90->sourcefile~formatmul.f90 sourcefile~example4.f90 example4.f90 sourcefile~example4.f90->sourcefile~formatmul.f90 sourcefile~example6.f90 example6.f90 sourcefile~example6.f90->sourcefile~formatmul.f90 sourcefile~example8.f90 example8.f90 sourcefile~example8.f90->sourcefile~formatmul.f90 sourcefile~test1.f90 test1.f90 sourcefile~test1.f90->sourcefile~formatmul.f90 sourcefile~test2.f90 test2.f90 sourcefile~test2.f90->sourcefile~formatmul.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Modules formatmul Source Code formatmul.f90 Source Code !> Module: formatmul !! This module provides matrix and vector multiplication functions using different methods. module formatmul !> Use the kinds module for real(kind) type. use kinds use formatmul_opts implicit none private public matmul !> Interface for matrix multiplication functions. interface matmul procedure :: mat_mat procedure :: mat_vec end interface contains !> Matrix-matrix multiplication using coarray parallelism. !> author: Seyed Ali Ghasemi pure function mat_mat ( A , B , method , option ) result ( C ) !> Input matrices A and B. real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) !> Multiplication method ('coarray'). character ( * ), intent ( in ) :: method !> Optional method-specific option. character ( * ), intent ( in ), optional :: option !> Result matrix C. ! real(rk), allocatable                :: C(:,:) real ( rk ) :: C ( size ( A , 1 ), size ( B , 2 )) if ( method == 'coarray' ) then ! Coarray-based parallel multiplication. if ( size ( A , 1 ) >= size ( B , 2 )) then ! Handle A's columns > B's rows. block integer :: i , m , n , o , im , nimg , base_value , remainder integer :: block_size ( num_images ()) integer :: offsets ( num_images ()) real ( rk ), allocatable :: C_block (:,:)[:], A_block (:,:)[:] im = this_image () nimg = num_images () m = size ( A , 1 ) o = size ( B , 2 ) n = size ( A , 2 ) call calc_block_offsets ( m , nimg , block_size , offsets ) allocate ( A_block ( block_size ( im ), n )[ * ]) allocate ( C_block ( block_size ( im ), o )[ * ]) A_block (:,:)[ im ] = A ( offsets ( im ) : offsets ( im ) + block_size ( im ) - 1 , :) C_block (:,:)[ im ] = matmul_opts ( A_block (:,:)[ im ], B , option ) sync all if ( im == 1 ) then do i = 1 , nimg C ( offsets ( i ) : offsets ( i ) + block_size ( i ) - 1 , :) = C_block (:,:)[ i ] end do end if end block else ! Handle B's columns > A's rows. block integer :: i , m , n , o , im , nimg , base_value , remainder integer :: block_size ( num_images ()) integer :: offsets ( num_images ()) real ( rk ), allocatable :: C_block (:,:)[:], B_block (:,:)[:] im = this_image () nimg = num_images () m = size ( A , 1 ) o = size ( B , 2 ) n = size ( A , 2 ) call calc_block_offsets ( o , nimg , block_size , offsets ) allocate ( B_block ( n , block_size ( im ))[ * ]) allocate ( C_block ( m , block_size ( im ))[ * ]) B_block (:,:)[ im ] = B (:, offsets ( im ) : offsets ( im ) + block_size ( im ) - 1 ) C_block (:,:)[ im ] = matmul_opts ( A , B_block (:,:)[ im ], option ) sync all if ( im == 1 ) then do i = 1 , nimg C (:, offsets ( i ) : offsets ( i ) + block_size ( i ) - 1 ) = C_block (:,:)[ i ] end do end if end block end if else ! Unsupported multiplication method. error stop 'Error: The specified method is not available for matrix-matrix multiplication!' ! if (this_image() == 1) then !    ! if (.not. allocated(C)) allocate(C(m, o)) !    C = matmul(A, B) ! end if end if end function mat_mat !> Matrix-vector multiplication using coarray parallelism. !> author: Seyed Ali Ghasemi pure function mat_vec ( A , v , method , option ) result ( w ) !> Input matrix A and vector v. real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) !> Multiplication method ('coarray'). character ( * ), intent ( in ) :: method !> Optional method-specific option. character ( * ), intent ( in ), optional :: option !> Result vector w. real ( rk ), allocatable :: w (:) if ( method == 'coarray' ) then ! Coarray-based parallel multiplication. block integer :: i , block_size , n , im , nimg real ( rk ), allocatable :: w_block (:)[:] integer :: m , remainder_m im = this_image () nimg = num_images () m = size ( A , 1 ) n = size ( A , 2 ) block_size = m / nimg remainder_m = m - block_size * ( nimg - 1 ) if ( mod ( m , nimg ) == 0 ) then if (. not . allocated ( w_block )) allocate ( w_block ( block_size )[ * ]) w_block (:) = matmul_opts ( A (( im - 1 ) * block_size + 1 : im * block_size , 1 : n ), v , option ) else if (. not . allocated ( w_block )) allocate ( w_block ( remainder_m )[ * ]) w_block (:) = matmul_opts ( A (( im - 1 ) * block_size + 1 : im * block_size + remainder_m , 1 : n ), v , option ) end if sync all ! critical if ( im == 1 ) then if (. not . allocated ( w )) allocate ( w ( m )) do i = 1 , nimg - 1 w (( i - 1 ) * block_size + 1 : i * block_size ) = w_block (:)[ i ] end do w (( nimg - 1 ) * block_size + 1 : m ) = w_block (:)[ nimg ] end if ! end critical end block else ! Unsupported multiplication method. error stop 'Error: The specified method is not available for matrix-vector multiplication!' ! if (this_image() == 1) then !    ! if (.not. allocated(w)) allocate(w(m)) !    w = matmul(A, v) ! end if end if end function mat_vec !> Calculate block sizes and offsets. !> author: Seyed Ali Ghasemi pure subroutine calc_block_offsets ( d , nimg , block_size , offsets ) integer , intent ( in ) :: d , nimg integer , intent ( out ) :: block_size ( nimg ), offsets ( nimg ) integer :: i , base_value , remainder base_value = d / nimg remainder = d - base_value * nimg block_size ( 1 : nimg ) = base_value if ( remainder > 0 ) block_size ( 1 : remainder ) = base_value + 1 offsets = [( sum ( block_size ( 1 : i - 1 )) + 1 , i = 1 , nimg )] end subroutine calc_block_offsets end module formatmul","tags":"","loc":"sourcefile/formatmul.f90.html"},{"title":"test1.f90 – ForMatmul","text":"This file depends on sourcefile~~test1.f90~~EfferentGraph sourcefile~test1.f90 test1.f90 sourcefile~formatmul.f90 formatmul.f90 sourcefile~test1.f90->sourcefile~formatmul.f90 sourcefile~formatmul_opts.f90 formatmul_opts.f90 sourcefile~formatmul.f90->sourcefile~formatmul_opts.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Programs mat_mat Source Code test1.f90 Source Code program mat_mat use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C (:,:), C_co (:,:) type ( timer ) :: t integer :: m , n , o ! C(m,o) = A(m,n).B(n,o) m = 200 n = 100 o = 10 allocate ( A ( m , n ), B ( n , o )) call random_number ( A ) call random_number ( B ) sync all C = matmul ( A , B ) sync all C_co = matmul ( A , B , 'coarray' ) sync all if ( this_image () == 1 ) print * , 'relative error:' , norm2 ( C - C_co ) / norm2 ( C ) end program mat_mat","tags":"","loc":"sourcefile/test1.f90.html"},{"title":"test2.f90 – ForMatmul","text":"This file depends on sourcefile~~test2.f90~~EfferentGraph sourcefile~test2.f90 test2.f90 sourcefile~formatmul.f90 formatmul.f90 sourcefile~test2.f90->sourcefile~formatmul.f90 sourcefile~formatmul_opts.f90 formatmul_opts.f90 sourcefile~formatmul.f90->sourcefile~formatmul_opts.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Programs mat_vec Source Code test2.f90 Source Code program mat_vec use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), v (:) real ( rk ), allocatable :: w (:), w_co (:) type ( timer ) :: t integer :: m , n ! w(m) = A(m,n).v(n) m = 200 n = 100 allocate ( A ( m , n ), v ( n )) call random_number ( A ) call random_number ( v ) w = matmul ( A , v ) sync all w_co = matmul ( A , v , 'coarray' ) sync all if ( this_image () == 1 ) print * , 'relative error:' , norm2 ( w - w_co ) / norm2 ( w ) end program mat_vec","tags":"","loc":"sourcefile/test2.f90.html"},{"title":"example8.f90 – ForMatmul","text":"This file depends on sourcefile~~example8.f90~~EfferentGraph sourcefile~example8.f90 example8.f90 sourcefile~formatmul.f90 formatmul.f90 sourcefile~example8.f90->sourcefile~formatmul.f90 sourcefile~formatmul_opts.f90 formatmul_opts.f90 sourcefile~formatmul.f90->sourcefile~formatmul_opts.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Programs example8 Source Code example8.f90 Source Code program example8 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), v (:) real ( rk ), allocatable :: w (:) type ( timer ) :: t integer :: m , n ! w(m) = A(m,n).v(n) m = 64 * 2 * 100 n = 16 * 2 * 100 allocate ( A ( m , n ), v ( n )) call random_number ( A ) call random_number ( v ) sync all call t % timer_start () w = matmul ( A , v , 'coarray' , option = 'm2' ) call t % timer_stop ( message = ' Elapsed time (example8: mat_vec, coarray with blas):' ) end program example8","tags":"","loc":"sourcefile/example8.f90.html"},{"title":"benchmark2.f90 – ForMatmul","text":"This file depends on sourcefile~~benchmark2.f90~~EfferentGraph sourcefile~benchmark2.f90 benchmark2.f90 sourcefile~formatmul.f90 formatmul.f90 sourcefile~benchmark2.f90->sourcefile~formatmul.f90 sourcefile~formatmul_opts.f90 formatmul_opts.f90 sourcefile~benchmark2.f90->sourcefile~formatmul_opts.f90 sourcefile~formatmul.f90->sourcefile~formatmul_opts.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Programs benchmark2 Source Code benchmark2.f90 Source Code program benchmark2 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul use formatmul_opts , only : matmul_blas implicit none real ( rk ), allocatable :: A (:,:), v (:) real ( rk ), allocatable :: w (:) type ( timer ) :: t integer :: m , n , i , l character ( 2 ) :: im ! w(m) = A(m,n).v(n) m = 64 * 2 * 100 n = 16 * 2 * 100 l = 5 allocate ( A ( m , n ), v ( n )) call random_number ( A ) call random_number ( v ) sync all if ( this_image () == 1 ) call t % timer_start () do i = 1 , l w = matmul ( A , v ) end do if ( this_image () == 1 ) call t % timer_stop ( message = ' Elapsed time (matmul):' , nloops = l ) sync all if ( this_image () == 1 ) call t % timer_start () do i = 1 , l w = matmul_blas ( A , v ) end do if ( this_image () == 1 ) call t % timer_stop ( message = ' Elapsed time (dgemv):' , nloops = l ) sync all call t % timer_start () do i = 1 , l w = matmul ( A , v , 'coarray' , 'm1' ) end do write ( im , \"(I2)\" ) this_image () call t % timer_stop ( message = ' Elapsed time (coarray with matmul) image=' // trim ( im ) // ':' , nloops = l ) sync all call t % timer_start () do i = 1 , l w = matmul ( A , v , 'coarray' , 'm2' ) end do write ( im , \"(I2)\" ) this_image () call t % timer_stop ( message = ' Elapsed time (coarray with dgemv) image=' // trim ( im ) // ':' , nloops = l ) end program benchmark2","tags":"","loc":"sourcefile/benchmark2.f90.html"},{"title":"example3.f90 – ForMatmul","text":"This file depends on sourcefile~~example3.f90~~EfferentGraph sourcefile~example3.f90 example3.f90 sourcefile~formatmul.f90 formatmul.f90 sourcefile~example3.f90->sourcefile~formatmul.f90 sourcefile~formatmul_opts.f90 formatmul_opts.f90 sourcefile~formatmul.f90->sourcefile~formatmul_opts.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Programs example3 Source Code example3.f90 Source Code program example3 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), v (:) real ( rk ), allocatable :: w (:) type ( timer ) :: t integer :: m , n ! w(m) = A(m,n).v(n) m = 64 * 2 * 100 n = 16 * 2 * 100 allocate ( A ( m , n ), v ( n )) call random_number ( A ) call random_number ( v ) sync all if ( this_image () == 1 ) call t % timer_start () w = matmul ( A , v ) if ( this_image () == 1 ) call t % timer_stop ( message = ' Elapsed time (example3: mat_vec):' ) end program example3","tags":"","loc":"sourcefile/example3.f90.html"},{"title":"example5.f90 – ForMatmul","text":"This file depends on sourcefile~~example5.f90~~EfferentGraph sourcefile~example5.f90 example5.f90 sourcefile~formatmul_opts.f90 formatmul_opts.f90 sourcefile~example5.f90->sourcefile~formatmul_opts.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Programs example5 Source Code example5.f90 Source Code program example5 use kinds , only : rk use fortime , only : timer use formatmul_opts , only : matmul_blas implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C (:,:) type ( timer ) :: t integer :: m , n , o ! C(m,o) = A(m,n).B(n,o) m = 64 * 2 * 100 n = 16 * 100 o = 64 * 10 allocate ( A ( m , n ), B ( n , o )) call random_number ( A ) call random_number ( B ) sync all if ( this_image () == 1 ) call t % timer_start () C = matmul_blas ( A , B ) if ( this_image () == 1 ) call t % timer_stop ( message = ' Elapsed time (example5: mat_mat with blas):' ) end program example5","tags":"","loc":"sourcefile/example5.f90.html"},{"title":"example7.f90 – ForMatmul","text":"This file depends on sourcefile~~example7.f90~~EfferentGraph sourcefile~example7.f90 example7.f90 sourcefile~formatmul_opts.f90 formatmul_opts.f90 sourcefile~example7.f90->sourcefile~formatmul_opts.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Programs example7 Source Code example7.f90 Source Code program example7 use kinds , only : rk use fortime , only : timer use formatmul_opts , only : matmul_blas implicit none real ( rk ), allocatable :: A (:,:), v (:) real ( rk ), allocatable :: w (:) type ( timer ) :: t integer :: m , n ! w(m) = A(m,n).v(n) m = 64 * 2 * 100 n = 16 * 2 * 100 allocate ( A ( m , n ), v ( n )) call random_number ( A ) call random_number ( v ) sync all if ( this_image () == 1 ) call t % timer_start () w = matmul_blas ( A , v ) if ( this_image () == 1 ) call t % timer_stop ( message = ' Elapsed time (example7: mat_vec with blas):' ) end program example7","tags":"","loc":"sourcefile/example7.f90.html"},{"title":"benchmark1.f90 – ForMatmul","text":"This file depends on sourcefile~~benchmark1.f90~~EfferentGraph sourcefile~benchmark1.f90 benchmark1.f90 sourcefile~formatmul.f90 formatmul.f90 sourcefile~benchmark1.f90->sourcefile~formatmul.f90 sourcefile~formatmul_opts.f90 formatmul_opts.f90 sourcefile~benchmark1.f90->sourcefile~formatmul_opts.f90 sourcefile~formatmul.f90->sourcefile~formatmul_opts.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Programs benchmark1 Source Code benchmark1.f90 Source Code program benchmark1 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul use formatmul_opts , only : matmul_blas implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C (:,:) type ( timer ) :: t integer :: m , n , o , i , l character ( 2 ) :: im ! C(m,o) = A(m,n).B(n,o) m = 3000 n = 2000 o = 1000 l = 5 allocate ( A ( m , n ), B ( n , o )) call random_number ( A ) call random_number ( B ) sync all if ( this_image () == 1 ) call t % timer_start () do i = 1 , l C = matmul ( A , B ) end do if ( this_image () == 1 ) call t % timer_stop ( message = ' Elapsed time (matmul):' , nloops = l ) sync all if ( this_image () == 1 ) call t % timer_start () do i = 1 , l C = matmul_blas ( A , B ) end do if ( this_image () == 1 ) call t % timer_stop ( message = ' Elapsed time (dgemm):' , nloops = l ) sync all call t % timer_start () do i = 1 , l C = matmul ( A , B , 'coarray' , 'm1' ) end do write ( im , \"(I2)\" ) this_image () call t % timer_stop ( message = ' Elapsed time (coarray with matmul) image=' // trim ( im ) // ':' , nloops = l ) sync all call t % timer_start () do i = 1 , l C = matmul ( A , B , 'coarray' , 'm2' ) end do call t % timer_stop ( message = ' Elapsed time (coarray with dgemm) image=' // trim ( im ) // ':' , nloops = l ) end program benchmark1","tags":"","loc":"sourcefile/benchmark1.f90.html"},{"title":"benchmark3.f90 – ForMatmul","text":"This file depends on sourcefile~~benchmark3.f90~~EfferentGraph sourcefile~benchmark3.f90 benchmark3.f90 sourcefile~formatmul.f90 formatmul.f90 sourcefile~benchmark3.f90->sourcefile~formatmul.f90 sourcefile~formatmul_opts.f90 formatmul_opts.f90 sourcefile~formatmul.f90->sourcefile~formatmul_opts.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Programs benchmark3 Source Code benchmark3.f90 Source Code program benchmark3 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C_ref (:,:), C (:,:) type ( timer ) :: t integer :: m , n , o , i , l , p , unit_num character ( len = :), allocatable :: file_name ! number of loops l = 10 file_name = \"benchmark3\" open ( newunit = unit_num , file = file_name ) write ( unit_num , '(a)' ) 'Coarray Matmul Benchmark' close ( unit_num ) do p = 250 , 4000 , 250 ! C(m,o) = A(m,n).B(n,o) m = p n = p o = p if ( this_image () == 1 ) print * , '----------------------------------------' if ( this_image () == 1 ) print '(a,g0,a,g0,a,g0,a,g0,a,g0,a,g0,a)' , 'C(' , m , ',' , o , ') = A(' , m , ',' , n , ').B(' , n , ',' , o , ')' if ( this_image () == 1 ) print * , '' if ( allocated ( A )) deallocate ( A ) if ( allocated ( B )) deallocate ( B ) if ( allocated ( C )) deallocate ( C ) if ( allocated ( C_ref )) deallocate ( C_ref ) allocate ( A ( m , n )) allocate ( B ( n , o )) allocate ( C ( m , o )) allocate ( C_ref ( m , o )) call random_number ( A ) call random_number ( B ) call start_benchmark2 ( t , 1 , \"C_ref = matmul(A,B)\" ) do i = 1 , l C_ref = matmul ( A , B ) end do call stop_benchmark2 ( t , 1 , m , n , o , l , C , 'Matmul' , file_name ) call start_benchmark ( t , 1 , \"C = matmul(A,B,'coarray','m1')\" ) do i = 1 , l C = matmul ( A , B , 'coarray' , 'm1' ) end do call stop_benchmark ( t , 1 , m , n , o , l , C , C_ref , 'coarray_Matmul' , file_name ) call start_benchmark ( t , 1 , \"C = matmul(A,B,'coarray','m2')\" ) do i = 1 , l C = matmul ( A , B , 'coarray' , 'm2' ) end do call stop_benchmark ( t , 1 , m , n , o , l , C , C_ref , 'coarray_dgemm' , file_name ) call start_benchmark ( t , 1 , \"C = matmul(A,B,'coarray','m3')\" ) do i = 1 , l C = matmul ( A , B , 'coarray' , 'm3' ) end do call stop_benchmark ( t , 1 , m , n , o , l , C , C_ref , 'coarray_m3' , file_name ) call start_benchmark ( t , 1 , \"C = matmul(A,B,'coarray','m4')\" ) do i = 1 , l C = matmul ( A , B , 'coarray' , 'm4' ) end do call stop_benchmark ( t , 1 , m , n , o , l , C , C_ref , 'coarray_m4' , file_name ) call start_benchmark ( t , 1 , \"C = matmul(A,B,'coarray','m5')\" ) do i = 1 , l C = matmul ( A , B , 'coarray' , 'm5' ) end do call stop_benchmark ( t , 1 , m , n , o , l , C , C_ref , 'coarray_m5' , file_name ) call start_benchmark ( t , 1 , \"C = matmul(A,B,'coarray','m6')\" ) do i = 1 , l C = matmul ( A , B , 'coarray' , 'm6' ) end do call stop_benchmark ( t , 1 , m , n , o , l , C , C_ref , 'coarray_m6' , file_name ) call start_benchmark ( t , 1 , \"C = matmul(A,B,'coarray','m7')\" ) do i = 1 , l C = matmul ( A , B , 'coarray' , 'm7' ) end do call stop_benchmark ( t , 1 , m , n , o , l , C , C_ref , 'coarray_m7' , file_name ) call start_benchmark ( t , 1 , \"C = matmul(A,B,'coarray','m8')\" ) do i = 1 , l C = matmul ( A , B , 'coarray' , 'm8' ) end do call stop_benchmark ( t , 1 , m , n , o , l , C , C_ref , 'coarray_m8' , file_name ) call start_benchmark ( t , 1 , \"C = matmul(A,B,'coarray','m9')\" ) do i = 1 , l C = matmul ( A , B , 'coarray' , 'm9' ) end do call stop_benchmark ( t , 1 , m , n , o , l , C , C_ref , 'coarray_m9' , file_name ) call start_benchmark ( t , 1 , \"C = matmul(A,B,'coarray','m10')\" ) do i = 1 , l C = matmul ( A , B , 'coarray' , 'm10' ) end do call stop_benchmark ( t , 1 , m , n , o , l , C , C_ref , 'coarray_m10' , file_name ) call start_benchmark ( t , 1 , \"C = matmul(A,B,'coarray','m11')\" ) do i = 1 , l C = matmul ( A , B , 'coarray' , 'm11' ) end do call stop_benchmark ( t , 1 , m , n , o , l , C , C_ref , 'coarray_m11' , file_name ) end do contains subroutine start_benchmark ( ti , im , msg ) type ( timer ), intent ( out ) :: ti integer , intent ( in ) :: im character ( * ), intent ( in ) :: msg sync all if ( this_image () == im ) then print '(a)' , msg print '(a,i2)' , ' Image        :' , im call ti % timer_start () end if end subroutine start_benchmark subroutine stop_benchmark ( ti , im , s1 , s2 , s3 , nloops , Mat , Mat_ref , method , filename ) type ( timer ), intent ( inout ) :: ti integer , intent ( in ) :: im integer , intent ( in ) :: s1 , s2 , s3 , nloops real ( rk ), intent ( in ) :: Mat ( s1 , s3 ), Mat_ref ( s1 , s3 ) character ( * ), intent ( in ) :: method character ( * ), intent ( in ) :: filename integer :: nunit if ( this_image () == im ) then call ti % timer_stop ( message = ' Elapsed time :' , nloops = l ) print '(a,f6.2,a)' , ' Performance  : ' , real ( nloops , rk ) * real ( s1 , rk ) * real ( s2 , rk ) * real ( s3 , rk ) * 1e-9_rk / ti % elapsed_time , ' [GFLOPS]' print '(a,3e13.6)' , ' Relative err.: ' , norm2 ( Mat_ref - Mat ) / norm2 ( Mat_ref ) print '(a)' , '' call write_benchmark ( method , s1 , s2 , s3 , nloops , ti , num_images (), filename ) end if end subroutine stop_benchmark subroutine start_benchmark2 ( ti , im , msg ) type ( timer ), intent ( out ) :: ti integer , intent ( in ) :: im character ( * ), intent ( in ) :: msg sync all if ( this_image () == im ) then print '(a)' , msg call ti % timer_start () end if end subroutine start_benchmark2 subroutine stop_benchmark2 ( ti , im , s1 , s2 , s3 , nloops , Mat , method , filename ) type ( timer ), intent ( inout ) :: ti integer , intent ( in ) :: im integer , intent ( in ) :: s1 , s2 , s3 , nloops real ( rk ), intent ( in ) :: Mat ( s1 , s3 ) character ( * ), intent ( in ) :: method character ( * ), intent ( in ) :: filename if ( this_image () == im ) then call ti % timer_stop ( message = ' Elapsed time :' , nloops = l ) print '(a,f6.2,a)' , ' Performance  : ' , real ( nloops , rk ) * real ( s1 , rk ) * real ( s2 , rk ) * real ( s3 , rk ) * 1e-9_rk / ti % elapsed_time , ' [GFLOPS]' print '(a)' , '' call write_benchmark ( method , s1 , s2 , s3 , nloops , ti , num_images (), filename ) end if end subroutine stop_benchmark2 subroutine write_benchmark ( method , s1 , s2 , s3 , nloops , ti , nimg , filename ) character ( * ), intent ( in ) :: method integer , intent ( in ) :: s1 , s2 , s3 , nloops type ( timer ), intent ( in ) :: ti integer , intent ( in ) :: nimg character ( * ), intent ( in ) :: filename integer :: nunit open ( newunit = nunit , file = filename , access = 'append' ) write ( nunit , '(a,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0,\" \",g0)' ) method , nimg , s1 , s2 , s3 , nloops , ti % elapsed_time , real ( nloops , rk ) * real ( s1 , rk ) * real ( s2 , rk ) * real ( s3 , rk ) * 1e-9_rk / ti % elapsed_time close ( nunit ) end subroutine write_benchmark end program benchmark3","tags":"","loc":"sourcefile/benchmark3.f90.html"},{"title":"example2.f90 – ForMatmul","text":"This file depends on sourcefile~~example2.f90~~EfferentGraph sourcefile~example2.f90 example2.f90 sourcefile~formatmul.f90 formatmul.f90 sourcefile~example2.f90->sourcefile~formatmul.f90 sourcefile~formatmul_opts.f90 formatmul_opts.f90 sourcefile~formatmul.f90->sourcefile~formatmul_opts.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Programs example2 Source Code example2.f90 Source Code program example2 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C (:,:) type ( timer ) :: t integer :: m , n , o ! C(m,o) = A(m,n).B(n,o) m = 64 * 2 * 100 n = 16 * 100 o = 64 * 10 allocate ( A ( m , n ), B ( n , o )) call random_number ( A ) call random_number ( B ) sync all call t % timer_start () C = matmul ( A , B , 'coarray' ) call t % timer_stop ( message = ' Elapsed time (example2: mat_mat, coarray):' ) end program example2","tags":"","loc":"sourcefile/example2.f90.html"},{"title":"example4.f90 – ForMatmul","text":"This file depends on sourcefile~~example4.f90~~EfferentGraph sourcefile~example4.f90 example4.f90 sourcefile~formatmul.f90 formatmul.f90 sourcefile~example4.f90->sourcefile~formatmul.f90 sourcefile~formatmul_opts.f90 formatmul_opts.f90 sourcefile~formatmul.f90->sourcefile~formatmul_opts.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Programs example4 Source Code example4.f90 Source Code program example4 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), v (:) real ( rk ), allocatable :: w (:) type ( timer ) :: t integer :: m , n ! w(m) = A(m,n).v(n) m = 64 * 2 * 100 n = 16 * 2 * 100 allocate ( A ( m , n ), v ( n )) call random_number ( A ) call random_number ( v ) sync all call t % timer_start () w = matmul ( A , v , 'coarray' ) call t % timer_stop ( message = ' Elapsed time (example4: mat_vec, coarray):' ) end program example4","tags":"","loc":"sourcefile/example4.f90.html"},{"title":"example6.f90 – ForMatmul","text":"This file depends on sourcefile~~example6.f90~~EfferentGraph sourcefile~example6.f90 example6.f90 sourcefile~formatmul.f90 formatmul.f90 sourcefile~example6.f90->sourcefile~formatmul.f90 sourcefile~formatmul_opts.f90 formatmul_opts.f90 sourcefile~formatmul.f90->sourcefile~formatmul_opts.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Programs example6 Source Code example6.f90 Source Code program example6 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C (:,:) type ( timer ) :: t integer :: m , n , o ! C(m,o) = A(m,n).B(n,o) m = 64 * 2 * 100 n = 16 * 100 o = 64 * 10 allocate ( A ( m , n ), B ( n , o )) call random_number ( A ) call random_number ( B ) sync all call t % timer_start () C = matmul ( A , B , 'coarray' , option = 'm2' ) call t % timer_stop ( message = ' Elapsed time (example6: mat_mat, coarray with blas):' ) end program example6","tags":"","loc":"sourcefile/example6.f90.html"},{"title":"example1.f90 – ForMatmul","text":"This file depends on sourcefile~~example1.f90~~EfferentGraph sourcefile~example1.f90 example1.f90 sourcefile~formatmul.f90 formatmul.f90 sourcefile~example1.f90->sourcefile~formatmul.f90 sourcefile~formatmul_opts.f90 formatmul_opts.f90 sourcefile~formatmul.f90->sourcefile~formatmul_opts.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Contents Programs example1 Source Code example1.f90 Source Code program example1 use kinds , only : rk use fortime , only : timer use formatmul , only : matmul implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C (:,:) type ( timer ) :: t integer :: m , n , o ! C(m,o) = A(m,n).B(n,o) m = 64 * 2 * 100 n = 16 * 100 o = 64 * 10 allocate ( A ( m , n ), B ( n , o )) call random_number ( A ) call random_number ( B ) sync all if ( this_image () == 1 ) call t % timer_start () C = matmul ( A , B ) if ( this_image () == 1 ) call t % timer_stop ( message = ' Elapsed time (example1: mat_mat):' ) end program example1","tags":"","loc":"sourcefile/example1.f90.html"}]}