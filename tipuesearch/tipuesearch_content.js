var tipuesearch = {"pages":[{"title":" ForMatmul ","text":"ForMatmul ForMatmul : A Fortran library that overloads the matmul function to enable efficient matrix multiplication with/without coarray. Usage use formatmul c = matmul ( a , b , option = 'm1' , transA = . true ., transB = . true ., coarray = . true .) fpm dependency If you want to use ForMatmul as a dependency in your own fpm project,\nyou can easily include it by adding the following line to your fpm.toml file: [dependencies] formatmul = { git = \"https://github.com/gha3mi/formatmul.git\" } How to run tests Clone the repository: You can clone the ForMatmul repository from GitHub using the following command: git clone https://github.com/gha3mi/formatmul.git cd formatmul Tested with Intel compiler: ifort (IFORT) 2021.10.0 20230609 fpm @ifort-test fpm @ifort-test-coarray Tested with Intel compiler: ifx (IFX) 2023.2.0 20230622 fpm @ifx-test fpm @ifx-test-coarray Tested with NVIDIA compiler: nvfortran 23.11-0 64-bit target on x86-64 Linux fpm @nvfortran-test Benchmarks You can find benchmark results on ForBenchmark . API documentation The most up-to-date API documentation for the master branch is available here .\nTo generate the API documentation for ForMatmul using ford run the following\ncommand: ford ford.yml Contributing Contributions to ForMatmul are welcome!\nIf you find any issues or would like to suggest improvements, please open an issue. Developer Info Seyed Ali Ghasemi","tags":"home","loc":"index.html"},{"title":"impure_mm_AB_12 – ForMatmul","text":"impure subroutine impure_mm_AB_12(a, b, c) Uses kinds proc~~impure_mm_ab_12~~UsesGraph proc~impure_mm_ab_12 formatmul_opts.f90::impure_mm_AB_12 kinds kinds proc~impure_mm_ab_12->kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: a (:,:) real(kind=rk), intent(in) :: b (:,:) real(kind=rk), intent(inout) :: c (:,:) Source Code pure subroutine impure_mm_AB_12 ( f_a , f_b , f_c ) import rk real ( rk ), intent ( in ) :: f_a (:,:), f_b (:,:) real ( rk ), intent ( inout ) :: f_c (:,:) end subroutine impure_mm_AB_12","tags":"","loc":"proc/impure_mm_ab_12.html"},{"title":"impure_mm_AB_13 – ForMatmul","text":"impure subroutine impure_mm_AB_13(a, b, c) Uses kinds proc~~impure_mm_ab_13~~UsesGraph proc~impure_mm_ab_13 formatmul_opts.f90::impure_mm_AB_13 kinds kinds proc~impure_mm_ab_13->kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: a (:,:) real(kind=rk), intent(in) :: b (:,:) real(kind=rk), intent(inout) :: c (:,:) Source Code pure subroutine impure_mm_AB_13 ( f_a , f_b , f_c ) import rk real ( rk ), intent ( in ) :: f_a (:,:), f_b (:,:) real ( rk ), intent ( inout ) :: f_c (:,:) end subroutine impure_mm_AB_13","tags":"","loc":"proc/impure_mm_ab_13.html"},{"title":"impure_mm_ATB_12 – ForMatmul","text":"impure subroutine impure_mm_ATB_12(a, b, c) Uses kinds proc~~impure_mm_atb_12~~UsesGraph proc~impure_mm_atb_12 formatmul_opts.f90::impure_mm_ATB_12 kinds kinds proc~impure_mm_atb_12->kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: a (:,:) real(kind=rk), intent(in) :: b (:,:) real(kind=rk), intent(inout) :: c (:,:) Source Code pure subroutine impure_mm_ATB_12 ( f_a , f_b , f_c ) import rk real ( rk ), intent ( in ) :: f_a (:,:), f_b (:,:) real ( rk ), intent ( inout ) :: f_c (:,:) end subroutine impure_mm_ATB_12","tags":"","loc":"proc/impure_mm_atb_12.html"},{"title":"impure_mm_ATB_13 – ForMatmul","text":"impure subroutine impure_mm_ATB_13(a, b, c) Uses kinds proc~~impure_mm_atb_13~~UsesGraph proc~impure_mm_atb_13 formatmul_opts.f90::impure_mm_ATB_13 kinds kinds proc~impure_mm_atb_13->kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: a (:,:) real(kind=rk), intent(in) :: b (:,:) real(kind=rk), intent(inout) :: c (:,:) Source Code pure subroutine impure_mm_ATB_13 ( f_a , f_b , f_c ) import rk real ( rk ), intent ( in ) :: f_a (:,:), f_b (:,:) real ( rk ), intent ( inout ) :: f_c (:,:) end subroutine impure_mm_ATB_13","tags":"","loc":"proc/impure_mm_atb_13.html"},{"title":"impure_mm_ABT_12 – ForMatmul","text":"impure subroutine impure_mm_ABT_12(a, b, c) Uses kinds proc~~impure_mm_abt_12~~UsesGraph proc~impure_mm_abt_12 formatmul_opts.f90::impure_mm_ABT_12 kinds kinds proc~impure_mm_abt_12->kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: a (:,:) real(kind=rk), intent(in) :: b (:,:) real(kind=rk), intent(inout) :: c (:,:) Source Code pure subroutine impure_mm_ABT_12 ( f_a , f_b , f_c ) import rk real ( rk ), intent ( in ) :: f_a (:,:), f_b (:,:) real ( rk ), intent ( inout ) :: f_c (:,:) end subroutine impure_mm_ABT_12","tags":"","loc":"proc/impure_mm_abt_12.html"},{"title":"impure_mm_ABT_13 – ForMatmul","text":"impure subroutine impure_mm_ABT_13(a, b, c) Uses kinds proc~~impure_mm_abt_13~~UsesGraph proc~impure_mm_abt_13 formatmul_opts.f90::impure_mm_ABT_13 kinds kinds proc~impure_mm_abt_13->kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: a (:,:) real(kind=rk), intent(in) :: b (:,:) real(kind=rk), intent(inout) :: c (:,:) Source Code pure subroutine impure_mm_ABT_13 ( f_a , f_b , f_c ) import rk real ( rk ), intent ( in ) :: f_a (:,:), f_b (:,:) real ( rk ), intent ( inout ) :: f_c (:,:) end subroutine impure_mm_ABT_13","tags":"","loc":"proc/impure_mm_abt_13.html"},{"title":"impure_mm_ATBT_12 – ForMatmul","text":"impure subroutine impure_mm_ATBT_12(a, b, c) Uses kinds proc~~impure_mm_atbt_12~~UsesGraph proc~impure_mm_atbt_12 formatmul_opts.f90::impure_mm_ATBT_12 kinds kinds proc~impure_mm_atbt_12->kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: a (:,:) real(kind=rk), intent(in) :: b (:,:) real(kind=rk), intent(inout) :: c (:,:) Source Code pure subroutine impure_mm_ATBT_12 ( f_a , f_b , f_c ) import rk real ( rk ), intent ( in ) :: f_a (:,:), f_b (:,:) real ( rk ), intent ( inout ) :: f_c (:,:) end subroutine impure_mm_ATBT_12","tags":"","loc":"proc/impure_mm_atbt_12.html"},{"title":"impure_mm_ATBT_13 – ForMatmul","text":"impure subroutine impure_mm_ATBT_13(a, b, c) Uses kinds proc~~impure_mm_atbt_13~~UsesGraph proc~impure_mm_atbt_13 formatmul_opts.f90::impure_mm_ATBT_13 kinds kinds proc~impure_mm_atbt_13->kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: a (:,:) real(kind=rk), intent(in) :: b (:,:) real(kind=rk), intent(inout) :: c (:,:) Source Code pure subroutine impure_mm_ATBT_13 ( f_a , f_b , f_c ) import rk real ( rk ), intent ( in ) :: f_a (:,:), f_b (:,:) real ( rk ), intent ( inout ) :: f_c (:,:) end subroutine impure_mm_ATBT_13","tags":"","loc":"proc/impure_mm_atbt_13.html"},{"title":"gemm – ForMatmul","text":"public interface gemm Called by interface~~gemm~~CalledByGraph interface~gemm external_interfaces_matmul::gemm proc~mm_ab_2 formatmul_opts::mm_AB_2 proc~mm_ab_2->interface~gemm proc~mm_abt_2 formatmul_opts::mm_ABT_2 proc~mm_abt_2->interface~gemm proc~mm_atb_2 formatmul_opts::mm_ATB_2 proc~mm_atb_2->interface~gemm proc~mm_atbt_2 formatmul_opts::mm_ATBT_2 proc~mm_atbt_2->interface~gemm proc~mat_mat_rel_ab_opt formatmul_opts::mat_mat_rel_AB_opt proc~mat_mat_rel_ab_opt->proc~mm_ab_2 proc~mat_mat_rel_abt_opt formatmul_opts::mat_mat_rel_ABT_opt proc~mat_mat_rel_abt_opt->proc~mm_abt_2 proc~mat_mat_rel_atb_opt formatmul_opts::mat_mat_rel_ATB_opt proc~mat_mat_rel_atb_opt->proc~mm_atb_2 proc~mat_mat_rel_atbt_opt formatmul_opts::mat_mat_rel_ATBT_opt proc~mat_mat_rel_atbt_opt->proc~mm_atbt_2 proc~mat_mat_rel_ab formatmul::mat_mat_rel_AB proc~mat_mat_rel_ab->proc~mat_mat_rel_ab_opt proc~mat_mat_rel_abt formatmul::mat_mat_rel_ABT proc~mat_mat_rel_abt->proc~mat_mat_rel_abt_opt proc~mat_mat_rel_atb formatmul::mat_mat_rel_ATB proc~mat_mat_rel_atb->proc~mat_mat_rel_atb_opt proc~mat_mat_rel_atbt formatmul::mat_mat_rel_ATBT proc~mat_mat_rel_atbt->proc~mat_mat_rel_atbt_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_ab proc~mat_mat_rel->proc~mat_mat_rel_abt proc~mat_mat_rel->proc~mat_mat_rel_atb proc~mat_mat_rel->proc~mat_mat_rel_atbt interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public pure subroutine dgemm(f_transa, f_transb, f_m, f_n, f_k, f_alpha, f_a, f_lda, f_b, f_ldb, f_beta, f_c, f_ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: f_transa character(len=1), intent(in) :: f_transb integer, intent(in) :: f_m integer, intent(in) :: f_n integer, intent(in) :: f_k real(kind=rk), intent(in) :: f_alpha real(kind=rk), intent(in) :: f_a (f_lda,*) integer, intent(in) :: f_lda real(kind=rk), intent(in) :: f_b (f_ldb,*) integer, intent(in) :: f_ldb real(kind=rk), intent(in) :: f_beta real(kind=rk), intent(inout) :: f_c (f_ldc,*) integer, intent(in) :: f_ldc public pure subroutine sgemm(f_transa, f_transb, f_m, f_n, f_k, f_alpha, f_a, f_lda, f_b, f_ldb, f_beta, f_c, f_ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: f_transa character(len=1), intent(in) :: f_transb integer, intent(in) :: f_m integer, intent(in) :: f_n integer, intent(in) :: f_k real(kind=rk), intent(in) :: f_alpha real(kind=rk), intent(in) :: f_a (f_lda,*) integer, intent(in) :: f_lda real(kind=rk), intent(in) :: f_b (f_ldb,*) integer, intent(in) :: f_ldb real(kind=rk), intent(in) :: f_beta real(kind=rk), intent(inout) :: f_c (f_ldc,*) integer, intent(in) :: f_ldc public pure subroutine dgemm(f_transa, f_transb, f_m, f_n, f_k, f_alpha, f_a, f_lda, f_b, f_ldb, f_beta, f_c, f_ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: f_transa character(len=1), intent(in) :: f_transb integer, intent(in) :: f_m integer, intent(in) :: f_n integer, intent(in) :: f_k real(kind=rk), intent(in) :: f_alpha real(kind=rk), intent(in) :: f_a (f_lda,*) integer, intent(in) :: f_lda real(kind=rk), intent(in) :: f_b (f_ldb,*) integer, intent(in) :: f_ldb real(kind=rk), intent(in) :: f_beta real(kind=rk), intent(inout) :: f_c (f_ldc,*) integer, intent(in) :: f_ldc","tags":"","loc":"interface/gemm.html"},{"title":"gemv – ForMatmul","text":"public interface gemv Called by interface~~gemv~~CalledByGraph interface~gemv external_interfaces_matmul::gemv proc~mv_atv_2 formatmul_opts::mv_ATv_2 proc~mv_atv_2->interface~gemv proc~mv_av_2 formatmul_opts::mv_Av_2 proc~mv_av_2->interface~gemv proc~mat_vec_rel_atv_opt formatmul_opts::mat_vec_rel_ATv_opt proc~mat_vec_rel_atv_opt->proc~mv_atv_2 proc~mat_vec_rel_av_opt formatmul_opts::mat_vec_rel_Av_opt proc~mat_vec_rel_av_opt->proc~mv_av_2 proc~mat_vec_rel_atv formatmul::mat_vec_rel_ATv proc~mat_vec_rel_atv->proc~mat_vec_rel_atv_opt proc~mat_vec_rel_av formatmul::mat_vec_rel_Av proc~mat_vec_rel_av->proc~mat_vec_rel_av_opt proc~mat_vec_rel formatmul::mat_vec_rel proc~mat_vec_rel->proc~mat_vec_rel_atv proc~mat_vec_rel->proc~mat_vec_rel_av interface~matmul formatmul::matmul interface~matmul->proc~mat_vec_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public pure subroutine dgemv(f_trans, f_m, f_n, f_alpha, f_a, f_lda, f_x, f_incx, f_beta, f_y, f_incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: f_trans integer, intent(in) :: f_m integer, intent(in) :: f_n real(kind=rk), intent(in) :: f_alpha real(kind=rk), intent(in) :: f_a (f_lda,*) integer, intent(in) :: f_lda real(kind=rk), intent(in) :: f_x (*) integer, intent(in) :: f_incx real(kind=rk), intent(in) :: f_beta real(kind=rk), intent(inout) :: f_y (*) integer, intent(in) :: f_incy public pure subroutine sgemv(f_trans, f_m, f_n, f_alpha, f_a, f_lda, f_x, f_incx, f_beta, f_y, f_incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: f_trans integer, intent(in) :: f_m integer, intent(in) :: f_n real(kind=rk), intent(in) :: f_alpha real(kind=rk), intent(in) :: f_a (f_lda,*) integer, intent(in) :: f_lda real(kind=rk), intent(in) :: f_x (*) integer, intent(in) :: f_incx real(kind=rk), intent(in) :: f_beta real(kind=rk), intent(inout) :: f_y (*) integer, intent(in) :: f_incy public pure subroutine dgemv(f_trans, f_m, f_n, f_alpha, f_a, f_lda, f_x, f_incx, f_beta, f_y, f_incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: f_trans integer, intent(in) :: f_m integer, intent(in) :: f_n real(kind=rk), intent(in) :: f_alpha real(kind=rk), intent(in) :: f_a (f_lda,*) integer, intent(in) :: f_lda real(kind=rk), intent(in) :: f_x (*) integer, intent(in) :: f_incx real(kind=rk), intent(in) :: f_beta real(kind=rk), intent(inout) :: f_y (*) integer, intent(in) :: f_incy","tags":"","loc":"interface/gemv.html"},{"title":"mat_mat_rel_AB_opt – ForMatmul","text":"public pure subroutine mat_mat_rel_AB_opt(A, B, C, option) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) character(len=*), intent(in) :: option Calls proc~~mat_mat_rel_ab_opt~~CallsGraph proc~mat_mat_rel_ab_opt formatmul_opts::mat_mat_rel_AB_opt proc~mm_ab_1 formatmul_opts::mm_AB_1 proc~mat_mat_rel_ab_opt->proc~mm_ab_1 proc~mm_ab_10 formatmul_opts::mm_AB_10 proc~mat_mat_rel_ab_opt->proc~mm_ab_10 proc~mm_ab_11 formatmul_opts::mm_AB_11 proc~mat_mat_rel_ab_opt->proc~mm_ab_11 proc~mm_ab_12 formatmul_opts::mm_AB_12 proc~mat_mat_rel_ab_opt->proc~mm_ab_12 proc~mm_ab_13 formatmul_opts::mm_AB_13 proc~mat_mat_rel_ab_opt->proc~mm_ab_13 proc~mm_ab_2 formatmul_opts::mm_AB_2 proc~mat_mat_rel_ab_opt->proc~mm_ab_2 proc~mm_ab_3 formatmul_opts::mm_AB_3 proc~mat_mat_rel_ab_opt->proc~mm_ab_3 proc~mm_ab_4 formatmul_opts::mm_AB_4 proc~mat_mat_rel_ab_opt->proc~mm_ab_4 proc~mm_ab_5 formatmul_opts::mm_AB_5 proc~mat_mat_rel_ab_opt->proc~mm_ab_5 proc~mm_ab_6 formatmul_opts::mm_AB_6 proc~mat_mat_rel_ab_opt->proc~mm_ab_6 proc~mm_ab_7 formatmul_opts::mm_AB_7 proc~mat_mat_rel_ab_opt->proc~mm_ab_7 proc~mm_ab_8 formatmul_opts::mm_AB_8 proc~mat_mat_rel_ab_opt->proc~mm_ab_8 proc~mm_ab_9 formatmul_opts::mm_AB_9 proc~mat_mat_rel_ab_opt->proc~mm_ab_9 interface~gemm external_interfaces_matmul::gemm proc~mm_ab_2->interface~gemm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~mat_mat_rel_ab_opt~~CalledByGraph proc~mat_mat_rel_ab_opt formatmul_opts::mat_mat_rel_AB_opt proc~mat_mat_rel_ab formatmul::mat_mat_rel_AB proc~mat_mat_rel_ab->proc~mat_mat_rel_ab_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_ab interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mat_mat_rel_AB_opt ( A , B , C , option ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) character ( * ), intent ( in ) :: option select case ( option ) case ( 'm1' ) call mm_AB_1 ( A , B , C ) case ( 'm2' ) call mm_AB_2 ( A , B , C ) case ( 'm3' ) call mm_AB_3 ( A , B , C ) case ( 'm4' ) call mm_AB_4 ( A , B , C ) case ( 'm5' ) call mm_AB_5 ( A , B , C ) case ( 'm6' ) call mm_AB_6 ( A , B , C ) case ( 'm7' ) call mm_AB_7 ( A , B , C ) case ( 'm8' ) call mm_AB_8 ( A , B , C ) case ( 'm9' ) call mm_AB_9 ( A , B , C ) case ( 'm10' ) call mm_AB_10 ( A , B , C ) case ( 'm11' ) call mm_AB_11 ( A , B , C ) case ( 'm12' ) call mm_AB_12 ( A , B , C ) case ( 'm13' ) call mm_AB_13 ( A , B , C ) end select end subroutine mat_mat_rel_AB_opt","tags":"","loc":"proc/mat_mat_rel_ab_opt.html"},{"title":"mat_mat_rel_ATB_opt – ForMatmul","text":"public pure subroutine mat_mat_rel_ATB_opt(A, B, C, option) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) character(len=*), intent(in) :: option Calls proc~~mat_mat_rel_atb_opt~~CallsGraph proc~mat_mat_rel_atb_opt formatmul_opts::mat_mat_rel_ATB_opt proc~mm_atb_1 formatmul_opts::mm_ATB_1 proc~mat_mat_rel_atb_opt->proc~mm_atb_1 proc~mm_atb_10 formatmul_opts::mm_ATB_10 proc~mat_mat_rel_atb_opt->proc~mm_atb_10 proc~mm_atb_11 formatmul_opts::mm_ATB_11 proc~mat_mat_rel_atb_opt->proc~mm_atb_11 proc~mm_atb_12 formatmul_opts::mm_ATB_12 proc~mat_mat_rel_atb_opt->proc~mm_atb_12 proc~mm_atb_13 formatmul_opts::mm_ATB_13 proc~mat_mat_rel_atb_opt->proc~mm_atb_13 proc~mm_atb_2 formatmul_opts::mm_ATB_2 proc~mat_mat_rel_atb_opt->proc~mm_atb_2 proc~mm_atb_3 formatmul_opts::mm_ATB_3 proc~mat_mat_rel_atb_opt->proc~mm_atb_3 proc~mm_atb_4 formatmul_opts::mm_ATB_4 proc~mat_mat_rel_atb_opt->proc~mm_atb_4 proc~mm_atb_5 formatmul_opts::mm_ATB_5 proc~mat_mat_rel_atb_opt->proc~mm_atb_5 proc~mm_atb_6 formatmul_opts::mm_ATB_6 proc~mat_mat_rel_atb_opt->proc~mm_atb_6 proc~mm_atb_7 formatmul_opts::mm_ATB_7 proc~mat_mat_rel_atb_opt->proc~mm_atb_7 proc~mm_atb_8 formatmul_opts::mm_ATB_8 proc~mat_mat_rel_atb_opt->proc~mm_atb_8 proc~mm_atb_9 formatmul_opts::mm_ATB_9 proc~mat_mat_rel_atb_opt->proc~mm_atb_9 interface~gemm external_interfaces_matmul::gemm proc~mm_atb_2->interface~gemm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~mat_mat_rel_atb_opt~~CalledByGraph proc~mat_mat_rel_atb_opt formatmul_opts::mat_mat_rel_ATB_opt proc~mat_mat_rel_atb formatmul::mat_mat_rel_ATB proc~mat_mat_rel_atb->proc~mat_mat_rel_atb_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_atb interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mat_mat_rel_ATB_opt ( A , B , C , option ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) character ( * ), intent ( in ) :: option select case ( option ) case ( 'm1' ) call mm_ATB_1 ( A , B , C ) case ( 'm2' ) call mm_ATB_2 ( A , B , C ) case ( 'm3' ) call mm_ATB_3 ( A , B , C ) case ( 'm4' ) call mm_ATB_4 ( A , B , C ) case ( 'm5' ) call mm_ATB_5 ( A , B , C ) case ( 'm6' ) call mm_ATB_6 ( A , B , C ) case ( 'm7' ) call mm_ATB_7 ( A , B , C ) case ( 'm8' ) call mm_ATB_8 ( A , B , C ) case ( 'm9' ) call mm_ATB_9 ( A , B , C ) case ( 'm10' ) call mm_ATB_10 ( A , B , C ) case ( 'm11' ) call mm_ATB_11 ( A , B , C ) case ( 'm12' ) call mm_ATB_12 ( A , B , C ) case ( 'm13' ) call mm_ATB_13 ( A , B , C ) end select end subroutine mat_mat_rel_ATB_opt","tags":"","loc":"proc/mat_mat_rel_atb_opt.html"},{"title":"mat_mat_rel_ABT_opt – ForMatmul","text":"public pure subroutine mat_mat_rel_ABT_opt(A, B, C, option) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) character(len=*), intent(in) :: option Calls proc~~mat_mat_rel_abt_opt~~CallsGraph proc~mat_mat_rel_abt_opt formatmul_opts::mat_mat_rel_ABT_opt proc~mm_abt_1 formatmul_opts::mm_ABT_1 proc~mat_mat_rel_abt_opt->proc~mm_abt_1 proc~mm_abt_10 formatmul_opts::mm_ABT_10 proc~mat_mat_rel_abt_opt->proc~mm_abt_10 proc~mm_abt_11 formatmul_opts::mm_ABT_11 proc~mat_mat_rel_abt_opt->proc~mm_abt_11 proc~mm_abt_12 formatmul_opts::mm_ABT_12 proc~mat_mat_rel_abt_opt->proc~mm_abt_12 proc~mm_abt_13 formatmul_opts::mm_ABT_13 proc~mat_mat_rel_abt_opt->proc~mm_abt_13 proc~mm_abt_2 formatmul_opts::mm_ABT_2 proc~mat_mat_rel_abt_opt->proc~mm_abt_2 proc~mm_abt_3 formatmul_opts::mm_ABT_3 proc~mat_mat_rel_abt_opt->proc~mm_abt_3 proc~mm_abt_4 formatmul_opts::mm_ABT_4 proc~mat_mat_rel_abt_opt->proc~mm_abt_4 proc~mm_abt_5 formatmul_opts::mm_ABT_5 proc~mat_mat_rel_abt_opt->proc~mm_abt_5 proc~mm_abt_6 formatmul_opts::mm_ABT_6 proc~mat_mat_rel_abt_opt->proc~mm_abt_6 proc~mm_abt_7 formatmul_opts::mm_ABT_7 proc~mat_mat_rel_abt_opt->proc~mm_abt_7 proc~mm_abt_8 formatmul_opts::mm_ABT_8 proc~mat_mat_rel_abt_opt->proc~mm_abt_8 proc~mm_abt_9 formatmul_opts::mm_ABT_9 proc~mat_mat_rel_abt_opt->proc~mm_abt_9 interface~gemm external_interfaces_matmul::gemm proc~mm_abt_2->interface~gemm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~mat_mat_rel_abt_opt~~CalledByGraph proc~mat_mat_rel_abt_opt formatmul_opts::mat_mat_rel_ABT_opt proc~mat_mat_rel_abt formatmul::mat_mat_rel_ABT proc~mat_mat_rel_abt->proc~mat_mat_rel_abt_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_abt interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mat_mat_rel_ABT_opt ( A , B , C , option ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) character ( * ), intent ( in ) :: option select case ( option ) case ( 'm1' ) call mm_ABT_1 ( A , B , C ) case ( 'm2' ) call mm_ABT_2 ( A , B , C ) case ( 'm3' ) call mm_ABT_3 ( A , B , C ) case ( 'm4' ) call mm_ABT_4 ( A , B , C ) case ( 'm5' ) call mm_ABT_5 ( A , B , C ) case ( 'm6' ) call mm_ABT_6 ( A , B , C ) case ( 'm7' ) call mm_ABT_7 ( A , B , C ) case ( 'm8' ) call mm_ABT_8 ( A , B , C ) case ( 'm9' ) call mm_ABT_9 ( A , B , C ) case ( 'm10' ) call mm_ABT_10 ( A , B , C ) case ( 'm11' ) call mm_ABT_11 ( A , B , C ) case ( 'm12' ) call mm_ABT_12 ( A , B , C ) case ( 'm13' ) call mm_ABT_13 ( A , B , C ) end select end subroutine mat_mat_rel_ABT_opt","tags":"","loc":"proc/mat_mat_rel_abt_opt.html"},{"title":"mat_mat_rel_ATBT_opt – ForMatmul","text":"public pure subroutine mat_mat_rel_ATBT_opt(A, B, C, option) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) character(len=*), intent(in) :: option Calls proc~~mat_mat_rel_atbt_opt~~CallsGraph proc~mat_mat_rel_atbt_opt formatmul_opts::mat_mat_rel_ATBT_opt proc~mm_atbt_1 formatmul_opts::mm_ATBT_1 proc~mat_mat_rel_atbt_opt->proc~mm_atbt_1 proc~mm_atbt_10 formatmul_opts::mm_ATBT_10 proc~mat_mat_rel_atbt_opt->proc~mm_atbt_10 proc~mm_atbt_11 formatmul_opts::mm_ATBT_11 proc~mat_mat_rel_atbt_opt->proc~mm_atbt_11 proc~mm_atbt_12 formatmul_opts::mm_ATBT_12 proc~mat_mat_rel_atbt_opt->proc~mm_atbt_12 proc~mm_atbt_13 formatmul_opts::mm_ATBT_13 proc~mat_mat_rel_atbt_opt->proc~mm_atbt_13 proc~mm_atbt_2 formatmul_opts::mm_ATBT_2 proc~mat_mat_rel_atbt_opt->proc~mm_atbt_2 proc~mm_atbt_3 formatmul_opts::mm_ATBT_3 proc~mat_mat_rel_atbt_opt->proc~mm_atbt_3 proc~mm_atbt_4 formatmul_opts::mm_ATBT_4 proc~mat_mat_rel_atbt_opt->proc~mm_atbt_4 proc~mm_atbt_5 formatmul_opts::mm_ATBT_5 proc~mat_mat_rel_atbt_opt->proc~mm_atbt_5 proc~mm_atbt_6 formatmul_opts::mm_ATBT_6 proc~mat_mat_rel_atbt_opt->proc~mm_atbt_6 proc~mm_atbt_7 formatmul_opts::mm_ATBT_7 proc~mat_mat_rel_atbt_opt->proc~mm_atbt_7 proc~mm_atbt_8 formatmul_opts::mm_ATBT_8 proc~mat_mat_rel_atbt_opt->proc~mm_atbt_8 proc~mm_atbt_9 formatmul_opts::mm_ATBT_9 proc~mat_mat_rel_atbt_opt->proc~mm_atbt_9 interface~gemm external_interfaces_matmul::gemm proc~mm_atbt_2->interface~gemm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~mat_mat_rel_atbt_opt~~CalledByGraph proc~mat_mat_rel_atbt_opt formatmul_opts::mat_mat_rel_ATBT_opt proc~mat_mat_rel_atbt formatmul::mat_mat_rel_ATBT proc~mat_mat_rel_atbt->proc~mat_mat_rel_atbt_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_atbt interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mat_mat_rel_ATBT_opt ( A , B , C , option ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) character ( * ), intent ( in ) :: option select case ( option ) case ( 'm1' ) call mm_ATBT_1 ( A , B , C ) case ( 'm2' ) call mm_ATBT_2 ( A , B , C ) case ( 'm3' ) call mm_ATBT_3 ( A , B , C ) case ( 'm4' ) call mm_ATBT_4 ( A , B , C ) case ( 'm5' ) call mm_ATBT_5 ( A , B , C ) case ( 'm6' ) call mm_ATBT_6 ( A , B , C ) case ( 'm7' ) call mm_ATBT_7 ( A , B , C ) case ( 'm8' ) call mm_ATBT_8 ( A , B , C ) case ( 'm9' ) call mm_ATBT_9 ( A , B , C ) case ( 'm10' ) call mm_ATBT_10 ( A , B , C ) case ( 'm11' ) call mm_ATBT_11 ( A , B , C ) case ( 'm12' ) call mm_ATBT_12 ( A , B , C ) case ( 'm13' ) call mm_ATBT_13 ( A , B , C ) end select end subroutine mat_mat_rel_ATBT_opt","tags":"","loc":"proc/mat_mat_rel_atbt_opt.html"},{"title":"mat_vec_rel_Av_opt – ForMatmul","text":"public pure subroutine mat_vec_rel_Av_opt(A, v, w, option) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) real(kind=rk), intent(inout), contiguous :: w (:) character(len=*), intent(in) :: option Calls proc~~mat_vec_rel_av_opt~~CallsGraph proc~mat_vec_rel_av_opt formatmul_opts::mat_vec_rel_Av_opt proc~mv_av_1 formatmul_opts::mv_Av_1 proc~mat_vec_rel_av_opt->proc~mv_av_1 proc~mv_av_2 formatmul_opts::mv_Av_2 proc~mat_vec_rel_av_opt->proc~mv_av_2 proc~mv_av_3 formatmul_opts::mv_Av_3 proc~mat_vec_rel_av_opt->proc~mv_av_3 proc~mv_av_4 formatmul_opts::mv_Av_4 proc~mat_vec_rel_av_opt->proc~mv_av_4 proc~mv_av_5 formatmul_opts::mv_Av_5 proc~mat_vec_rel_av_opt->proc~mv_av_5 proc~mv_av_6 formatmul_opts::mv_Av_6 proc~mat_vec_rel_av_opt->proc~mv_av_6 proc~mv_av_7 formatmul_opts::mv_Av_7 proc~mat_vec_rel_av_opt->proc~mv_av_7 proc~mv_av_8 formatmul_opts::mv_Av_8 proc~mat_vec_rel_av_opt->proc~mv_av_8 interface~gemv external_interfaces_matmul::gemv proc~mv_av_2->interface~gemv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~mat_vec_rel_av_opt~~CalledByGraph proc~mat_vec_rel_av_opt formatmul_opts::mat_vec_rel_Av_opt proc~mat_vec_rel_av formatmul::mat_vec_rel_Av proc~mat_vec_rel_av->proc~mat_vec_rel_av_opt proc~mat_vec_rel formatmul::mat_vec_rel proc~mat_vec_rel->proc~mat_vec_rel_av interface~matmul formatmul::matmul interface~matmul->proc~mat_vec_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mat_vec_rel_Av_opt ( A , v , w , option ) real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) real ( rk ), intent ( inout ), contiguous :: w (:) character ( * ), intent ( in ) :: option select case ( option ) case ( 'm1' ) call mv_Av_1 ( A , v , w ) case ( 'm2' ) call mv_Av_2 ( A , v , w ) case ( 'm3' ) call mv_Av_3 ( A , v , w ) case ( 'm4' ) call mv_Av_4 ( A , v , w ) case ( 'm5' ) call mv_Av_5 ( A , v , w ) case ( 'm6' ) call mv_Av_6 ( A , v , w ) case ( 'm7' ) call mv_Av_7 ( A , v , w ) case ( 'm8' ) call mv_Av_8 ( A , v , w ) end select end subroutine mat_vec_rel_Av_opt","tags":"","loc":"proc/mat_vec_rel_av_opt.html"},{"title":"mat_vec_rel_ATv_opt – ForMatmul","text":"public pure subroutine mat_vec_rel_ATv_opt(A, v, w, option) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) real(kind=rk), intent(inout), contiguous :: w (:) character(len=*), intent(in) :: option Calls proc~~mat_vec_rel_atv_opt~~CallsGraph proc~mat_vec_rel_atv_opt formatmul_opts::mat_vec_rel_ATv_opt proc~mv_atv_1 formatmul_opts::mv_ATv_1 proc~mat_vec_rel_atv_opt->proc~mv_atv_1 proc~mv_atv_2 formatmul_opts::mv_ATv_2 proc~mat_vec_rel_atv_opt->proc~mv_atv_2 proc~mv_atv_3 formatmul_opts::mv_ATv_3 proc~mat_vec_rel_atv_opt->proc~mv_atv_3 proc~mv_atv_4 formatmul_opts::mv_ATv_4 proc~mat_vec_rel_atv_opt->proc~mv_atv_4 proc~mv_atv_5 formatmul_opts::mv_ATv_5 proc~mat_vec_rel_atv_opt->proc~mv_atv_5 proc~mv_atv_6 formatmul_opts::mv_ATv_6 proc~mat_vec_rel_atv_opt->proc~mv_atv_6 proc~mv_atv_7 formatmul_opts::mv_ATv_7 proc~mat_vec_rel_atv_opt->proc~mv_atv_7 proc~mv_atv_8 formatmul_opts::mv_ATv_8 proc~mat_vec_rel_atv_opt->proc~mv_atv_8 interface~gemv external_interfaces_matmul::gemv proc~mv_atv_2->interface~gemv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~mat_vec_rel_atv_opt~~CalledByGraph proc~mat_vec_rel_atv_opt formatmul_opts::mat_vec_rel_ATv_opt proc~mat_vec_rel_atv formatmul::mat_vec_rel_ATv proc~mat_vec_rel_atv->proc~mat_vec_rel_atv_opt proc~mat_vec_rel formatmul::mat_vec_rel proc~mat_vec_rel->proc~mat_vec_rel_atv interface~matmul formatmul::matmul interface~matmul->proc~mat_vec_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mat_vec_rel_ATv_opt ( A , v , w , option ) real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) real ( rk ), intent ( inout ), contiguous :: w (:) character ( * ), intent ( in ) :: option select case ( option ) case ( 'm1' ) call mv_ATv_1 ( A , v , w ) case ( 'm2' ) call mv_ATv_2 ( A , v , w ) case ( 'm3' ) call mv_ATv_3 ( A , v , w ) case ( 'm4' ) call mv_ATv_4 ( A , v , w ) case ( 'm5' ) call mv_ATv_5 ( A , v , w ) case ( 'm6' ) call mv_ATv_6 ( A , v , w ) case ( 'm7' ) call mv_ATv_7 ( A , v , w ) case ( 'm8' ) call mv_ATv_8 ( A , v , w ) end select end subroutine mat_vec_rel_ATv_opt","tags":"","loc":"proc/mat_vec_rel_atv_opt.html"},{"title":"mm_AB_1 – ForMatmul","text":"private pure subroutine mm_AB_1(A, B, C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) Called by proc~~mm_ab_1~~CalledByGraph proc~mm_ab_1 formatmul_opts::mm_AB_1 proc~mat_mat_rel_ab_opt formatmul_opts::mat_mat_rel_AB_opt proc~mat_mat_rel_ab_opt->proc~mm_ab_1 proc~mat_mat_rel_ab formatmul::mat_mat_rel_AB proc~mat_mat_rel_ab->proc~mat_mat_rel_ab_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_ab interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_AB_1 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) C = matmul ( A , B ) end subroutine mm_AB_1","tags":"","loc":"proc/mm_ab_1.html"},{"title":"mm_AB_2 – ForMatmul","text":"private pure subroutine mm_AB_2(A, B, C) Uses external_interfaces_matmul proc~~mm_ab_2~~UsesGraph proc~mm_ab_2 formatmul_opts::mm_AB_2 module~external_interfaces_matmul external_interfaces_matmul proc~mm_ab_2->module~external_interfaces_matmul kinds kinds module~external_interfaces_matmul->kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) Calls proc~~mm_ab_2~~CallsGraph proc~mm_ab_2 formatmul_opts::mm_AB_2 interface~gemm external_interfaces_matmul::gemm proc~mm_ab_2->interface~gemm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~mm_ab_2~~CalledByGraph proc~mm_ab_2 formatmul_opts::mm_AB_2 proc~mat_mat_rel_ab_opt formatmul_opts::mat_mat_rel_AB_opt proc~mat_mat_rel_ab_opt->proc~mm_ab_2 proc~mat_mat_rel_ab formatmul::mat_mat_rel_AB proc~mat_mat_rel_ab->proc~mat_mat_rel_ab_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_ab interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_AB_2 ( A , B , C ) use external_interfaces_matmul real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n m = size ( A , 1 ) n = size ( A , 2 ) ! Call BLAS gemm subroutine for matrix-matrix multiplication. call gemm ( 'N' , 'N' , m , size ( B , 2 ), n , 1.0_rk , A , m , B , n , 0.0_rk , C , m ) end subroutine mm_AB_2","tags":"","loc":"proc/mm_ab_2.html"},{"title":"mm_AB_3 – ForMatmul","text":"private pure subroutine mm_AB_3(A, B, C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) Called by proc~~mm_ab_3~~CalledByGraph proc~mm_ab_3 formatmul_opts::mm_AB_3 proc~mat_mat_rel_ab_opt formatmul_opts::mat_mat_rel_AB_opt proc~mat_mat_rel_ab_opt->proc~mm_ab_3 proc~mat_mat_rel_ab formatmul::mat_mat_rel_AB proc~mat_mat_rel_ab->proc~mat_mat_rel_ab_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_ab interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_AB_3 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 1 ) n = size ( A , 2 ) p = size ( B , 2 ) do i = 1 , m do j = 1 , n do k = 1 , p c ( i , k ) = c ( i , k ) + a ( i , j ) * b ( j , k ) end do end do end do end subroutine mm_AB_3","tags":"","loc":"proc/mm_ab_3.html"},{"title":"mm_AB_4 – ForMatmul","text":"private pure subroutine mm_AB_4(A, B, C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) Called by proc~~mm_ab_4~~CalledByGraph proc~mm_ab_4 formatmul_opts::mm_AB_4 proc~mat_mat_rel_ab_opt formatmul_opts::mat_mat_rel_AB_opt proc~mat_mat_rel_ab_opt->proc~mm_ab_4 proc~mat_mat_rel_ab formatmul::mat_mat_rel_AB proc~mat_mat_rel_ab->proc~mat_mat_rel_ab_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_ab interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_AB_4 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 1 ) n = size ( A , 2 ) p = size ( B , 2 ) do i = 1 , m do j = 1 , p do k = 1 , n c ( i , j ) = c ( i , j ) + a ( i , k ) * b ( k , j ) end do end do end do end subroutine mm_AB_4","tags":"","loc":"proc/mm_ab_4.html"},{"title":"mm_AB_5 – ForMatmul","text":"private pure subroutine mm_AB_5(A, B, C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) Called by proc~~mm_ab_5~~CalledByGraph proc~mm_ab_5 formatmul_opts::mm_AB_5 proc~mat_mat_rel_ab_opt formatmul_opts::mat_mat_rel_AB_opt proc~mat_mat_rel_ab_opt->proc~mm_ab_5 proc~mat_mat_rel_ab formatmul::mat_mat_rel_AB proc~mat_mat_rel_ab->proc~mat_mat_rel_ab_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_ab interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_AB_5 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 1 ) n = size ( A , 2 ) p = size ( B , 2 ) do i = 1 , n do j = 1 , m do k = 1 , p c ( j , k ) = c ( j , k ) + a ( j , i ) * b ( i , k ) end do end do end do end subroutine mm_AB_5","tags":"","loc":"proc/mm_ab_5.html"},{"title":"mm_AB_6 – ForMatmul","text":"private pure subroutine mm_AB_6(A, B, C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) Called by proc~~mm_ab_6~~CalledByGraph proc~mm_ab_6 formatmul_opts::mm_AB_6 proc~mat_mat_rel_ab_opt formatmul_opts::mat_mat_rel_AB_opt proc~mat_mat_rel_ab_opt->proc~mm_ab_6 proc~mat_mat_rel_ab formatmul::mat_mat_rel_AB proc~mat_mat_rel_ab->proc~mat_mat_rel_ab_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_ab interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_AB_6 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 1 ) n = size ( A , 2 ) p = size ( B , 2 ) do i = 1 , n do j = 1 , p do k = 1 , m c ( k , j ) = c ( k , j ) + a ( k , i ) * b ( i , j ) end do end do end do end subroutine mm_AB_6","tags":"","loc":"proc/mm_ab_6.html"},{"title":"mm_AB_7 – ForMatmul","text":"private pure subroutine mm_AB_7(A, B, C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) Called by proc~~mm_ab_7~~CalledByGraph proc~mm_ab_7 formatmul_opts::mm_AB_7 proc~mat_mat_rel_ab_opt formatmul_opts::mat_mat_rel_AB_opt proc~mat_mat_rel_ab_opt->proc~mm_ab_7 proc~mat_mat_rel_ab formatmul::mat_mat_rel_AB proc~mat_mat_rel_ab->proc~mat_mat_rel_ab_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_ab interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_AB_7 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 1 ) n = size ( A , 2 ) p = size ( B , 2 ) do i = 1 , p do j = 1 , m do k = 1 , n c ( j , i ) = c ( j , i ) + a ( j , k ) * b ( k , i ) end do end do end do end subroutine mm_AB_7","tags":"","loc":"proc/mm_ab_7.html"},{"title":"mm_AB_8 – ForMatmul","text":"private pure subroutine mm_AB_8(A, B, C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) Called by proc~~mm_ab_8~~CalledByGraph proc~mm_ab_8 formatmul_opts::mm_AB_8 proc~mat_mat_rel_ab_opt formatmul_opts::mat_mat_rel_AB_opt proc~mat_mat_rel_ab_opt->proc~mm_ab_8 proc~mat_mat_rel_ab formatmul::mat_mat_rel_AB proc~mat_mat_rel_ab->proc~mat_mat_rel_ab_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_ab interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_AB_8 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 1 ) n = size ( A , 2 ) p = size ( B , 2 ) do i = 1 , p do j = 1 , n do k = 1 , m c ( k , i ) = c ( k , i ) + a ( k , j ) * b ( j , i ) end do end do end do end subroutine mm_AB_8","tags":"","loc":"proc/mm_ab_8.html"},{"title":"mm_AB_9 – ForMatmul","text":"private pure subroutine mm_AB_9(A, B, C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) Called by proc~~mm_ab_9~~CalledByGraph proc~mm_ab_9 formatmul_opts::mm_AB_9 proc~mat_mat_rel_ab_opt formatmul_opts::mat_mat_rel_AB_opt proc~mat_mat_rel_ab_opt->proc~mm_ab_9 proc~mat_mat_rel_ab formatmul::mat_mat_rel_AB proc~mat_mat_rel_ab->proc~mat_mat_rel_ab_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_ab interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_AB_9 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , p integer :: i , k m = size ( A , 1 ) p = size ( B , 2 ) do i = 1 , p do k = 1 , m c ( k , i ) = dot_product ( a ( k ,:), b (:, i )) end do end do end subroutine mm_AB_9","tags":"","loc":"proc/mm_ab_9.html"},{"title":"mm_AB_10 – ForMatmul","text":"private pure subroutine mm_AB_10(A, B, C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) Called by proc~~mm_ab_10~~CalledByGraph proc~mm_ab_10 formatmul_opts::mm_AB_10 proc~mat_mat_rel_ab_opt formatmul_opts::mat_mat_rel_AB_opt proc~mat_mat_rel_ab_opt->proc~mm_ab_10 proc~mat_mat_rel_ab formatmul::mat_mat_rel_AB proc~mat_mat_rel_ab->proc~mat_mat_rel_ab_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_ab interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_AB_10 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , p integer :: i , k m = size ( A , 1 ) p = size ( B , 2 ) error stop 'ForMatMul: shared is not supported in gfortran' !   do concurrent (i = 1: p) shared(m, p) ! check shared variables !     do k = 1, m !         c(k,i) = dot_product(a(k,:), b(:,i)) !     end do !   end do end subroutine mm_AB_10","tags":"","loc":"proc/mm_ab_10.html"},{"title":"mm_AB_11 – ForMatmul","text":"private pure subroutine mm_AB_11(A, B, C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) Called by proc~~mm_ab_11~~CalledByGraph proc~mm_ab_11 formatmul_opts::mm_AB_11 proc~mat_mat_rel_ab_opt formatmul_opts::mat_mat_rel_AB_opt proc~mat_mat_rel_ab_opt->proc~mm_ab_11 proc~mat_mat_rel_ab formatmul::mat_mat_rel_AB proc~mat_mat_rel_ab->proc~mat_mat_rel_ab_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_ab interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_AB_11 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 1 ) n = size ( A , 2 ) p = size ( B , 2 ) error stop 'ForMatMul: shared is not supported in gfortran' !    do concurrent (i = 1: p) shared(m, n, p) ! check shared variables !         do j=1,n !             do k=1,m !                 c(k,i) = c(k,i) + a(k,j)*b(j,i) !             end do !         end do !     end do end subroutine mm_AB_11","tags":"","loc":"proc/mm_ab_11.html"},{"title":"mm_AB_12 – ForMatmul","text":"private pure subroutine mm_AB_12(A, B, C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) Called by proc~~mm_ab_12~~CalledByGraph proc~mm_ab_12 formatmul_opts::mm_AB_12 proc~mat_mat_rel_ab_opt formatmul_opts::mat_mat_rel_AB_opt proc~mat_mat_rel_ab_opt->proc~mm_ab_12 proc~mat_mat_rel_ab formatmul::mat_mat_rel_AB proc~mat_mat_rel_ab->proc~mat_mat_rel_ab_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_ab interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_AB_12 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) interface pure subroutine impure_mm_AB_12 ( f_a , f_b , f_c ) import rk real ( rk ), intent ( in ) :: f_a (:,:), f_b (:,:) real ( rk ), intent ( inout ) :: f_c (:,:) end subroutine impure_mm_AB_12 end interface call impure_mm_AB_12 ( a , b , c ) end subroutine mm_AB_12","tags":"","loc":"proc/mm_ab_12.html"},{"title":"mm_AB_13 – ForMatmul","text":"private pure subroutine mm_AB_13(A, B, C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) Called by proc~~mm_ab_13~~CalledByGraph proc~mm_ab_13 formatmul_opts::mm_AB_13 proc~mat_mat_rel_ab_opt formatmul_opts::mat_mat_rel_AB_opt proc~mat_mat_rel_ab_opt->proc~mm_ab_13 proc~mat_mat_rel_ab formatmul::mat_mat_rel_AB proc~mat_mat_rel_ab->proc~mat_mat_rel_ab_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_ab interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_AB_13 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) interface pure subroutine impure_mm_AB_13 ( f_a , f_b , f_c ) import rk real ( rk ), intent ( in ) :: f_a (:,:), f_b (:,:) real ( rk ), intent ( inout ) :: f_c (:,:) end subroutine impure_mm_AB_13 end interface call impure_mm_AB_13 ( a , b , c ) end subroutine mm_AB_13","tags":"","loc":"proc/mm_ab_13.html"},{"title":"mm_ATB_1 – ForMatmul","text":"private pure subroutine mm_ATB_1(A, B, C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) Called by proc~~mm_atb_1~~CalledByGraph proc~mm_atb_1 formatmul_opts::mm_ATB_1 proc~mat_mat_rel_atb_opt formatmul_opts::mat_mat_rel_ATB_opt proc~mat_mat_rel_atb_opt->proc~mm_atb_1 proc~mat_mat_rel_atb formatmul::mat_mat_rel_ATB proc~mat_mat_rel_atb->proc~mat_mat_rel_atb_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_atb interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_ATB_1 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) C = matmul ( transpose ( A ), B ) end subroutine mm_ATB_1","tags":"","loc":"proc/mm_atb_1.html"},{"title":"mm_ATB_2 – ForMatmul","text":"private pure subroutine mm_ATB_2(A, B, C) Uses external_interfaces_matmul proc~~mm_atb_2~~UsesGraph proc~mm_atb_2 formatmul_opts::mm_ATB_2 module~external_interfaces_matmul external_interfaces_matmul proc~mm_atb_2->module~external_interfaces_matmul kinds kinds module~external_interfaces_matmul->kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) Calls proc~~mm_atb_2~~CallsGraph proc~mm_atb_2 formatmul_opts::mm_ATB_2 interface~gemm external_interfaces_matmul::gemm proc~mm_atb_2->interface~gemm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~mm_atb_2~~CalledByGraph proc~mm_atb_2 formatmul_opts::mm_ATB_2 proc~mat_mat_rel_atb_opt formatmul_opts::mat_mat_rel_ATB_opt proc~mat_mat_rel_atb_opt->proc~mm_atb_2 proc~mat_mat_rel_atb formatmul::mat_mat_rel_ATB proc~mat_mat_rel_atb->proc~mat_mat_rel_atb_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_atb interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_ATB_2 ( A , B , C ) use external_interfaces_matmul real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n m = size ( A , 2 ) n = size ( A , 1 ) ! Call BLAS gemm subroutine for matrix-matrix multiplication. call gemm ( 'T' , 'N' , m , size ( B , 2 ), n , 1.0_rk , A , n , B , n , 0.0_rk , C , m ) end subroutine mm_ATB_2","tags":"","loc":"proc/mm_atb_2.html"},{"title":"mm_ATB_3 – ForMatmul","text":"private pure subroutine mm_ATB_3(A, B, C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) Called by proc~~mm_atb_3~~CalledByGraph proc~mm_atb_3 formatmul_opts::mm_ATB_3 proc~mat_mat_rel_atb_opt formatmul_opts::mat_mat_rel_ATB_opt proc~mat_mat_rel_atb_opt->proc~mm_atb_3 proc~mat_mat_rel_atb formatmul::mat_mat_rel_ATB proc~mat_mat_rel_atb->proc~mat_mat_rel_atb_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_atb interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_ATB_3 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 2 ) n = size ( A , 1 ) p = size ( B , 2 ) do i = 1 , m do j = 1 , n do k = 1 , p c ( i , k ) = c ( i , k ) + a ( j , i ) * b ( j , k ) end do end do end do end subroutine mm_ATB_3","tags":"","loc":"proc/mm_atb_3.html"},{"title":"mm_ATB_4 – ForMatmul","text":"private pure subroutine mm_ATB_4(A, B, C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) Called by proc~~mm_atb_4~~CalledByGraph proc~mm_atb_4 formatmul_opts::mm_ATB_4 proc~mat_mat_rel_atb_opt formatmul_opts::mat_mat_rel_ATB_opt proc~mat_mat_rel_atb_opt->proc~mm_atb_4 proc~mat_mat_rel_atb formatmul::mat_mat_rel_ATB proc~mat_mat_rel_atb->proc~mat_mat_rel_atb_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_atb interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_ATB_4 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 2 ) n = size ( A , 1 ) p = size ( B , 2 ) do i = 1 , m do j = 1 , p do k = 1 , n c ( i , j ) = c ( i , j ) + a ( k , i ) * b ( k , j ) end do end do end do end subroutine mm_ATB_4","tags":"","loc":"proc/mm_atb_4.html"},{"title":"mm_ATB_5 – ForMatmul","text":"private pure subroutine mm_ATB_5(A, B, C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) Called by proc~~mm_atb_5~~CalledByGraph proc~mm_atb_5 formatmul_opts::mm_ATB_5 proc~mat_mat_rel_atb_opt formatmul_opts::mat_mat_rel_ATB_opt proc~mat_mat_rel_atb_opt->proc~mm_atb_5 proc~mat_mat_rel_atb formatmul::mat_mat_rel_ATB proc~mat_mat_rel_atb->proc~mat_mat_rel_atb_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_atb interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_ATB_5 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 2 ) n = size ( A , 1 ) p = size ( B , 2 ) do i = 1 , n do j = 1 , m do k = 1 , p c ( j , k ) = c ( j , k ) + a ( i , j ) * b ( i , k ) end do end do end do end subroutine mm_ATB_5","tags":"","loc":"proc/mm_atb_5.html"},{"title":"mm_ATB_6 – ForMatmul","text":"private pure subroutine mm_ATB_6(A, B, C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) Called by proc~~mm_atb_6~~CalledByGraph proc~mm_atb_6 formatmul_opts::mm_ATB_6 proc~mat_mat_rel_atb_opt formatmul_opts::mat_mat_rel_ATB_opt proc~mat_mat_rel_atb_opt->proc~mm_atb_6 proc~mat_mat_rel_atb formatmul::mat_mat_rel_ATB proc~mat_mat_rel_atb->proc~mat_mat_rel_atb_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_atb interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_ATB_6 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 2 ) n = size ( A , 1 ) p = size ( B , 2 ) do i = 1 , n do j = 1 , p do k = 1 , m c ( k , j ) = c ( k , j ) + a ( i , k ) * b ( i , j ) end do end do end do end subroutine mm_ATB_6","tags":"","loc":"proc/mm_atb_6.html"},{"title":"mm_ATB_7 – ForMatmul","text":"private pure subroutine mm_ATB_7(A, B, C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) Called by proc~~mm_atb_7~~CalledByGraph proc~mm_atb_7 formatmul_opts::mm_ATB_7 proc~mat_mat_rel_atb_opt formatmul_opts::mat_mat_rel_ATB_opt proc~mat_mat_rel_atb_opt->proc~mm_atb_7 proc~mat_mat_rel_atb formatmul::mat_mat_rel_ATB proc~mat_mat_rel_atb->proc~mat_mat_rel_atb_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_atb interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_ATB_7 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 2 ) n = size ( A , 1 ) p = size ( B , 2 ) do i = 1 , p do j = 1 , m do k = 1 , n c ( j , i ) = c ( j , i ) + a ( k , j ) * b ( k , i ) end do end do end do end subroutine mm_ATB_7","tags":"","loc":"proc/mm_atb_7.html"},{"title":"mm_ATB_8 – ForMatmul","text":"private pure subroutine mm_ATB_8(A, B, C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) Called by proc~~mm_atb_8~~CalledByGraph proc~mm_atb_8 formatmul_opts::mm_ATB_8 proc~mat_mat_rel_atb_opt formatmul_opts::mat_mat_rel_ATB_opt proc~mat_mat_rel_atb_opt->proc~mm_atb_8 proc~mat_mat_rel_atb formatmul::mat_mat_rel_ATB proc~mat_mat_rel_atb->proc~mat_mat_rel_atb_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_atb interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_ATB_8 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 2 ) n = size ( A , 1 ) p = size ( B , 2 ) do i = 1 , p do j = 1 , n do k = 1 , m c ( k , i ) = c ( k , i ) + a ( j , k ) * b ( j , i ) end do end do end do end subroutine mm_ATB_8","tags":"","loc":"proc/mm_atb_8.html"},{"title":"mm_ATB_9 – ForMatmul","text":"private pure subroutine mm_ATB_9(A, B, C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) Called by proc~~mm_atb_9~~CalledByGraph proc~mm_atb_9 formatmul_opts::mm_ATB_9 proc~mat_mat_rel_atb_opt formatmul_opts::mat_mat_rel_ATB_opt proc~mat_mat_rel_atb_opt->proc~mm_atb_9 proc~mat_mat_rel_atb formatmul::mat_mat_rel_ATB proc~mat_mat_rel_atb->proc~mat_mat_rel_atb_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_atb interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_ATB_9 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , p integer :: i , k m = size ( A , 2 ) p = size ( B , 2 ) do i = 1 , p do k = 1 , m c ( k , i ) = dot_product ( a (:, k ), b (:, i )) end do end do end subroutine mm_ATB_9","tags":"","loc":"proc/mm_atb_9.html"},{"title":"mm_ATB_10 – ForMatmul","text":"private pure subroutine mm_ATB_10(A, B, C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) Called by proc~~mm_atb_10~~CalledByGraph proc~mm_atb_10 formatmul_opts::mm_ATB_10 proc~mat_mat_rel_atb_opt formatmul_opts::mat_mat_rel_ATB_opt proc~mat_mat_rel_atb_opt->proc~mm_atb_10 proc~mat_mat_rel_atb formatmul::mat_mat_rel_ATB proc~mat_mat_rel_atb->proc~mat_mat_rel_atb_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_atb interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_ATB_10 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , p integer :: i , k m = size ( A , 2 ) p = size ( B , 2 ) error stop 'ForMatMul: shared is not supported in gfortran' !   do concurrent (i = 1: p) shared(m, p) ! check shared variables !     do k = 1, m !         c(k,i) = dot_product(a(:,k), b(:,i)) !     end do !   end do end subroutine mm_ATB_10","tags":"","loc":"proc/mm_atb_10.html"},{"title":"mm_ATB_11 – ForMatmul","text":"private pure subroutine mm_ATB_11(A, B, C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) Called by proc~~mm_atb_11~~CalledByGraph proc~mm_atb_11 formatmul_opts::mm_ATB_11 proc~mat_mat_rel_atb_opt formatmul_opts::mat_mat_rel_ATB_opt proc~mat_mat_rel_atb_opt->proc~mm_atb_11 proc~mat_mat_rel_atb formatmul::mat_mat_rel_ATB proc~mat_mat_rel_atb->proc~mat_mat_rel_atb_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_atb interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_ATB_11 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 2 ) n = size ( A , 1 ) p = size ( B , 2 ) error stop 'ForMatMul: shared is not supported in gfortran' !    do concurrent (i = 1: p) shared(m, n, p) ! check shared variables !         do j=1,n !             do k=1,m !                 c(k,i) = c(k,i) + a(j,k)*b(j,i) !             end do !         end do !     end do end subroutine mm_ATB_11","tags":"","loc":"proc/mm_atb_11.html"},{"title":"mm_ATB_12 – ForMatmul","text":"private pure subroutine mm_ATB_12(A, B, C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) Called by proc~~mm_atb_12~~CalledByGraph proc~mm_atb_12 formatmul_opts::mm_ATB_12 proc~mat_mat_rel_atb_opt formatmul_opts::mat_mat_rel_ATB_opt proc~mat_mat_rel_atb_opt->proc~mm_atb_12 proc~mat_mat_rel_atb formatmul::mat_mat_rel_ATB proc~mat_mat_rel_atb->proc~mat_mat_rel_atb_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_atb interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_ATB_12 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) interface pure subroutine impure_mm_ATB_12 ( f_a , f_b , f_c ) import rk real ( rk ), intent ( in ) :: f_a (:,:), f_b (:,:) real ( rk ), intent ( inout ) :: f_c (:,:) end subroutine impure_mm_ATB_12 end interface call impure_mm_ATB_12 ( a , b , c ) end subroutine mm_ATB_12","tags":"","loc":"proc/mm_atb_12.html"},{"title":"mm_ATB_13 – ForMatmul","text":"private pure subroutine mm_ATB_13(A, B, C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) Called by proc~~mm_atb_13~~CalledByGraph proc~mm_atb_13 formatmul_opts::mm_ATB_13 proc~mat_mat_rel_atb_opt formatmul_opts::mat_mat_rel_ATB_opt proc~mat_mat_rel_atb_opt->proc~mm_atb_13 proc~mat_mat_rel_atb formatmul::mat_mat_rel_ATB proc~mat_mat_rel_atb->proc~mat_mat_rel_atb_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_atb interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_ATB_13 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) interface pure subroutine impure_mm_ATB_13 ( f_a , f_b , f_c ) import rk real ( rk ), intent ( in ) :: f_a (:,:), f_b (:,:) real ( rk ), intent ( inout ) :: f_c (:,:) end subroutine impure_mm_ATB_13 end interface call impure_mm_ATB_13 ( a , b , c ) end subroutine mm_ATB_13","tags":"","loc":"proc/mm_atb_13.html"},{"title":"mm_ABT_1 – ForMatmul","text":"private pure subroutine mm_ABT_1(A, B, C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) Called by proc~~mm_abt_1~~CalledByGraph proc~mm_abt_1 formatmul_opts::mm_ABT_1 proc~mat_mat_rel_abt_opt formatmul_opts::mat_mat_rel_ABT_opt proc~mat_mat_rel_abt_opt->proc~mm_abt_1 proc~mat_mat_rel_abt formatmul::mat_mat_rel_ABT proc~mat_mat_rel_abt->proc~mat_mat_rel_abt_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_abt interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_ABT_1 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) C = matmul ( A , transpose ( B )) end subroutine mm_ABT_1","tags":"","loc":"proc/mm_abt_1.html"},{"title":"mm_ABT_2 – ForMatmul","text":"private pure subroutine mm_ABT_2(A, B, C) Uses external_interfaces_matmul proc~~mm_abt_2~~UsesGraph proc~mm_abt_2 formatmul_opts::mm_ABT_2 module~external_interfaces_matmul external_interfaces_matmul proc~mm_abt_2->module~external_interfaces_matmul kinds kinds module~external_interfaces_matmul->kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) Calls proc~~mm_abt_2~~CallsGraph proc~mm_abt_2 formatmul_opts::mm_ABT_2 interface~gemm external_interfaces_matmul::gemm proc~mm_abt_2->interface~gemm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~mm_abt_2~~CalledByGraph proc~mm_abt_2 formatmul_opts::mm_ABT_2 proc~mat_mat_rel_abt_opt formatmul_opts::mat_mat_rel_ABT_opt proc~mat_mat_rel_abt_opt->proc~mm_abt_2 proc~mat_mat_rel_abt formatmul::mat_mat_rel_ABT proc~mat_mat_rel_abt->proc~mat_mat_rel_abt_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_abt interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_ABT_2 ( A , B , C ) use external_interfaces_matmul real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , p m = size ( A , 1 ) p = size ( B , 1 ) ! Call BLAS gemm subroutine for matrix-matrix multiplication. call gemm ( 'N' , 'T' , m , p , size ( A , 2 ), 1.0_rk , A , m , B , p , 0.0_rk , C , m ) end subroutine mm_ABT_2","tags":"","loc":"proc/mm_abt_2.html"},{"title":"mm_ABT_3 – ForMatmul","text":"private pure subroutine mm_ABT_3(A, B, C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) Called by proc~~mm_abt_3~~CalledByGraph proc~mm_abt_3 formatmul_opts::mm_ABT_3 proc~mat_mat_rel_abt_opt formatmul_opts::mat_mat_rel_ABT_opt proc~mat_mat_rel_abt_opt->proc~mm_abt_3 proc~mat_mat_rel_abt formatmul::mat_mat_rel_ABT proc~mat_mat_rel_abt->proc~mat_mat_rel_abt_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_abt interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_ABT_3 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 1 ) n = size ( A , 2 ) p = size ( B , 1 ) do i = 1 , m do j = 1 , n do k = 1 , p c ( i , k ) = c ( i , k ) + a ( i , j ) * b ( k , j ) end do end do end do end subroutine mm_ABT_3","tags":"","loc":"proc/mm_abt_3.html"},{"title":"mm_ABT_4 – ForMatmul","text":"private pure subroutine mm_ABT_4(A, B, C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) Called by proc~~mm_abt_4~~CalledByGraph proc~mm_abt_4 formatmul_opts::mm_ABT_4 proc~mat_mat_rel_abt_opt formatmul_opts::mat_mat_rel_ABT_opt proc~mat_mat_rel_abt_opt->proc~mm_abt_4 proc~mat_mat_rel_abt formatmul::mat_mat_rel_ABT proc~mat_mat_rel_abt->proc~mat_mat_rel_abt_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_abt interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_ABT_4 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 1 ) n = size ( A , 2 ) p = size ( B , 1 ) do i = 1 , m do j = 1 , p do k = 1 , n c ( i , j ) = c ( i , j ) + a ( i , k ) * b ( j , k ) end do end do end do end subroutine mm_ABT_4","tags":"","loc":"proc/mm_abt_4.html"},{"title":"mm_ABT_5 – ForMatmul","text":"private pure subroutine mm_ABT_5(A, B, C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) Called by proc~~mm_abt_5~~CalledByGraph proc~mm_abt_5 formatmul_opts::mm_ABT_5 proc~mat_mat_rel_abt_opt formatmul_opts::mat_mat_rel_ABT_opt proc~mat_mat_rel_abt_opt->proc~mm_abt_5 proc~mat_mat_rel_abt formatmul::mat_mat_rel_ABT proc~mat_mat_rel_abt->proc~mat_mat_rel_abt_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_abt interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_ABT_5 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 1 ) n = size ( A , 2 ) p = size ( B , 1 ) do i = 1 , n do j = 1 , m do k = 1 , p c ( j , k ) = c ( j , k ) + a ( j , i ) * b ( k , i ) end do end do end do end subroutine mm_ABT_5","tags":"","loc":"proc/mm_abt_5.html"},{"title":"mm_ABT_6 – ForMatmul","text":"private pure subroutine mm_ABT_6(A, B, C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) Called by proc~~mm_abt_6~~CalledByGraph proc~mm_abt_6 formatmul_opts::mm_ABT_6 proc~mat_mat_rel_abt_opt formatmul_opts::mat_mat_rel_ABT_opt proc~mat_mat_rel_abt_opt->proc~mm_abt_6 proc~mat_mat_rel_abt formatmul::mat_mat_rel_ABT proc~mat_mat_rel_abt->proc~mat_mat_rel_abt_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_abt interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_ABT_6 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 1 ) n = size ( A , 2 ) p = size ( B , 1 ) do i = 1 , n do j = 1 , p do k = 1 , m c ( k , j ) = c ( k , j ) + a ( k , i ) * b ( j , i ) end do end do end do end subroutine mm_ABT_6","tags":"","loc":"proc/mm_abt_6.html"},{"title":"mm_ABT_7 – ForMatmul","text":"private pure subroutine mm_ABT_7(A, B, C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) Called by proc~~mm_abt_7~~CalledByGraph proc~mm_abt_7 formatmul_opts::mm_ABT_7 proc~mat_mat_rel_abt_opt formatmul_opts::mat_mat_rel_ABT_opt proc~mat_mat_rel_abt_opt->proc~mm_abt_7 proc~mat_mat_rel_abt formatmul::mat_mat_rel_ABT proc~mat_mat_rel_abt->proc~mat_mat_rel_abt_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_abt interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_ABT_7 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 1 ) n = size ( A , 2 ) p = size ( B , 1 ) do i = 1 , p do j = 1 , m do k = 1 , n c ( j , i ) = c ( j , i ) + a ( j , k ) * b ( i , k ) end do end do end do end subroutine mm_ABT_7","tags":"","loc":"proc/mm_abt_7.html"},{"title":"mm_ABT_8 – ForMatmul","text":"private pure subroutine mm_ABT_8(A, B, C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) Called by proc~~mm_abt_8~~CalledByGraph proc~mm_abt_8 formatmul_opts::mm_ABT_8 proc~mat_mat_rel_abt_opt formatmul_opts::mat_mat_rel_ABT_opt proc~mat_mat_rel_abt_opt->proc~mm_abt_8 proc~mat_mat_rel_abt formatmul::mat_mat_rel_ABT proc~mat_mat_rel_abt->proc~mat_mat_rel_abt_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_abt interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_ABT_8 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 1 ) n = size ( A , 2 ) p = size ( B , 1 ) do i = 1 , p do j = 1 , n do k = 1 , m c ( k , i ) = c ( k , i ) + a ( k , j ) * b ( i , j ) end do end do end do end subroutine mm_ABT_8","tags":"","loc":"proc/mm_abt_8.html"},{"title":"mm_ABT_9 – ForMatmul","text":"private pure subroutine mm_ABT_9(A, B, C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) Called by proc~~mm_abt_9~~CalledByGraph proc~mm_abt_9 formatmul_opts::mm_ABT_9 proc~mat_mat_rel_abt_opt formatmul_opts::mat_mat_rel_ABT_opt proc~mat_mat_rel_abt_opt->proc~mm_abt_9 proc~mat_mat_rel_abt formatmul::mat_mat_rel_ABT proc~mat_mat_rel_abt->proc~mat_mat_rel_abt_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_abt interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_ABT_9 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , p integer :: i , k m = size ( A , 1 ) p = size ( B , 1 ) do i = 1 , p do k = 1 , m c ( k , i ) = dot_product ( a ( k ,:), b ( i ,:)) end do end do end subroutine mm_ABT_9","tags":"","loc":"proc/mm_abt_9.html"},{"title":"mm_ABT_10 – ForMatmul","text":"private pure subroutine mm_ABT_10(A, B, C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) Called by proc~~mm_abt_10~~CalledByGraph proc~mm_abt_10 formatmul_opts::mm_ABT_10 proc~mat_mat_rel_abt_opt formatmul_opts::mat_mat_rel_ABT_opt proc~mat_mat_rel_abt_opt->proc~mm_abt_10 proc~mat_mat_rel_abt formatmul::mat_mat_rel_ABT proc~mat_mat_rel_abt->proc~mat_mat_rel_abt_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_abt interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_ABT_10 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , p integer :: i , k m = size ( A , 1 ) p = size ( B , 1 ) error stop 'ForMatMul: shared is not supported in gfortran' !   do concurrent (i = 1: p) shared(m, p) ! check shared variables !     do k = 1, m !         c(k,i) = dot_product(a(k,:), b(i,:)) !     end do !   end do end subroutine mm_ABT_10","tags":"","loc":"proc/mm_abt_10.html"},{"title":"mm_ABT_11 – ForMatmul","text":"private pure subroutine mm_ABT_11(A, B, C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) Called by proc~~mm_abt_11~~CalledByGraph proc~mm_abt_11 formatmul_opts::mm_ABT_11 proc~mat_mat_rel_abt_opt formatmul_opts::mat_mat_rel_ABT_opt proc~mat_mat_rel_abt_opt->proc~mm_abt_11 proc~mat_mat_rel_abt formatmul::mat_mat_rel_ABT proc~mat_mat_rel_abt->proc~mat_mat_rel_abt_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_abt interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_ABT_11 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 1 ) n = size ( A , 2 ) p = size ( B , 1 ) error stop 'ForMatMul: shared is not supported in gfortran' !    do concurrent (i = 1: p) shared(m, n, p) ! check shared variables !         do j=1,n !             do k=1,m !                 c(k,i) = c(k,i) + a(k,j)*b(i,j) !             end do !         end do !     end do end subroutine mm_ABT_11","tags":"","loc":"proc/mm_abt_11.html"},{"title":"mm_ABT_12 – ForMatmul","text":"private pure subroutine mm_ABT_12(A, B, C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) Called by proc~~mm_abt_12~~CalledByGraph proc~mm_abt_12 formatmul_opts::mm_ABT_12 proc~mat_mat_rel_abt_opt formatmul_opts::mat_mat_rel_ABT_opt proc~mat_mat_rel_abt_opt->proc~mm_abt_12 proc~mat_mat_rel_abt formatmul::mat_mat_rel_ABT proc~mat_mat_rel_abt->proc~mat_mat_rel_abt_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_abt interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_ABT_12 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) interface pure subroutine impure_mm_ABT_12 ( f_a , f_b , f_c ) import rk real ( rk ), intent ( in ) :: f_a (:,:), f_b (:,:) real ( rk ), intent ( inout ) :: f_c (:,:) end subroutine impure_mm_ABT_12 end interface call impure_mm_ABT_12 ( a , b , c ) end subroutine mm_ABT_12","tags":"","loc":"proc/mm_abt_12.html"},{"title":"mm_ABT_13 – ForMatmul","text":"private pure subroutine mm_ABT_13(A, B, C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) Called by proc~~mm_abt_13~~CalledByGraph proc~mm_abt_13 formatmul_opts::mm_ABT_13 proc~mat_mat_rel_abt_opt formatmul_opts::mat_mat_rel_ABT_opt proc~mat_mat_rel_abt_opt->proc~mm_abt_13 proc~mat_mat_rel_abt formatmul::mat_mat_rel_ABT proc~mat_mat_rel_abt->proc~mat_mat_rel_abt_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_abt interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_ABT_13 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) interface pure subroutine impure_mm_ABT_13 ( f_a , f_b , f_c ) import rk real ( rk ), intent ( in ) :: f_a (:,:), f_b (:,:) real ( rk ), intent ( inout ) :: f_c (:,:) end subroutine impure_mm_ABT_13 end interface call impure_mm_ABT_13 ( a , b , c ) end subroutine mm_ABT_13","tags":"","loc":"proc/mm_abt_13.html"},{"title":"mm_ATBT_1 – ForMatmul","text":"private pure subroutine mm_ATBT_1(A, B, C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) Called by proc~~mm_atbt_1~~CalledByGraph proc~mm_atbt_1 formatmul_opts::mm_ATBT_1 proc~mat_mat_rel_atbt_opt formatmul_opts::mat_mat_rel_ATBT_opt proc~mat_mat_rel_atbt_opt->proc~mm_atbt_1 proc~mat_mat_rel_atbt formatmul::mat_mat_rel_ATBT proc~mat_mat_rel_atbt->proc~mat_mat_rel_atbt_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_atbt interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_ATBT_1 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) C = matmul ( transpose ( A ), transpose ( B )) end subroutine mm_ATBT_1","tags":"","loc":"proc/mm_atbt_1.html"},{"title":"mm_ATBT_2 – ForMatmul","text":"private pure subroutine mm_ATBT_2(A, B, C) Uses external_interfaces_matmul proc~~mm_atbt_2~~UsesGraph proc~mm_atbt_2 formatmul_opts::mm_ATBT_2 module~external_interfaces_matmul external_interfaces_matmul proc~mm_atbt_2->module~external_interfaces_matmul kinds kinds module~external_interfaces_matmul->kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) Calls proc~~mm_atbt_2~~CallsGraph proc~mm_atbt_2 formatmul_opts::mm_ATBT_2 interface~gemm external_interfaces_matmul::gemm proc~mm_atbt_2->interface~gemm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~mm_atbt_2~~CalledByGraph proc~mm_atbt_2 formatmul_opts::mm_ATBT_2 proc~mat_mat_rel_atbt_opt formatmul_opts::mat_mat_rel_ATBT_opt proc~mat_mat_rel_atbt_opt->proc~mm_atbt_2 proc~mat_mat_rel_atbt formatmul::mat_mat_rel_ATBT proc~mat_mat_rel_atbt->proc~mat_mat_rel_atbt_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_atbt interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_ATBT_2 ( A , B , C ) use external_interfaces_matmul real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p m = size ( A , 2 ) n = size ( A , 1 ) p = size ( B , 1 ) ! Call BLAS gemm subroutine for matrix-matrix multiplication. call gemm ( 'T' , 'T' , m , p , n , 1.0_rk , A , n , B , p , 0.0_rk , C , m ) end subroutine mm_ATBT_2","tags":"","loc":"proc/mm_atbt_2.html"},{"title":"mm_ATBT_3 – ForMatmul","text":"private pure subroutine mm_ATBT_3(A, B, C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) Called by proc~~mm_atbt_3~~CalledByGraph proc~mm_atbt_3 formatmul_opts::mm_ATBT_3 proc~mat_mat_rel_atbt_opt formatmul_opts::mat_mat_rel_ATBT_opt proc~mat_mat_rel_atbt_opt->proc~mm_atbt_3 proc~mat_mat_rel_atbt formatmul::mat_mat_rel_ATBT proc~mat_mat_rel_atbt->proc~mat_mat_rel_atbt_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_atbt interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_ATBT_3 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 2 ) n = size ( A , 1 ) p = size ( B , 1 ) do i = 1 , m do j = 1 , n do k = 1 , p c ( i , k ) = c ( i , k ) + a ( j , i ) * b ( k , j ) end do end do end do end subroutine mm_ATBT_3","tags":"","loc":"proc/mm_atbt_3.html"},{"title":"mm_ATBT_4 – ForMatmul","text":"private pure subroutine mm_ATBT_4(A, B, C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) Called by proc~~mm_atbt_4~~CalledByGraph proc~mm_atbt_4 formatmul_opts::mm_ATBT_4 proc~mat_mat_rel_atbt_opt formatmul_opts::mat_mat_rel_ATBT_opt proc~mat_mat_rel_atbt_opt->proc~mm_atbt_4 proc~mat_mat_rel_atbt formatmul::mat_mat_rel_ATBT proc~mat_mat_rel_atbt->proc~mat_mat_rel_atbt_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_atbt interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_ATBT_4 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 2 ) n = size ( A , 1 ) p = size ( B , 1 ) do i = 1 , m do j = 1 , p do k = 1 , n c ( i , j ) = c ( i , j ) + a ( k , i ) * b ( j , k ) end do end do end do end subroutine mm_ATBT_4","tags":"","loc":"proc/mm_atbt_4.html"},{"title":"mm_ATBT_5 – ForMatmul","text":"private pure subroutine mm_ATBT_5(A, B, C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) Called by proc~~mm_atbt_5~~CalledByGraph proc~mm_atbt_5 formatmul_opts::mm_ATBT_5 proc~mat_mat_rel_atbt_opt formatmul_opts::mat_mat_rel_ATBT_opt proc~mat_mat_rel_atbt_opt->proc~mm_atbt_5 proc~mat_mat_rel_atbt formatmul::mat_mat_rel_ATBT proc~mat_mat_rel_atbt->proc~mat_mat_rel_atbt_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_atbt interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_ATBT_5 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 2 ) n = size ( A , 1 ) p = size ( B , 1 ) do i = 1 , n do j = 1 , m do k = 1 , p c ( j , k ) = c ( j , k ) + a ( i , j ) * b ( k , i ) end do end do end do end subroutine mm_ATBT_5","tags":"","loc":"proc/mm_atbt_5.html"},{"title":"mm_ATBT_6 – ForMatmul","text":"private pure subroutine mm_ATBT_6(A, B, C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) Called by proc~~mm_atbt_6~~CalledByGraph proc~mm_atbt_6 formatmul_opts::mm_ATBT_6 proc~mat_mat_rel_atbt_opt formatmul_opts::mat_mat_rel_ATBT_opt proc~mat_mat_rel_atbt_opt->proc~mm_atbt_6 proc~mat_mat_rel_atbt formatmul::mat_mat_rel_ATBT proc~mat_mat_rel_atbt->proc~mat_mat_rel_atbt_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_atbt interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_ATBT_6 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 2 ) n = size ( A , 1 ) p = size ( B , 1 ) do i = 1 , n do j = 1 , p do k = 1 , m c ( k , j ) = c ( k , j ) + a ( i , k ) * b ( j , i ) end do end do end do end subroutine mm_ATBT_6","tags":"","loc":"proc/mm_atbt_6.html"},{"title":"mm_ATBT_7 – ForMatmul","text":"private pure subroutine mm_ATBT_7(A, B, C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) Called by proc~~mm_atbt_7~~CalledByGraph proc~mm_atbt_7 formatmul_opts::mm_ATBT_7 proc~mat_mat_rel_atbt_opt formatmul_opts::mat_mat_rel_ATBT_opt proc~mat_mat_rel_atbt_opt->proc~mm_atbt_7 proc~mat_mat_rel_atbt formatmul::mat_mat_rel_ATBT proc~mat_mat_rel_atbt->proc~mat_mat_rel_atbt_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_atbt interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_ATBT_7 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 2 ) n = size ( A , 1 ) p = size ( B , 1 ) do i = 1 , p do j = 1 , m do k = 1 , n c ( j , i ) = c ( j , i ) + a ( k , j ) * b ( i , k ) end do end do end do end subroutine mm_ATBT_7","tags":"","loc":"proc/mm_atbt_7.html"},{"title":"mm_ATBT_8 – ForMatmul","text":"private pure subroutine mm_ATBT_8(A, B, C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) Called by proc~~mm_atbt_8~~CalledByGraph proc~mm_atbt_8 formatmul_opts::mm_ATBT_8 proc~mat_mat_rel_atbt_opt formatmul_opts::mat_mat_rel_ATBT_opt proc~mat_mat_rel_atbt_opt->proc~mm_atbt_8 proc~mat_mat_rel_atbt formatmul::mat_mat_rel_ATBT proc~mat_mat_rel_atbt->proc~mat_mat_rel_atbt_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_atbt interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_ATBT_8 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 2 ) n = size ( A , 1 ) p = size ( B , 1 ) do i = 1 , p do j = 1 , n do k = 1 , m c ( k , i ) = c ( k , i ) + a ( j , k ) * b ( i , j ) end do end do end do end subroutine mm_ATBT_8","tags":"","loc":"proc/mm_atbt_8.html"},{"title":"mm_ATBT_9 – ForMatmul","text":"private pure subroutine mm_ATBT_9(A, B, C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) Called by proc~~mm_atbt_9~~CalledByGraph proc~mm_atbt_9 formatmul_opts::mm_ATBT_9 proc~mat_mat_rel_atbt_opt formatmul_opts::mat_mat_rel_ATBT_opt proc~mat_mat_rel_atbt_opt->proc~mm_atbt_9 proc~mat_mat_rel_atbt formatmul::mat_mat_rel_ATBT proc~mat_mat_rel_atbt->proc~mat_mat_rel_atbt_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_atbt interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_ATBT_9 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , p integer :: i , k m = size ( A , 2 ) p = size ( B , 1 ) do i = 1 , p do k = 1 , m c ( k , i ) = dot_product ( a (:, k ), b ( i ,:)) end do end do end subroutine mm_ATBT_9","tags":"","loc":"proc/mm_atbt_9.html"},{"title":"mm_ATBT_10 – ForMatmul","text":"private pure subroutine mm_ATBT_10(A, B, C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) Called by proc~~mm_atbt_10~~CalledByGraph proc~mm_atbt_10 formatmul_opts::mm_ATBT_10 proc~mat_mat_rel_atbt_opt formatmul_opts::mat_mat_rel_ATBT_opt proc~mat_mat_rel_atbt_opt->proc~mm_atbt_10 proc~mat_mat_rel_atbt formatmul::mat_mat_rel_ATBT proc~mat_mat_rel_atbt->proc~mat_mat_rel_atbt_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_atbt interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_ATBT_10 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , p integer :: i , k m = size ( A , 2 ) p = size ( B , 1 ) error stop 'ForMatMul: shared is not supported in gfortran' !   do concurrent (i = 1: p) shared(m, p) ! check shared variables !     do k = 1, m !         c(k,i) = dot_product(a(:,k), b(i,:)) !     end do !   end do end subroutine mm_ATBT_10","tags":"","loc":"proc/mm_atbt_10.html"},{"title":"mm_ATBT_11 – ForMatmul","text":"private pure subroutine mm_ATBT_11(A, B, C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) Called by proc~~mm_atbt_11~~CalledByGraph proc~mm_atbt_11 formatmul_opts::mm_ATBT_11 proc~mat_mat_rel_atbt_opt formatmul_opts::mat_mat_rel_ATBT_opt proc~mat_mat_rel_atbt_opt->proc~mm_atbt_11 proc~mat_mat_rel_atbt formatmul::mat_mat_rel_ATBT proc~mat_mat_rel_atbt->proc~mat_mat_rel_atbt_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_atbt interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_ATBT_11 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 2 ) n = size ( A , 1 ) p = size ( B , 1 ) error stop 'ForMatMul: shared is not supported in gfortran' !    do concurrent (i = 1: p) shared(m, n, p) ! check shared variables !         do j=1,n !             do k=1,m !                 c(k,i) = c(k,i) + a(j,k)*b(i,j) !             end do !         end do !     end do end subroutine mm_ATBT_11","tags":"","loc":"proc/mm_atbt_11.html"},{"title":"mm_ATBT_12 – ForMatmul","text":"private pure subroutine mm_ATBT_12(A, B, C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) Called by proc~~mm_atbt_12~~CalledByGraph proc~mm_atbt_12 formatmul_opts::mm_ATBT_12 proc~mat_mat_rel_atbt_opt formatmul_opts::mat_mat_rel_ATBT_opt proc~mat_mat_rel_atbt_opt->proc~mm_atbt_12 proc~mat_mat_rel_atbt formatmul::mat_mat_rel_ATBT proc~mat_mat_rel_atbt->proc~mat_mat_rel_atbt_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_atbt interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_ATBT_12 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) interface pure subroutine impure_mm_ATBT_12 ( f_a , f_b , f_c ) import rk real ( rk ), intent ( in ) :: f_a (:,:), f_b (:,:) real ( rk ), intent ( inout ) :: f_c (:,:) end subroutine impure_mm_ATBT_12 end interface call impure_mm_ATBT_12 ( a , b , c ) end subroutine mm_ATBT_12","tags":"","loc":"proc/mm_atbt_12.html"},{"title":"mm_ATBT_13 – ForMatmul","text":"private pure subroutine mm_ATBT_13(A, B, C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) Called by proc~~mm_atbt_13~~CalledByGraph proc~mm_atbt_13 formatmul_opts::mm_ATBT_13 proc~mat_mat_rel_atbt_opt formatmul_opts::mat_mat_rel_ATBT_opt proc~mat_mat_rel_atbt_opt->proc~mm_atbt_13 proc~mat_mat_rel_atbt formatmul::mat_mat_rel_ATBT proc~mat_mat_rel_atbt->proc~mat_mat_rel_atbt_opt proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_atbt interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mm_ATBT_13 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) interface pure subroutine impure_mm_ATBT_13 ( f_a , f_b , f_c ) import rk real ( rk ), intent ( in ) :: f_a (:,:), f_b (:,:) real ( rk ), intent ( inout ) :: f_c (:,:) end subroutine impure_mm_ATBT_13 end interface call impure_mm_ATBT_13 ( a , b , c ) end subroutine mm_ATBT_13","tags":"","loc":"proc/mm_atbt_13.html"},{"title":"mv_Av_1 – ForMatmul","text":"private pure subroutine mv_Av_1(A, v, w) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) real(kind=rk), intent(inout), contiguous :: w (:) Called by proc~~mv_av_1~~CalledByGraph proc~mv_av_1 formatmul_opts::mv_Av_1 proc~mat_vec_rel_av_opt formatmul_opts::mat_vec_rel_Av_opt proc~mat_vec_rel_av_opt->proc~mv_av_1 proc~mat_vec_rel_av formatmul::mat_vec_rel_Av proc~mat_vec_rel_av->proc~mat_vec_rel_av_opt proc~mat_vec_rel formatmul::mat_vec_rel proc~mat_vec_rel->proc~mat_vec_rel_av interface~matmul formatmul::matmul interface~matmul->proc~mat_vec_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mv_Av_1 ( A , v , w ) real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) real ( rk ), intent ( inout ), contiguous :: w (:) w = matmul ( A , v ) end subroutine mv_Av_1","tags":"","loc":"proc/mv_av_1.html"},{"title":"mv_Av_2 – ForMatmul","text":"private pure subroutine mv_Av_2(A, v, w) Uses external_interfaces_matmul proc~~mv_av_2~~UsesGraph proc~mv_av_2 formatmul_opts::mv_Av_2 module~external_interfaces_matmul external_interfaces_matmul proc~mv_av_2->module~external_interfaces_matmul kinds kinds module~external_interfaces_matmul->kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) real(kind=rk), intent(inout), contiguous :: w (:) Calls proc~~mv_av_2~~CallsGraph proc~mv_av_2 formatmul_opts::mv_Av_2 interface~gemv external_interfaces_matmul::gemv proc~mv_av_2->interface~gemv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~mv_av_2~~CalledByGraph proc~mv_av_2 formatmul_opts::mv_Av_2 proc~mat_vec_rel_av_opt formatmul_opts::mat_vec_rel_Av_opt proc~mat_vec_rel_av_opt->proc~mv_av_2 proc~mat_vec_rel_av formatmul::mat_vec_rel_Av proc~mat_vec_rel_av->proc~mat_vec_rel_av_opt proc~mat_vec_rel formatmul::mat_vec_rel proc~mat_vec_rel->proc~mat_vec_rel_av interface~matmul formatmul::matmul interface~matmul->proc~mat_vec_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mv_Av_2 ( A , v , w ) use external_interfaces_matmul real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) real ( rk ), intent ( inout ), contiguous :: w (:) integer :: m m = size ( A , 1 ) ! Call BLAS gemv subroutine for matrix-vector multiplication. call gemv ( 'N' , m , size ( A , 2 ), 1.0_rk , A , m , v , 1 , 0.0_rk , w , 1 ) end subroutine mv_Av_2","tags":"","loc":"proc/mv_av_2.html"},{"title":"mv_Av_3 – ForMatmul","text":"private pure subroutine mv_Av_3(A, v, w) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) real(kind=rk), intent(inout), contiguous :: w (:) Called by proc~~mv_av_3~~CalledByGraph proc~mv_av_3 formatmul_opts::mv_Av_3 proc~mat_vec_rel_av_opt formatmul_opts::mat_vec_rel_Av_opt proc~mat_vec_rel_av_opt->proc~mv_av_3 proc~mat_vec_rel_av formatmul::mat_vec_rel_Av proc~mat_vec_rel_av->proc~mat_vec_rel_av_opt proc~mat_vec_rel formatmul::mat_vec_rel proc~mat_vec_rel->proc~mat_vec_rel_av interface~matmul formatmul::matmul interface~matmul->proc~mat_vec_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mv_Av_3 ( A , v , w ) real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) real ( rk ), intent ( inout ), contiguous :: w (:) integer :: m , n integer :: i , j m = size ( A , 1 ) n = size ( A , 2 ) do i = 1 , m do j = 1 , n w ( i ) = w ( i ) + a ( i , j ) * v ( j ) end do end do end subroutine mv_Av_3","tags":"","loc":"proc/mv_av_3.html"},{"title":"mv_Av_4 – ForMatmul","text":"private pure subroutine mv_Av_4(A, v, w) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) real(kind=rk), intent(inout), contiguous :: w (:) Called by proc~~mv_av_4~~CalledByGraph proc~mv_av_4 formatmul_opts::mv_Av_4 proc~mat_vec_rel_av_opt formatmul_opts::mat_vec_rel_Av_opt proc~mat_vec_rel_av_opt->proc~mv_av_4 proc~mat_vec_rel_av formatmul::mat_vec_rel_Av proc~mat_vec_rel_av->proc~mat_vec_rel_av_opt proc~mat_vec_rel formatmul::mat_vec_rel proc~mat_vec_rel->proc~mat_vec_rel_av interface~matmul formatmul::matmul interface~matmul->proc~mat_vec_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mv_Av_4 ( A , v , w ) real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) real ( rk ), intent ( inout ), contiguous :: w (:) integer :: m , n integer :: i , j m = size ( A , 1 ) n = size ( A , 2 ) do j = 1 , n do i = 1 , m w ( i ) = w ( i ) + a ( i , j ) * v ( j ) end do end do end subroutine mv_Av_4","tags":"","loc":"proc/mv_av_4.html"},{"title":"mv_Av_5 – ForMatmul","text":"private pure subroutine mv_Av_5(A, v, w) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) real(kind=rk), intent(inout), contiguous :: w (:) Called by proc~~mv_av_5~~CalledByGraph proc~mv_av_5 formatmul_opts::mv_Av_5 proc~mat_vec_rel_av_opt formatmul_opts::mat_vec_rel_Av_opt proc~mat_vec_rel_av_opt->proc~mv_av_5 proc~mat_vec_rel_av formatmul::mat_vec_rel_Av proc~mat_vec_rel_av->proc~mat_vec_rel_av_opt proc~mat_vec_rel formatmul::mat_vec_rel proc~mat_vec_rel->proc~mat_vec_rel_av interface~matmul formatmul::matmul interface~matmul->proc~mat_vec_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mv_Av_5 ( A , v , w ) real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) real ( rk ), intent ( inout ), contiguous :: w (:) integer :: m integer :: k m = size ( A , 1 ) do k = 1 , m w ( k ) = dot_product ( a ( k ,:), v (:)) end do end subroutine mv_Av_5","tags":"","loc":"proc/mv_av_5.html"},{"title":"mv_Av_6 – ForMatmul","text":"private pure subroutine mv_Av_6(A, v, w) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) real(kind=rk), intent(inout), contiguous :: w (:) Called by proc~~mv_av_6~~CalledByGraph proc~mv_av_6 formatmul_opts::mv_Av_6 proc~mat_vec_rel_av_opt formatmul_opts::mat_vec_rel_Av_opt proc~mat_vec_rel_av_opt->proc~mv_av_6 proc~mat_vec_rel_av formatmul::mat_vec_rel_Av proc~mat_vec_rel_av->proc~mat_vec_rel_av_opt proc~mat_vec_rel formatmul::mat_vec_rel proc~mat_vec_rel->proc~mat_vec_rel_av interface~matmul formatmul::matmul interface~matmul->proc~mat_vec_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mv_Av_6 ( A , v , w ) real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) real ( rk ), intent ( inout ), contiguous :: w (:) integer :: n integer :: k n = size ( A , 2 ) do k = 1 , n w (:) = w (:) + a (:, k ) * v ( k ) end do end subroutine mv_Av_6","tags":"","loc":"proc/mv_av_6.html"},{"title":"mv_Av_7 – ForMatmul","text":"private pure subroutine mv_Av_7(A, v, w) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) real(kind=rk), intent(inout), contiguous :: w (:) Called by proc~~mv_av_7~~CalledByGraph proc~mv_av_7 formatmul_opts::mv_Av_7 proc~mat_vec_rel_av_opt formatmul_opts::mat_vec_rel_Av_opt proc~mat_vec_rel_av_opt->proc~mv_av_7 proc~mat_vec_rel_av formatmul::mat_vec_rel_Av proc~mat_vec_rel_av->proc~mat_vec_rel_av_opt proc~mat_vec_rel formatmul::mat_vec_rel proc~mat_vec_rel->proc~mat_vec_rel_av interface~matmul formatmul::matmul interface~matmul->proc~mat_vec_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mv_Av_7 ( A , v , w ) real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) real ( rk ), intent ( inout ), contiguous :: w (:) integer :: m , n integer :: k m = size ( A , 1 ) error stop 'ForMatMul: shared is not supported in gfortran' !   do concurrent (k = 1: m) shared(m,a,v) ! check shared variables !      w(k) = dot_product(a(k,:), v(:)) !   end do end subroutine mv_Av_7","tags":"","loc":"proc/mv_av_7.html"},{"title":"mv_Av_8 – ForMatmul","text":"private pure subroutine mv_Av_8(A, v, w) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) real(kind=rk), intent(inout), contiguous :: w (:) Called by proc~~mv_av_8~~CalledByGraph proc~mv_av_8 formatmul_opts::mv_Av_8 proc~mat_vec_rel_av_opt formatmul_opts::mat_vec_rel_Av_opt proc~mat_vec_rel_av_opt->proc~mv_av_8 proc~mat_vec_rel_av formatmul::mat_vec_rel_Av proc~mat_vec_rel_av->proc~mat_vec_rel_av_opt proc~mat_vec_rel formatmul::mat_vec_rel proc~mat_vec_rel->proc~mat_vec_rel_av interface~matmul formatmul::matmul interface~matmul->proc~mat_vec_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mv_Av_8 ( A , v , w ) real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) real ( rk ), intent ( inout ), contiguous :: w (:) integer :: m , n integer :: i , j m = size ( A , 1 ) n = size ( A , 2 ) error stop 'ForMatMul: shared is not supported in gfortran' !   do concurrent(i=1:m) shared(m, n, a, v) ! check shared variables !      do j=1,n !         w(i) = w(i) + a(i,j)*v(j) !      end do !   end do end subroutine mv_Av_8","tags":"","loc":"proc/mv_av_8.html"},{"title":"mv_ATv_1 – ForMatmul","text":"private pure subroutine mv_ATv_1(A, v, w) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) real(kind=rk), intent(inout), contiguous :: w (:) Called by proc~~mv_atv_1~~CalledByGraph proc~mv_atv_1 formatmul_opts::mv_ATv_1 proc~mat_vec_rel_atv_opt formatmul_opts::mat_vec_rel_ATv_opt proc~mat_vec_rel_atv_opt->proc~mv_atv_1 proc~mat_vec_rel_atv formatmul::mat_vec_rel_ATv proc~mat_vec_rel_atv->proc~mat_vec_rel_atv_opt proc~mat_vec_rel formatmul::mat_vec_rel proc~mat_vec_rel->proc~mat_vec_rel_atv interface~matmul formatmul::matmul interface~matmul->proc~mat_vec_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mv_ATv_1 ( A , v , w ) real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) real ( rk ), intent ( inout ), contiguous :: w (:) w = matmul ( transpose ( A ), v ) end subroutine mv_ATv_1","tags":"","loc":"proc/mv_atv_1.html"},{"title":"mv_ATv_2 – ForMatmul","text":"private pure subroutine mv_ATv_2(A, v, w) Uses external_interfaces_matmul proc~~mv_atv_2~~UsesGraph proc~mv_atv_2 formatmul_opts::mv_ATv_2 module~external_interfaces_matmul external_interfaces_matmul proc~mv_atv_2->module~external_interfaces_matmul kinds kinds module~external_interfaces_matmul->kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) real(kind=rk), intent(inout), contiguous :: w (:) Calls proc~~mv_atv_2~~CallsGraph proc~mv_atv_2 formatmul_opts::mv_ATv_2 interface~gemv external_interfaces_matmul::gemv proc~mv_atv_2->interface~gemv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~mv_atv_2~~CalledByGraph proc~mv_atv_2 formatmul_opts::mv_ATv_2 proc~mat_vec_rel_atv_opt formatmul_opts::mat_vec_rel_ATv_opt proc~mat_vec_rel_atv_opt->proc~mv_atv_2 proc~mat_vec_rel_atv formatmul::mat_vec_rel_ATv proc~mat_vec_rel_atv->proc~mat_vec_rel_atv_opt proc~mat_vec_rel formatmul::mat_vec_rel proc~mat_vec_rel->proc~mat_vec_rel_atv interface~matmul formatmul::matmul interface~matmul->proc~mat_vec_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mv_ATv_2 ( A , v , w ) use external_interfaces_matmul real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) real ( rk ), intent ( inout ), contiguous :: w (:) integer :: m m = size ( A , 1 ) ! Call BLAS gemv subroutine for matrix-vector multiplication. call gemv ( 'T' , m , size ( A , 2 ), 1.0_rk , A , m , v , 1 , 0.0_rk , w , 1 ) end subroutine mv_ATv_2","tags":"","loc":"proc/mv_atv_2.html"},{"title":"mv_ATv_3 – ForMatmul","text":"private pure subroutine mv_ATv_3(A, v, w) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) real(kind=rk), intent(inout), contiguous :: w (:) Called by proc~~mv_atv_3~~CalledByGraph proc~mv_atv_3 formatmul_opts::mv_ATv_3 proc~mat_vec_rel_atv_opt formatmul_opts::mat_vec_rel_ATv_opt proc~mat_vec_rel_atv_opt->proc~mv_atv_3 proc~mat_vec_rel_atv formatmul::mat_vec_rel_ATv proc~mat_vec_rel_atv->proc~mat_vec_rel_atv_opt proc~mat_vec_rel formatmul::mat_vec_rel proc~mat_vec_rel->proc~mat_vec_rel_atv interface~matmul formatmul::matmul interface~matmul->proc~mat_vec_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mv_ATv_3 ( A , v , w ) real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) real ( rk ), intent ( inout ), contiguous :: w (:) integer :: m , n integer :: i , j m = size ( A , 2 ) n = size ( A , 1 ) do i = 1 , m do j = 1 , n w ( i ) = w ( i ) + a ( j , i ) * v ( j ) end do end do end subroutine mv_ATv_3","tags":"","loc":"proc/mv_atv_3.html"},{"title":"mv_ATv_4 – ForMatmul","text":"private pure subroutine mv_ATv_4(A, v, w) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) real(kind=rk), intent(inout), contiguous :: w (:) Called by proc~~mv_atv_4~~CalledByGraph proc~mv_atv_4 formatmul_opts::mv_ATv_4 proc~mat_vec_rel_atv_opt formatmul_opts::mat_vec_rel_ATv_opt proc~mat_vec_rel_atv_opt->proc~mv_atv_4 proc~mat_vec_rel_atv formatmul::mat_vec_rel_ATv proc~mat_vec_rel_atv->proc~mat_vec_rel_atv_opt proc~mat_vec_rel formatmul::mat_vec_rel proc~mat_vec_rel->proc~mat_vec_rel_atv interface~matmul formatmul::matmul interface~matmul->proc~mat_vec_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mv_ATv_4 ( A , v , w ) real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) real ( rk ), intent ( inout ), contiguous :: w (:) integer :: m , n integer :: i , j m = size ( A , 2 ) n = size ( A , 1 ) do j = 1 , n do i = 1 , m w ( i ) = w ( i ) + a ( j , i ) * v ( j ) end do end do end subroutine mv_ATv_4","tags":"","loc":"proc/mv_atv_4.html"},{"title":"mv_ATv_5 – ForMatmul","text":"private pure subroutine mv_ATv_5(A, v, w) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) real(kind=rk), intent(inout), contiguous :: w (:) Called by proc~~mv_atv_5~~CalledByGraph proc~mv_atv_5 formatmul_opts::mv_ATv_5 proc~mat_vec_rel_atv_opt formatmul_opts::mat_vec_rel_ATv_opt proc~mat_vec_rel_atv_opt->proc~mv_atv_5 proc~mat_vec_rel_atv formatmul::mat_vec_rel_ATv proc~mat_vec_rel_atv->proc~mat_vec_rel_atv_opt proc~mat_vec_rel formatmul::mat_vec_rel proc~mat_vec_rel->proc~mat_vec_rel_atv interface~matmul formatmul::matmul interface~matmul->proc~mat_vec_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mv_ATv_5 ( A , v , w ) real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) real ( rk ), intent ( inout ), contiguous :: w (:) integer :: m integer :: k m = size ( A , 2 ) do k = 1 , m w ( k ) = dot_product ( a (:, k ), v (:)) end do end subroutine mv_ATv_5","tags":"","loc":"proc/mv_atv_5.html"},{"title":"mv_ATv_6 – ForMatmul","text":"private pure subroutine mv_ATv_6(A, v, w) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) real(kind=rk), intent(inout), contiguous :: w (:) Called by proc~~mv_atv_6~~CalledByGraph proc~mv_atv_6 formatmul_opts::mv_ATv_6 proc~mat_vec_rel_atv_opt formatmul_opts::mat_vec_rel_ATv_opt proc~mat_vec_rel_atv_opt->proc~mv_atv_6 proc~mat_vec_rel_atv formatmul::mat_vec_rel_ATv proc~mat_vec_rel_atv->proc~mat_vec_rel_atv_opt proc~mat_vec_rel formatmul::mat_vec_rel proc~mat_vec_rel->proc~mat_vec_rel_atv interface~matmul formatmul::matmul interface~matmul->proc~mat_vec_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mv_ATv_6 ( A , v , w ) real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) real ( rk ), intent ( inout ), contiguous :: w (:) integer :: n integer :: k n = size ( A , 1 ) do k = 1 , n w (:) = w (:) + a ( k ,:) * v ( k ) end do end subroutine mv_ATv_6","tags":"","loc":"proc/mv_atv_6.html"},{"title":"mv_ATv_7 – ForMatmul","text":"private pure subroutine mv_ATv_7(A, v, w) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) real(kind=rk), intent(inout), contiguous :: w (:) Called by proc~~mv_atv_7~~CalledByGraph proc~mv_atv_7 formatmul_opts::mv_ATv_7 proc~mat_vec_rel_atv_opt formatmul_opts::mat_vec_rel_ATv_opt proc~mat_vec_rel_atv_opt->proc~mv_atv_7 proc~mat_vec_rel_atv formatmul::mat_vec_rel_ATv proc~mat_vec_rel_atv->proc~mat_vec_rel_atv_opt proc~mat_vec_rel formatmul::mat_vec_rel proc~mat_vec_rel->proc~mat_vec_rel_atv interface~matmul formatmul::matmul interface~matmul->proc~mat_vec_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mv_ATv_7 ( A , v , w ) real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) real ( rk ), intent ( inout ), contiguous :: w (:) integer :: m , n integer :: k m = size ( A , 2 ) error stop 'ForMatMul: shared is not supported in gfortran' !   do concurrent (k = 1: m) shared(m,a,v) ! check shared variables !      w(k) = dot_product(a(:,k), v(:)) !   end do end subroutine mv_ATv_7","tags":"","loc":"proc/mv_atv_7.html"},{"title":"mv_ATv_8 – ForMatmul","text":"private pure subroutine mv_ATv_8(A, v, w) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) real(kind=rk), intent(inout), contiguous :: w (:) Called by proc~~mv_atv_8~~CalledByGraph proc~mv_atv_8 formatmul_opts::mv_ATv_8 proc~mat_vec_rel_atv_opt formatmul_opts::mat_vec_rel_ATv_opt proc~mat_vec_rel_atv_opt->proc~mv_atv_8 proc~mat_vec_rel_atv formatmul::mat_vec_rel_ATv proc~mat_vec_rel_atv->proc~mat_vec_rel_atv_opt proc~mat_vec_rel formatmul::mat_vec_rel proc~mat_vec_rel->proc~mat_vec_rel_atv interface~matmul formatmul::matmul interface~matmul->proc~mat_vec_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mv_ATv_8 ( A , v , w ) real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) real ( rk ), intent ( inout ), contiguous :: w (:) integer :: m , n integer :: i , j m = size ( A , 2 ) n = size ( A , 1 ) error stop 'ForMatMul: shared is not supported in gfortran' !   do concurrent(i=1:m) shared(m, n, a, v) ! check shared variables !      do j=1,n !         w(i) = w(i) + a(j,i)*v(j) !      end do !   end do end subroutine mv_ATv_8","tags":"","loc":"proc/mv_atv_8.html"},{"title":"mat_mat_coarray_rel – ForMatmul","text":"private impure function mat_mat_coarray_rel(a, b, transA, transB, option, coarray) result(c) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: a (:,:) real(kind=rk), intent(in), contiguous :: b (:,:) logical, intent(in), optional :: transA logical, intent(in), optional :: transB character(len=*), intent(in), optional :: option logical, intent(in) :: coarray Return Value real(kind=rk), allocatable, (:,:) Calls proc~~mat_mat_coarray_rel~~CallsGraph proc~mat_mat_coarray_rel formatmul::mat_mat_coarray_rel proc~compute_block_ranges formatmul::compute_block_ranges proc~mat_mat_coarray_rel->proc~compute_block_ranges Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~mat_mat_coarray_rel~~CalledByGraph proc~mat_mat_coarray_rel formatmul::mat_mat_coarray_rel interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_coarray_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure function mat_mat_coarray_rel ( a , b , transA , transB , option , coarray ) result ( c ) real ( rk ), intent ( in ), contiguous :: a (:,:), b (:,:) character ( * ), intent ( in ), optional :: option logical , intent ( in ), optional :: transA , transB real ( rk ), allocatable :: c (:,:) logical , intent ( in ) :: coarray #if defined (USE_COARRAY) integer :: i , im , nimg , n , m integer :: block_size ( num_images ()), start_elem ( num_images ()), end_elem ( num_images ()) real ( rk ), allocatable :: C_block (:,:)[:], B_block (:,:)[:], A_block (:,:)[:] if ( present ( transA ) . and . present ( transB )) then if (. not . transA . and . . not . transB ) then ! AB allocate ( C ( size ( A , 1 ), size ( B , 2 )), source = 0.0_rk ) im = this_image () nimg = num_images () m = size ( A , 1 ) n = size ( A , 2 ) call compute_block_ranges ( size ( B , 2 ), nimg , block_size , start_elem , end_elem ) allocate ( B_block ( n , block_size ( im ))[ * ], C_block ( m , block_size ( im ))[ * ]) B_block (:,:)[ im ] = B (:, start_elem ( im ): end_elem ( im )) C_block (:,:)[ im ] = matmul ( A , B_block (:,:)[ im ], transA = . false ., transB = . false ., option = option ) sync all if ( im == 1 ) then do i = 1 , nimg C (:, start_elem ( i ): end_elem ( i )) = C_block (:,:)[ i ] end do end if else if ( transA . and . transB ) then ! ATBT allocate ( C ( size ( A , 2 ), size ( B , 1 )), source = 0.0_rk ) im = this_image () nimg = num_images () m = size ( A , 1 ) n = size ( A , 2 ) call compute_block_ranges ( size ( A , 2 ), nimg , block_size , start_elem , end_elem ) allocate ( A_block ( m , block_size ( im ))[ * ], C_block ( block_size ( im ), size ( B , 1 ))[ * ]) A_block (:,:)[ im ] = A (:, start_elem ( im ): end_elem ( im )) C_block (:,:)[ im ] = matmul ( A_block (:,:)[ im ], B , transA = . true ., transB = . true ., option = option ) sync all if ( im == 1 ) then do i = 1 , nimg C ( start_elem ( i ): end_elem ( i ), :) = C_block (:,:)[ i ] end do end if else if ( transA . and . . not . transB ) then ! ATB allocate ( C ( size ( A , 2 ), size ( B , 2 )), source = 0.0_rk ) im = this_image () nimg = num_images () m = size ( A , 1 ) n = size ( A , 2 ) call compute_block_ranges ( size ( A , 2 ), nimg , block_size , start_elem , end_elem ) allocate ( A_block ( m , block_size ( im ))[ * ], C_block ( block_size ( im ), size ( B , 2 ))[ * ]) A_block (:,:)[ im ] = A (:, start_elem ( im ): end_elem ( im )) C_block (:,:)[ im ] = matmul ( A_block (:, :)[ im ], B , transA = . true ., transB = . false ., option = option ) sync all if ( im == 1 ) then do i = 1 , nimg C ( start_elem ( i ): end_elem ( i ), :) = C_block (:,:)[ i ] end do end if else if (. not . transA . and . transB ) then ! ABT allocate ( C ( size ( A , 1 ), size ( B , 1 )), source = 0.0_rk ) im = this_image () nimg = num_images () m = size ( A , 1 ) n = size ( A , 2 ) call compute_block_ranges ( size ( A , 2 ), nimg , block_size , start_elem , end_elem ) allocate ( A_block ( m , block_size ( im ))[ * ], B_block ( size ( B , 1 ), block_size ( im ))[ * ]) allocate ( C_block ( m , size ( B , 1 ))[ * ]) A_block (:,:)[ im ] = A (:, start_elem ( im ): end_elem ( im )) B_block (:,:)[ im ] = B (:, start_elem ( im ): end_elem ( im )) C_block (:,:)[ im ] = matmul ( A_block (:,:)[ im ], B_block (:,:)[ im ], transA = . false ., transB = . true ., option = option ) sync all if ( im == 1 ) then do i = 1 , nimg C (:, :) = C (:, :) + C_block (:,:)[ i ] end do end if end if else if ( present ( transA ) . or . present ( transB )) then if ( present ( transA )) then if ( transA ) then ! ATB allocate ( C ( size ( A , 2 ), size ( B , 2 )), source = 0.0_rk ) im = this_image () nimg = num_images () m = size ( A , 1 ) n = size ( A , 2 ) call compute_block_ranges ( size ( A , 2 ), nimg , block_size , start_elem , end_elem ) allocate ( A_block ( m , block_size ( im ))[ * ], C_block ( block_size ( im ), size ( B , 2 ))[ * ]) A_block (:,:)[ im ] = A (:, start_elem ( im ): end_elem ( im )) C_block (:,:)[ im ] = matmul ( A_block (:, :)[ im ], B , transA = . true ., transB = . false ., option = option ) sync all if ( im == 1 ) then do i = 1 , nimg C ( start_elem ( i ): end_elem ( i ), :) = C_block (:,:)[ i ] end do end if else if (. not . transA ) then ! ABT allocate ( C ( size ( A , 1 ), size ( B , 1 )), source = 0.0_rk ) im = this_image () nimg = num_images () m = size ( A , 1 ) n = size ( A , 2 ) call compute_block_ranges ( size ( A , 2 ), nimg , block_size , start_elem , end_elem ) allocate ( A_block ( m , block_size ( im ))[ * ], B_block ( size ( B , 1 ), block_size ( im ))[ * ]) allocate ( C_block ( m , size ( B , 1 ))[ * ]) A_block (:,:)[ im ] = A (:, start_elem ( im ): end_elem ( im )) B_block (:,:)[ im ] = B (:, start_elem ( im ): end_elem ( im )) C_block (:,:)[ im ] = matmul ( A_block (:,:)[ im ], B_block (:,:)[ im ], transA = . false ., transB = . true ., option = option ) sync all if ( im == 1 ) then do i = 1 , nimg C (:, :) = C (:, :) + C_block (:,:)[ i ] end do end if end if else if ( present ( transB )) then if ( transB ) then ! ABT allocate ( C ( size ( A , 1 ), size ( B , 1 )), source = 0.0_rk ) im = this_image () nimg = num_images () m = size ( A , 1 ) n = size ( A , 2 ) call compute_block_ranges ( size ( A , 2 ), nimg , block_size , start_elem , end_elem ) allocate ( A_block ( m , block_size ( im ))[ * ], B_block ( size ( B , 1 ), block_size ( im ))[ * ]) allocate ( C_block ( m , size ( B , 1 ))[ * ]) A_block (:,:)[ im ] = A (:, start_elem ( im ): end_elem ( im )) B_block (:,:)[ im ] = B (:, start_elem ( im ): end_elem ( im )) C_block (:,:)[ im ] = matmul ( A_block (:,:)[ im ], B_block (:,:)[ im ], transA = . false ., transB = . true ., option = option ) sync all if ( im == 1 ) then do i = 1 , nimg C (:, :) = C (:, :) + C_block (:,:)[ i ] end do end if else if (. not . transB ) then ! ATB allocate ( C ( size ( A , 2 ), size ( B , 2 )), source = 0.0_rk ) im = this_image () nimg = num_images () m = size ( A , 1 ) n = size ( A , 2 ) call compute_block_ranges ( size ( A , 2 ), nimg , block_size , start_elem , end_elem ) allocate ( A_block ( m , block_size ( im ))[ * ], C_block ( block_size ( im ), size ( B , 2 ))[ * ]) A_block (:,:)[ im ] = A (:, start_elem ( im ): end_elem ( im )) C_block (:,:)[ im ] = matmul ( A_block (:, :)[ im ], B , transA = . true ., transB = . false ., option = option ) sync all if ( im == 1 ) then do i = 1 , nimg C ( start_elem ( i ): end_elem ( i ), :) = C_block (:,:)[ i ] end do end if end if end if else if (. not . present ( transA ) . and . . not . present ( transB )) then ! AB allocate ( C ( size ( A , 1 ), size ( B , 2 )), source = 0.0_rk ) im = this_image () nimg = num_images () m = size ( A , 1 ) n = size ( A , 2 ) call compute_block_ranges ( size ( B , 2 ), nimg , block_size , start_elem , end_elem ) allocate ( B_block ( n , block_size ( im ))[ * ], C_block ( m , block_size ( im ))[ * ]) B_block (:,:)[ im ] = B (:, start_elem ( im ): end_elem ( im )) C_block (:,:)[ im ] = matmul ( A , B_block (:,:)[ im ], transA = . false ., transB = . false ., option = option ) sync all if ( im == 1 ) then do i = 1 , nimg C (:, start_elem ( i ): end_elem ( i )) = C_block (:,:)[ i ] end do end if end if #else C = matmul ( A , B , transA = transA , transB = transB , option = option ) #endif end function mat_mat_coarray_rel","tags":"","loc":"proc/mat_mat_coarray_rel.html"},{"title":"mat_vec_coarray_rel – ForMatmul","text":"private impure function mat_vec_coarray_rel(A, v, transA, option, coarray) result(w) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) logical, intent(in), optional :: transA character(len=*), intent(in), optional :: option logical, intent(in) :: coarray Return Value real(kind=rk), allocatable, (:) Calls proc~~mat_vec_coarray_rel~~CallsGraph proc~mat_vec_coarray_rel formatmul::mat_vec_coarray_rel proc~compute_block_ranges formatmul::compute_block_ranges proc~mat_vec_coarray_rel->proc~compute_block_ranges Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~mat_vec_coarray_rel~~CalledByGraph proc~mat_vec_coarray_rel formatmul::mat_vec_coarray_rel interface~matmul formatmul::matmul interface~matmul->proc~mat_vec_coarray_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure function mat_vec_coarray_rel ( A , v , transA , option , coarray ) result ( w ) real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) character ( * ), intent ( in ), optional :: option logical , intent ( in ), optional :: transA real ( rk ), allocatable :: w (:) logical , intent ( in ) :: coarray #if defined (USE_COARRAY) integer :: i , im , nimg , n , m integer :: block_size ( num_images ()), start_elem ( num_images ()), end_elem ( num_images ()) real ( rk ), allocatable :: w_block (:)[:], v_block (:)[:], A_block (:,:)[:] if ( present ( transA )) then if ( transA ) then ! ATv allocate ( w ( size ( A , 2 )), source = 0.0_rk ) im = this_image () nimg = num_images () call compute_block_ranges ( size ( A , 2 ), nimg , block_size , start_elem , end_elem ) allocate ( w_block ( block_size ( im ))[ * ], A_block ( size ( A , 1 ), block_size ( im ))[ * ]) A_block (:,:)[ im ] = A (:, start_elem ( im ): end_elem ( im )) w_block (:)[ im ] = matmul ( A_block (:, :)[ im ], v , transA = . true ., option = option ) sync all if ( im == 1 ) then do i = 1 , nimg w ( start_elem ( i ): end_elem ( i )) = w_block (:)[ i ] end do end if else if (. not . transA ) then ! Av allocate ( w ( size ( A , 1 )), source = 0.0_rk ) im = this_image () nimg = num_images () call compute_block_ranges ( size ( A , 2 ), nimg , block_size , start_elem , end_elem ) allocate ( w_block ( size ( A , 1 ))[ * ], v_block ( block_size ( im ))[ * ], A_block ( size ( A , 1 ), block_size ( im ))[ * ]) A_block (:,:)[ im ] = A (:, start_elem ( im ): end_elem ( im )) v_block (:)[ im ] = v ( start_elem ( im ): end_elem ( im )) w_block (:)[ im ] = matmul ( A_block (:,:)[ im ], v_block (:)[ im ], transA = . false ., option = option ) sync all if ( im == 1 ) then do i = 1 , nimg w (:) = w (:) + w_block (:)[ i ] end do end if end if else if (. not . present ( transA )) then ! Av allocate ( w ( size ( A , 1 )), source = 0.0_rk ) im = this_image () nimg = num_images () call compute_block_ranges ( size ( A , 2 ), nimg , block_size , start_elem , end_elem ) allocate ( w_block ( size ( A , 1 ))[ * ], v_block ( block_size ( im ))[ * ], A_block ( size ( A , 1 ), block_size ( im ))[ * ]) A_block (:,:)[ im ] = A (:, start_elem ( im ): end_elem ( im )) v_block (:)[ im ] = v ( start_elem ( im ): end_elem ( im )) w_block (:)[ im ] = matmul ( A_block (:,:)[ im ], v_block (:)[ im ], transA = . false ., option = option ) sync all if ( im == 1 ) then do i = 1 , nimg w (:) = w (:) + w_block (:)[ i ] end do end if end if #else w = matmul ( A , v , transA = transA , option = option ) #endif end function mat_vec_coarray_rel","tags":"","loc":"proc/mat_vec_coarray_rel.html"},{"title":"mat_mat_block_rel – ForMatmul","text":"private pure function mat_mat_block_rel(a, b, transA, transB, option, nblock) result(c) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: a (:,:) real(kind=rk), intent(in), contiguous :: b (:,:) logical, intent(in), optional :: transA logical, intent(in), optional :: transB character(len=*), intent(in), optional :: option integer, intent(in) :: nblock Return Value real(kind=rk), allocatable, (:,:) Calls proc~~mat_mat_block_rel~~CallsGraph proc~mat_mat_block_rel formatmul::mat_mat_block_rel proc~compute_block_ranges formatmul::compute_block_ranges proc~mat_mat_block_rel->proc~compute_block_ranges Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~mat_mat_block_rel~~CalledByGraph proc~mat_mat_block_rel formatmul::mat_mat_block_rel interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_block_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function mat_mat_block_rel ( a , b , transA , transB , option , nblock ) result ( c ) real ( rk ), intent ( in ), contiguous :: a (:,:), b (:,:) logical , intent ( in ), optional :: transA , transB character ( * ), intent ( in ), optional :: option integer , intent ( in ) :: nblock real ( rk ), allocatable :: c (:,:) integer :: ib , se , ee integer :: block_size ( nblock ), start_elem ( nblock ), end_elem ( nblock ) if ( present ( transA ) . and . present ( transB )) then if (. not . transA . and . . not . transB ) then ! AB allocate ( C ( size ( A , 1 ), size ( B , 2 )), source = 0.0_rk ) call compute_block_ranges ( size ( B , 2 ), nblock , block_size , start_elem , end_elem ) #if defined(USE_DO_CONCURRENT) do concurrent ( ib = 1 : nblock ) se = start_elem ( ib ) ee = end_elem ( ib ) C (:, se : ee ) = & C (:, se : ee ) + matmul ( A , B (:, se : ee ), transA = . false ., transB = . false ., option = option ) end do #else do ib = 1 , nblock se = start_elem ( ib ) ee = end_elem ( ib ) C (:, se : ee ) = & C (:, se : ee ) + matmul ( A , B (:, se : ee ), transA = . false ., transB = . false ., option = option ) end do #endif else if ( transA . and . transB ) then ! ATBT allocate ( C ( size ( A , 2 ), size ( B , 1 )), source = 0.0_rk ) call compute_block_ranges ( size ( A , 2 ), nblock , block_size , start_elem , end_elem ) #if defined(USE_DO_CONCURRENT) do concurrent ( ib = 1 : nblock ) se = start_elem ( ib ) ee = end_elem ( ib ) C ( se : ee , :) = & C ( se : ee , :) + matmul ( A (:, se : ee ), B , transA = . true ., transB = . true ., option = option ) end do #else do ib = 1 , nblock se = start_elem ( ib ) ee = end_elem ( ib ) C ( se : ee , :) = & C ( se : ee , :) + matmul ( A (:, se : ee ), B , transA = . true ., transB = . true ., option = option ) end do #endif else if ( transA . and . . not . transB ) then ! ATB allocate ( C ( size ( A , 2 ), size ( B , 2 )), source = 0.0_rk ) call compute_block_ranges ( size ( A , 2 ), nblock , block_size , start_elem , end_elem ) #if defined(USE_DO_CONCURRENT) do concurrent ( ib = 1 : nblock ) se = start_elem ( ib ) ee = end_elem ( ib ) C ( se : ee , :) = & C ( se : ee , :) + matmul ( A (:, se : ee ), B , transA = . true ., transB = . false ., option = option ) end do #else do ib = 1 , nblock se = start_elem ( ib ) ee = end_elem ( ib ) C ( se : ee , :) = & C ( se : ee , :) + matmul ( A (:, se : ee ), B , transA = . true ., transB = . false ., option = option ) end do #endif else if (. not . transA . and . transB ) then ! ABT allocate ( C ( size ( A , 1 ), size ( B , 1 )), source = 0.0_rk ) call compute_block_ranges ( size ( A , 2 ), nblock , block_size , start_elem , end_elem ) #if defined(USE_DO_CONCURRENT) do concurrent ( ib = 1 : nblock ) se = start_elem ( ib ) ee = end_elem ( ib ) C (:, :) = C (:, :) + & matmul ( A (:, se : ee ), B (:, se : ee ), transA = . false ., transB = . true ., option = option ) end do #else do ib = 1 , nblock se = start_elem ( ib ) ee = end_elem ( ib ) C (:, :) = C (:, :) + & matmul ( A (:, se : ee ), B (:, se : ee ), transA = . false ., transB = . true ., option = option ) end do #endif end if else if ( present ( transA ) . or . present ( transB )) then if ( present ( transA )) then if ( transA ) then ! ATB allocate ( C ( size ( A , 2 ), size ( B , 2 )), source = 0.0_rk ) call compute_block_ranges ( size ( A , 2 ), nblock , block_size , start_elem , end_elem ) #if defined(USE_DO_CONCURRENT) do concurrent ( ib = 1 : nblock ) se = start_elem ( ib ) ee = end_elem ( ib ) C ( se : ee , :) = & C ( se : ee , :) + matmul ( A (:, se : ee ), B , transA = . true ., transB = . false ., option = option ) end do #else do ib = 1 , nblock se = start_elem ( ib ) ee = end_elem ( ib ) C ( se : ee , :) = & C ( se : ee , :) + matmul ( A (:, se : ee ), B , transA = . true ., transB = . false ., option = option ) end do #endif else if (. not . transA ) then ! ABT allocate ( C ( size ( A , 1 ), size ( B , 1 )), source = 0.0_rk ) call compute_block_ranges ( size ( A , 2 ), nblock , block_size , start_elem , end_elem ) #if defined(USE_DO_CONCURRENT) do concurrent ( ib = 1 : nblock ) se = start_elem ( ib ) ee = end_elem ( ib ) C (:, :) = C (:, :) + & matmul ( A (:, se : ee ), B (:, se : ee ), transA = . false ., transB = . true ., option = option ) end do #else do ib = 1 , nblock se = start_elem ( ib ) ee = end_elem ( ib ) C (:, :) = C (:, :) + & matmul ( A (:, se : ee ), B (:, se : ee ), transA = . false ., transB = . true ., option = option ) end do #endif end if else if ( present ( transB )) then if ( transB ) then ! ABT allocate ( C ( size ( A , 1 ), size ( B , 1 )), source = 0.0_rk ) call compute_block_ranges ( size ( A , 2 ), nblock , block_size , start_elem , end_elem ) #if defined(USE_DO_CONCURRENT) do concurrent ( ib = 1 : nblock ) se = start_elem ( ib ) ee = end_elem ( ib ) C (:, :) = C (:, :) + & matmul ( A (:, se : ee ), B (:, se : ee ), transA = . false ., transB = . true ., option = option ) end do #else do ib = 1 , nblock se = start_elem ( ib ) ee = end_elem ( ib ) C (:, :) = C (:, :) + & matmul ( A (:, se : ee ), B (:, se : ee ), transA = . false ., transB = . true ., option = option ) end do #endif else if (. not . transB ) then ! ATB allocate ( C ( size ( A , 2 ), size ( B , 2 )), source = 0.0_rk ) call compute_block_ranges ( size ( A , 2 ), nblock , block_size , start_elem , end_elem ) #if defined(USE_DO_CONCURRENT) do concurrent ( ib = 1 : nblock ) se = start_elem ( ib ) ee = end_elem ( ib ) C ( se : ee , :) = & C ( se : ee , :) + matmul ( A (:, se : ee ), B , transA = . true ., transB = . false ., option = option ) end do #else do ib = 1 , nblock se = start_elem ( ib ) ee = end_elem ( ib ) C ( se : ee , :) = & C ( se : ee , :) + matmul ( A (:, se : ee ), B , transA = . true ., transB = . false ., option = option ) end do #endif end if end if else if (. not . present ( transA ) . and . . not . present ( transB )) then ! AB allocate ( C ( size ( A , 1 ), size ( B , 2 )), source = 0.0_rk ) call compute_block_ranges ( size ( B , 2 ), nblock , block_size , start_elem , end_elem ) #if defined(USE_DO_CONCURRENT) do concurrent ( ib = 1 : nblock ) se = start_elem ( ib ) ee = end_elem ( ib ) C (:, se : ee ) = & C (:, se : ee ) + matmul ( A , B (:, se : ee ), transA = . false ., transB = . false ., option = option ) end do #else do ib = 1 , nblock se = start_elem ( ib ) ee = end_elem ( ib ) C (:, se : ee ) = & C (:, se : ee ) + matmul ( A , B (:, se : ee ), transA = . false ., transB = . false ., option = option ) end do #endif end if end function mat_mat_block_rel","tags":"","loc":"proc/mat_mat_block_rel.html"},{"title":"mat_vec_block_rel – ForMatmul","text":"private pure function mat_vec_block_rel(A, v, transA, option, nblock) result(w) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) logical, intent(in), optional :: transA character(len=*), intent(in), optional :: option integer, intent(in) :: nblock Return Value real(kind=rk), allocatable, (:) Calls proc~~mat_vec_block_rel~~CallsGraph proc~mat_vec_block_rel formatmul::mat_vec_block_rel proc~compute_block_ranges formatmul::compute_block_ranges proc~mat_vec_block_rel->proc~compute_block_ranges Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~mat_vec_block_rel~~CalledByGraph proc~mat_vec_block_rel formatmul::mat_vec_block_rel interface~matmul formatmul::matmul interface~matmul->proc~mat_vec_block_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function mat_vec_block_rel ( A , v , transA , option , nblock ) result ( w ) real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) logical , intent ( in ), optional :: transA character ( * ), intent ( in ), optional :: option integer , intent ( in ) :: nblock real ( rk ), allocatable :: w (:) integer :: ib , se , ee integer :: block_size ( nblock ), start_elem ( nblock ), end_elem ( nblock ) if ( present ( transA )) then if ( transA ) then ! ATv allocate ( w ( size ( A , 2 )), source = 0.0_rk ) call compute_block_ranges ( size ( A , 2 ), nblock , block_size , start_elem , end_elem ) #if defined(USE_DO_CONCURRENT) do concurrent ( ib = 1 : nblock ) se = start_elem ( ib ) ee = end_elem ( ib ) w ( se : ee ) = & w ( se : ee ) + matmul ( A (:, se : ee ), v , transA = . true ., option = option ) end do #else do ib = 1 , nblock se = start_elem ( ib ) ee = end_elem ( ib ) w ( se : ee ) = & w ( se : ee ) + matmul ( A (:, se : ee ), v , transA = . true ., option = option ) end do #endif else if (. not . transA ) then ! Av allocate ( w ( size ( A , 1 )), source = 0.0_rk ) call compute_block_ranges ( size ( A , 2 ), nblock , block_size , start_elem , end_elem ) #if defined(USE_DO_CONCURRENT) do concurrent ( ib = 1 : nblock ) se = start_elem ( ib ) ee = end_elem ( ib ) w (:) = & w (:) + matmul ( A (:, se : ee ), v ( se : ee ), transA = . false ., option = option ) end do #else do ib = 1 , nblock se = start_elem ( ib ) ee = end_elem ( ib ) w (:) = & w (:) + matmul ( A (:, se : ee ), v ( se : ee ), transA = . false ., option = option ) end do #endif end if else if (. not . present ( transA )) then ! Av allocate ( w ( size ( A , 1 )), source = 0.0_rk ) call compute_block_ranges ( size ( A , 2 ), nblock , block_size , start_elem , end_elem ) #if defined(USE_DO_CONCURRENT) do concurrent ( ib = 1 : nblock ) se = start_elem ( ib ) ee = end_elem ( ib ) w (:) = & w (:) + matmul ( A (:, se : ee ), v ( se : ee ), transA = . false ., option = option ) end do #else do ib = 1 , nblock se = start_elem ( ib ) ee = end_elem ( ib ) w (:) = & w (:) + matmul ( A (:, se : ee ), v ( se : ee ), transA = . false ., option = option ) end do #endif end if end function mat_vec_block_rel","tags":"","loc":"proc/mat_vec_block_rel.html"},{"title":"mat_mat_rel – ForMatmul","text":"private pure function mat_mat_rel(A, B, transA, transB, option) result(C) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) logical, intent(in), optional :: transA logical, intent(in), optional :: transB character(len=*), intent(in), optional :: option Return Value real(kind=rk), allocatable, (:,:) Calls proc~~mat_mat_rel~~CallsGraph proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel_ab formatmul::mat_mat_rel_AB proc~mat_mat_rel->proc~mat_mat_rel_ab proc~mat_mat_rel_abt formatmul::mat_mat_rel_ABT proc~mat_mat_rel->proc~mat_mat_rel_abt proc~mat_mat_rel_atb formatmul::mat_mat_rel_ATB proc~mat_mat_rel->proc~mat_mat_rel_atb proc~mat_mat_rel_atbt formatmul::mat_mat_rel_ATBT proc~mat_mat_rel->proc~mat_mat_rel_atbt proc~mat_mat_rel_ab_opt formatmul_opts::mat_mat_rel_AB_opt proc~mat_mat_rel_ab->proc~mat_mat_rel_ab_opt proc~mat_mat_rel_abt_opt formatmul_opts::mat_mat_rel_ABT_opt proc~mat_mat_rel_abt->proc~mat_mat_rel_abt_opt proc~mat_mat_rel_atb_opt formatmul_opts::mat_mat_rel_ATB_opt proc~mat_mat_rel_atb->proc~mat_mat_rel_atb_opt proc~mat_mat_rel_atbt_opt formatmul_opts::mat_mat_rel_ATBT_opt proc~mat_mat_rel_atbt->proc~mat_mat_rel_atbt_opt proc~mm_ab_1 formatmul_opts::mm_AB_1 proc~mat_mat_rel_ab_opt->proc~mm_ab_1 proc~mm_ab_10 formatmul_opts::mm_AB_10 proc~mat_mat_rel_ab_opt->proc~mm_ab_10 proc~mm_ab_11 formatmul_opts::mm_AB_11 proc~mat_mat_rel_ab_opt->proc~mm_ab_11 proc~mm_ab_12 formatmul_opts::mm_AB_12 proc~mat_mat_rel_ab_opt->proc~mm_ab_12 proc~mm_ab_13 formatmul_opts::mm_AB_13 proc~mat_mat_rel_ab_opt->proc~mm_ab_13 proc~mm_ab_2 formatmul_opts::mm_AB_2 proc~mat_mat_rel_ab_opt->proc~mm_ab_2 proc~mm_ab_3 formatmul_opts::mm_AB_3 proc~mat_mat_rel_ab_opt->proc~mm_ab_3 proc~mm_ab_4 formatmul_opts::mm_AB_4 proc~mat_mat_rel_ab_opt->proc~mm_ab_4 proc~mm_ab_5 formatmul_opts::mm_AB_5 proc~mat_mat_rel_ab_opt->proc~mm_ab_5 proc~mm_ab_6 formatmul_opts::mm_AB_6 proc~mat_mat_rel_ab_opt->proc~mm_ab_6 proc~mm_ab_7 formatmul_opts::mm_AB_7 proc~mat_mat_rel_ab_opt->proc~mm_ab_7 proc~mm_ab_8 formatmul_opts::mm_AB_8 proc~mat_mat_rel_ab_opt->proc~mm_ab_8 proc~mm_ab_9 formatmul_opts::mm_AB_9 proc~mat_mat_rel_ab_opt->proc~mm_ab_9 proc~mm_abt_1 formatmul_opts::mm_ABT_1 proc~mat_mat_rel_abt_opt->proc~mm_abt_1 proc~mm_abt_10 formatmul_opts::mm_ABT_10 proc~mat_mat_rel_abt_opt->proc~mm_abt_10 proc~mm_abt_11 formatmul_opts::mm_ABT_11 proc~mat_mat_rel_abt_opt->proc~mm_abt_11 proc~mm_abt_12 formatmul_opts::mm_ABT_12 proc~mat_mat_rel_abt_opt->proc~mm_abt_12 proc~mm_abt_13 formatmul_opts::mm_ABT_13 proc~mat_mat_rel_abt_opt->proc~mm_abt_13 proc~mm_abt_2 formatmul_opts::mm_ABT_2 proc~mat_mat_rel_abt_opt->proc~mm_abt_2 proc~mm_abt_3 formatmul_opts::mm_ABT_3 proc~mat_mat_rel_abt_opt->proc~mm_abt_3 proc~mm_abt_4 formatmul_opts::mm_ABT_4 proc~mat_mat_rel_abt_opt->proc~mm_abt_4 proc~mm_abt_5 formatmul_opts::mm_ABT_5 proc~mat_mat_rel_abt_opt->proc~mm_abt_5 proc~mm_abt_6 formatmul_opts::mm_ABT_6 proc~mat_mat_rel_abt_opt->proc~mm_abt_6 proc~mm_abt_7 formatmul_opts::mm_ABT_7 proc~mat_mat_rel_abt_opt->proc~mm_abt_7 proc~mm_abt_8 formatmul_opts::mm_ABT_8 proc~mat_mat_rel_abt_opt->proc~mm_abt_8 proc~mm_abt_9 formatmul_opts::mm_ABT_9 proc~mat_mat_rel_abt_opt->proc~mm_abt_9 proc~mm_atb_1 formatmul_opts::mm_ATB_1 proc~mat_mat_rel_atb_opt->proc~mm_atb_1 proc~mm_atb_10 formatmul_opts::mm_ATB_10 proc~mat_mat_rel_atb_opt->proc~mm_atb_10 proc~mm_atb_11 formatmul_opts::mm_ATB_11 proc~mat_mat_rel_atb_opt->proc~mm_atb_11 proc~mm_atb_12 formatmul_opts::mm_ATB_12 proc~mat_mat_rel_atb_opt->proc~mm_atb_12 proc~mm_atb_13 formatmul_opts::mm_ATB_13 proc~mat_mat_rel_atb_opt->proc~mm_atb_13 proc~mm_atb_2 formatmul_opts::mm_ATB_2 proc~mat_mat_rel_atb_opt->proc~mm_atb_2 proc~mm_atb_3 formatmul_opts::mm_ATB_3 proc~mat_mat_rel_atb_opt->proc~mm_atb_3 proc~mm_atb_4 formatmul_opts::mm_ATB_4 proc~mat_mat_rel_atb_opt->proc~mm_atb_4 proc~mm_atb_5 formatmul_opts::mm_ATB_5 proc~mat_mat_rel_atb_opt->proc~mm_atb_5 proc~mm_atb_6 formatmul_opts::mm_ATB_6 proc~mat_mat_rel_atb_opt->proc~mm_atb_6 proc~mm_atb_7 formatmul_opts::mm_ATB_7 proc~mat_mat_rel_atb_opt->proc~mm_atb_7 proc~mm_atb_8 formatmul_opts::mm_ATB_8 proc~mat_mat_rel_atb_opt->proc~mm_atb_8 proc~mm_atb_9 formatmul_opts::mm_ATB_9 proc~mat_mat_rel_atb_opt->proc~mm_atb_9 proc~mm_atbt_1 formatmul_opts::mm_ATBT_1 proc~mat_mat_rel_atbt_opt->proc~mm_atbt_1 proc~mm_atbt_10 formatmul_opts::mm_ATBT_10 proc~mat_mat_rel_atbt_opt->proc~mm_atbt_10 proc~mm_atbt_11 formatmul_opts::mm_ATBT_11 proc~mat_mat_rel_atbt_opt->proc~mm_atbt_11 proc~mm_atbt_12 formatmul_opts::mm_ATBT_12 proc~mat_mat_rel_atbt_opt->proc~mm_atbt_12 proc~mm_atbt_13 formatmul_opts::mm_ATBT_13 proc~mat_mat_rel_atbt_opt->proc~mm_atbt_13 proc~mm_atbt_2 formatmul_opts::mm_ATBT_2 proc~mat_mat_rel_atbt_opt->proc~mm_atbt_2 proc~mm_atbt_3 formatmul_opts::mm_ATBT_3 proc~mat_mat_rel_atbt_opt->proc~mm_atbt_3 proc~mm_atbt_4 formatmul_opts::mm_ATBT_4 proc~mat_mat_rel_atbt_opt->proc~mm_atbt_4 proc~mm_atbt_5 formatmul_opts::mm_ATBT_5 proc~mat_mat_rel_atbt_opt->proc~mm_atbt_5 proc~mm_atbt_6 formatmul_opts::mm_ATBT_6 proc~mat_mat_rel_atbt_opt->proc~mm_atbt_6 proc~mm_atbt_7 formatmul_opts::mm_ATBT_7 proc~mat_mat_rel_atbt_opt->proc~mm_atbt_7 proc~mm_atbt_8 formatmul_opts::mm_ATBT_8 proc~mat_mat_rel_atbt_opt->proc~mm_atbt_8 proc~mm_atbt_9 formatmul_opts::mm_ATBT_9 proc~mat_mat_rel_atbt_opt->proc~mm_atbt_9 interface~gemm external_interfaces_matmul::gemm proc~mm_ab_2->interface~gemm proc~mm_abt_2->interface~gemm proc~mm_atb_2->interface~gemm proc~mm_atbt_2->interface~gemm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~mat_mat_rel~~CalledByGraph proc~mat_mat_rel formatmul::mat_mat_rel interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function mat_mat_rel ( A , B , transA , transB , option ) result ( C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), allocatable :: C (:,:) character ( * ), intent ( in ), optional :: option logical , intent ( in ), optional :: transA , transB if ( present ( transA ) . and . present ( transB )) then if (. not . transA . and . . not . transB ) then ! AB allocate ( C ( size ( A , 1 ), size ( B , 2 )), source = 0.0_rk ) call mat_mat_rel_AB ( A , B , C , option ) else if ( transA . and . transB ) then ! ATBT allocate ( C ( size ( A , 2 ), size ( B , 1 )), source = 0.0_rk ) call mat_mat_rel_ATBT ( A , B , C , option ) else if ( transA . and . . not . transB ) then ! ATB allocate ( C ( size ( A , 2 ), size ( B , 2 )), source = 0.0_rk ) call mat_mat_rel_ATB ( A , B , C , option ) else if (. not . transA . and . transB ) then ! ABT allocate ( C ( size ( A , 1 ), size ( B , 1 )), source = 0.0_rk ) call mat_mat_rel_ABT ( A , B , C , option ) end if else if ( present ( transA ) . or . present ( transB )) then if ( present ( transA )) then if ( transA ) then ! ATB allocate ( C ( size ( A , 2 ), size ( B , 2 )), source = 0.0_rk ) call mat_mat_rel_ATB ( A , B , C , option ) else if (. not . transA ) then ! ABT allocate ( C ( size ( A , 1 ), size ( B , 1 )), source = 0.0_rk ) call mat_mat_rel_ABT ( A , B , C , option ) end if else if ( present ( transB )) then if ( transB ) then ! ABT allocate ( C ( size ( A , 1 ), size ( B , 1 )), source = 0.0_rk ) call mat_mat_rel_ABT ( A , B , C , option ) else if (. not . transB ) then ! ATB allocate ( C ( size ( A , 2 ), size ( B , 2 )), source = 0.0_rk ) call mat_mat_rel_ATB ( A , B , C , option ) end if end if else if (. not . present ( transA ) . and . . not . present ( transB )) then ! AB allocate ( C ( size ( A , 1 ), size ( B , 2 )), source = 0.0_rk ) call mat_mat_rel_AB ( A , B , C , option ) end if end function mat_mat_rel","tags":"","loc":"proc/mat_mat_rel.html"},{"title":"mat_vec_rel – ForMatmul","text":"private pure function mat_vec_rel(A, v, transA, option) result(w) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) logical, intent(in), optional :: transA character(len=*), intent(in), optional :: option Return Value real(kind=rk), allocatable, (:) Calls proc~~mat_vec_rel~~CallsGraph proc~mat_vec_rel formatmul::mat_vec_rel proc~mat_vec_rel_atv formatmul::mat_vec_rel_ATv proc~mat_vec_rel->proc~mat_vec_rel_atv proc~mat_vec_rel_av formatmul::mat_vec_rel_Av proc~mat_vec_rel->proc~mat_vec_rel_av proc~mat_vec_rel_atv_opt formatmul_opts::mat_vec_rel_ATv_opt proc~mat_vec_rel_atv->proc~mat_vec_rel_atv_opt proc~mat_vec_rel_av_opt formatmul_opts::mat_vec_rel_Av_opt proc~mat_vec_rel_av->proc~mat_vec_rel_av_opt proc~mv_atv_1 formatmul_opts::mv_ATv_1 proc~mat_vec_rel_atv_opt->proc~mv_atv_1 proc~mv_atv_2 formatmul_opts::mv_ATv_2 proc~mat_vec_rel_atv_opt->proc~mv_atv_2 proc~mv_atv_3 formatmul_opts::mv_ATv_3 proc~mat_vec_rel_atv_opt->proc~mv_atv_3 proc~mv_atv_4 formatmul_opts::mv_ATv_4 proc~mat_vec_rel_atv_opt->proc~mv_atv_4 proc~mv_atv_5 formatmul_opts::mv_ATv_5 proc~mat_vec_rel_atv_opt->proc~mv_atv_5 proc~mv_atv_6 formatmul_opts::mv_ATv_6 proc~mat_vec_rel_atv_opt->proc~mv_atv_6 proc~mv_atv_7 formatmul_opts::mv_ATv_7 proc~mat_vec_rel_atv_opt->proc~mv_atv_7 proc~mv_atv_8 formatmul_opts::mv_ATv_8 proc~mat_vec_rel_atv_opt->proc~mv_atv_8 proc~mv_av_1 formatmul_opts::mv_Av_1 proc~mat_vec_rel_av_opt->proc~mv_av_1 proc~mv_av_2 formatmul_opts::mv_Av_2 proc~mat_vec_rel_av_opt->proc~mv_av_2 proc~mv_av_3 formatmul_opts::mv_Av_3 proc~mat_vec_rel_av_opt->proc~mv_av_3 proc~mv_av_4 formatmul_opts::mv_Av_4 proc~mat_vec_rel_av_opt->proc~mv_av_4 proc~mv_av_5 formatmul_opts::mv_Av_5 proc~mat_vec_rel_av_opt->proc~mv_av_5 proc~mv_av_6 formatmul_opts::mv_Av_6 proc~mat_vec_rel_av_opt->proc~mv_av_6 proc~mv_av_7 formatmul_opts::mv_Av_7 proc~mat_vec_rel_av_opt->proc~mv_av_7 proc~mv_av_8 formatmul_opts::mv_Av_8 proc~mat_vec_rel_av_opt->proc~mv_av_8 interface~gemv external_interfaces_matmul::gemv proc~mv_atv_2->interface~gemv proc~mv_av_2->interface~gemv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~mat_vec_rel~~CalledByGraph proc~mat_vec_rel formatmul::mat_vec_rel interface~matmul formatmul::matmul interface~matmul->proc~mat_vec_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function mat_vec_rel ( A , v , transA , option ) result ( w ) real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) real ( rk ), allocatable :: w (:) character ( * ), intent ( in ), optional :: option logical , intent ( in ), optional :: transA if ( present ( transA )) then if ( transA ) then ! ATv allocate ( w ( size ( A , 2 )), source = 0.0_rk ) call mat_vec_rel_ATv ( A , v , w , option ) else if (. not . transA ) then ! Av allocate ( w ( size ( A , 1 )), source = 0.0_rk ) call mat_vec_rel_Av ( A , v , w , option ) end if else if (. not . present ( transA )) then ! Av allocate ( w ( size ( A , 1 )), source = 0.0_rk ) call mat_vec_rel_Av ( A , v , w , option ) end if end function mat_vec_rel","tags":"","loc":"proc/mat_vec_rel.html"},{"title":"compute_block_ranges – ForMatmul","text":"private pure subroutine compute_block_ranges(d, nimg, block_size, start_elem, end_elem) Calculate block sizes and ranges.\nauthor: Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name integer, intent(in) :: d integer, intent(in) :: nimg integer, intent(out) :: block_size (nimg) integer, intent(out) :: start_elem (nimg) integer, intent(out) :: end_elem (nimg) Called by proc~~compute_block_ranges~~CalledByGraph proc~compute_block_ranges formatmul::compute_block_ranges proc~mat_mat_block_rel formatmul::mat_mat_block_rel proc~mat_mat_block_rel->proc~compute_block_ranges proc~mat_mat_coarray_rel formatmul::mat_mat_coarray_rel proc~mat_mat_coarray_rel->proc~compute_block_ranges proc~mat_vec_block_rel formatmul::mat_vec_block_rel proc~mat_vec_block_rel->proc~compute_block_ranges proc~mat_vec_coarray_rel formatmul::mat_vec_coarray_rel proc~mat_vec_coarray_rel->proc~compute_block_ranges interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_block_rel interface~matmul->proc~mat_mat_coarray_rel interface~matmul->proc~mat_vec_block_rel interface~matmul->proc~mat_vec_coarray_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine compute_block_ranges ( d , nimg , block_size , start_elem , end_elem ) integer , intent ( in ) :: d , nimg integer , intent ( out ) :: block_size ( nimg ), start_elem ( nimg ), end_elem ( nimg ) integer :: i , remainder block_size = d / nimg remainder = mod ( d , nimg ) block_size ( 1 : remainder ) = block_size ( 1 : remainder ) + 1 start_elem ( 1 ) = 1 do i = 2 , nimg start_elem ( i ) = start_elem ( i - 1 ) + block_size ( i - 1 ) end do end_elem ( 1 ) = block_size ( 1 ) end_elem ( 2 :) = start_elem ( 2 :) + block_size ( 2 :) - 1 ! Check if the block sizes are valid. if ( minval ( block_size ) <= 0 ) error stop 'ForDot: reduce the number of images of coarray.' end subroutine compute_block_ranges","tags":"","loc":"proc/compute_block_ranges.html"},{"title":"mat_mat_rel_AB – ForMatmul","text":"private pure subroutine mat_mat_rel_AB(A, B, C, option) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) character(len=*), intent(in), optional :: option Calls proc~~mat_mat_rel_ab~~CallsGraph proc~mat_mat_rel_ab formatmul::mat_mat_rel_AB proc~mat_mat_rel_ab_opt formatmul_opts::mat_mat_rel_AB_opt proc~mat_mat_rel_ab->proc~mat_mat_rel_ab_opt proc~mm_ab_1 formatmul_opts::mm_AB_1 proc~mat_mat_rel_ab_opt->proc~mm_ab_1 proc~mm_ab_10 formatmul_opts::mm_AB_10 proc~mat_mat_rel_ab_opt->proc~mm_ab_10 proc~mm_ab_11 formatmul_opts::mm_AB_11 proc~mat_mat_rel_ab_opt->proc~mm_ab_11 proc~mm_ab_12 formatmul_opts::mm_AB_12 proc~mat_mat_rel_ab_opt->proc~mm_ab_12 proc~mm_ab_13 formatmul_opts::mm_AB_13 proc~mat_mat_rel_ab_opt->proc~mm_ab_13 proc~mm_ab_2 formatmul_opts::mm_AB_2 proc~mat_mat_rel_ab_opt->proc~mm_ab_2 proc~mm_ab_3 formatmul_opts::mm_AB_3 proc~mat_mat_rel_ab_opt->proc~mm_ab_3 proc~mm_ab_4 formatmul_opts::mm_AB_4 proc~mat_mat_rel_ab_opt->proc~mm_ab_4 proc~mm_ab_5 formatmul_opts::mm_AB_5 proc~mat_mat_rel_ab_opt->proc~mm_ab_5 proc~mm_ab_6 formatmul_opts::mm_AB_6 proc~mat_mat_rel_ab_opt->proc~mm_ab_6 proc~mm_ab_7 formatmul_opts::mm_AB_7 proc~mat_mat_rel_ab_opt->proc~mm_ab_7 proc~mm_ab_8 formatmul_opts::mm_AB_8 proc~mat_mat_rel_ab_opt->proc~mm_ab_8 proc~mm_ab_9 formatmul_opts::mm_AB_9 proc~mat_mat_rel_ab_opt->proc~mm_ab_9 interface~gemm external_interfaces_matmul::gemm proc~mm_ab_2->interface~gemm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~mat_mat_rel_ab~~CalledByGraph proc~mat_mat_rel_ab formatmul::mat_mat_rel_AB proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_ab interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mat_mat_rel_AB ( A , B , C , option ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) character ( * ), intent ( in ), optional :: option if ( present ( option )) then call mat_mat_rel_AB_opt ( A , B , C , option ) else call mat_mat_rel_AB_opt ( A , B , C , 'm2' ) end if end subroutine mat_mat_rel_AB","tags":"","loc":"proc/mat_mat_rel_ab.html"},{"title":"mat_mat_rel_ATB – ForMatmul","text":"private pure subroutine mat_mat_rel_ATB(A, B, C, option) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) character(len=*), intent(in), optional :: option Calls proc~~mat_mat_rel_atb~~CallsGraph proc~mat_mat_rel_atb formatmul::mat_mat_rel_ATB proc~mat_mat_rel_atb_opt formatmul_opts::mat_mat_rel_ATB_opt proc~mat_mat_rel_atb->proc~mat_mat_rel_atb_opt proc~mm_atb_1 formatmul_opts::mm_ATB_1 proc~mat_mat_rel_atb_opt->proc~mm_atb_1 proc~mm_atb_10 formatmul_opts::mm_ATB_10 proc~mat_mat_rel_atb_opt->proc~mm_atb_10 proc~mm_atb_11 formatmul_opts::mm_ATB_11 proc~mat_mat_rel_atb_opt->proc~mm_atb_11 proc~mm_atb_12 formatmul_opts::mm_ATB_12 proc~mat_mat_rel_atb_opt->proc~mm_atb_12 proc~mm_atb_13 formatmul_opts::mm_ATB_13 proc~mat_mat_rel_atb_opt->proc~mm_atb_13 proc~mm_atb_2 formatmul_opts::mm_ATB_2 proc~mat_mat_rel_atb_opt->proc~mm_atb_2 proc~mm_atb_3 formatmul_opts::mm_ATB_3 proc~mat_mat_rel_atb_opt->proc~mm_atb_3 proc~mm_atb_4 formatmul_opts::mm_ATB_4 proc~mat_mat_rel_atb_opt->proc~mm_atb_4 proc~mm_atb_5 formatmul_opts::mm_ATB_5 proc~mat_mat_rel_atb_opt->proc~mm_atb_5 proc~mm_atb_6 formatmul_opts::mm_ATB_6 proc~mat_mat_rel_atb_opt->proc~mm_atb_6 proc~mm_atb_7 formatmul_opts::mm_ATB_7 proc~mat_mat_rel_atb_opt->proc~mm_atb_7 proc~mm_atb_8 formatmul_opts::mm_ATB_8 proc~mat_mat_rel_atb_opt->proc~mm_atb_8 proc~mm_atb_9 formatmul_opts::mm_ATB_9 proc~mat_mat_rel_atb_opt->proc~mm_atb_9 interface~gemm external_interfaces_matmul::gemm proc~mm_atb_2->interface~gemm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~mat_mat_rel_atb~~CalledByGraph proc~mat_mat_rel_atb formatmul::mat_mat_rel_ATB proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_atb interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mat_mat_rel_ATB ( A , B , C , option ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) character ( * ), intent ( in ), optional :: option if ( present ( option )) then call mat_mat_rel_ATB_opt ( A , B , C , option ) else call mat_mat_rel_ATB_opt ( A , B , C , 'm2' ) end if end subroutine mat_mat_rel_ATB","tags":"","loc":"proc/mat_mat_rel_atb.html"},{"title":"mat_mat_rel_ABT – ForMatmul","text":"private pure subroutine mat_mat_rel_ABT(A, B, C, option) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) character(len=*), intent(in), optional :: option Calls proc~~mat_mat_rel_abt~~CallsGraph proc~mat_mat_rel_abt formatmul::mat_mat_rel_ABT proc~mat_mat_rel_abt_opt formatmul_opts::mat_mat_rel_ABT_opt proc~mat_mat_rel_abt->proc~mat_mat_rel_abt_opt proc~mm_abt_1 formatmul_opts::mm_ABT_1 proc~mat_mat_rel_abt_opt->proc~mm_abt_1 proc~mm_abt_10 formatmul_opts::mm_ABT_10 proc~mat_mat_rel_abt_opt->proc~mm_abt_10 proc~mm_abt_11 formatmul_opts::mm_ABT_11 proc~mat_mat_rel_abt_opt->proc~mm_abt_11 proc~mm_abt_12 formatmul_opts::mm_ABT_12 proc~mat_mat_rel_abt_opt->proc~mm_abt_12 proc~mm_abt_13 formatmul_opts::mm_ABT_13 proc~mat_mat_rel_abt_opt->proc~mm_abt_13 proc~mm_abt_2 formatmul_opts::mm_ABT_2 proc~mat_mat_rel_abt_opt->proc~mm_abt_2 proc~mm_abt_3 formatmul_opts::mm_ABT_3 proc~mat_mat_rel_abt_opt->proc~mm_abt_3 proc~mm_abt_4 formatmul_opts::mm_ABT_4 proc~mat_mat_rel_abt_opt->proc~mm_abt_4 proc~mm_abt_5 formatmul_opts::mm_ABT_5 proc~mat_mat_rel_abt_opt->proc~mm_abt_5 proc~mm_abt_6 formatmul_opts::mm_ABT_6 proc~mat_mat_rel_abt_opt->proc~mm_abt_6 proc~mm_abt_7 formatmul_opts::mm_ABT_7 proc~mat_mat_rel_abt_opt->proc~mm_abt_7 proc~mm_abt_8 formatmul_opts::mm_ABT_8 proc~mat_mat_rel_abt_opt->proc~mm_abt_8 proc~mm_abt_9 formatmul_opts::mm_ABT_9 proc~mat_mat_rel_abt_opt->proc~mm_abt_9 interface~gemm external_interfaces_matmul::gemm proc~mm_abt_2->interface~gemm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~mat_mat_rel_abt~~CalledByGraph proc~mat_mat_rel_abt formatmul::mat_mat_rel_ABT proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_abt interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mat_mat_rel_ABT ( A , B , C , option ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) character ( * ), intent ( in ), optional :: option if ( present ( option )) then call mat_mat_rel_ABT_opt ( A , B , C , option ) else call mat_mat_rel_ABT_opt ( A , B , C , 'm2' ) end if end subroutine mat_mat_rel_ABT","tags":"","loc":"proc/mat_mat_rel_abt.html"},{"title":"mat_mat_rel_ATBT – ForMatmul","text":"private pure subroutine mat_mat_rel_ATBT(A, B, C, option) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) character(len=*), intent(in), optional :: option Calls proc~~mat_mat_rel_atbt~~CallsGraph proc~mat_mat_rel_atbt formatmul::mat_mat_rel_ATBT proc~mat_mat_rel_atbt_opt formatmul_opts::mat_mat_rel_ATBT_opt proc~mat_mat_rel_atbt->proc~mat_mat_rel_atbt_opt proc~mm_atbt_1 formatmul_opts::mm_ATBT_1 proc~mat_mat_rel_atbt_opt->proc~mm_atbt_1 proc~mm_atbt_10 formatmul_opts::mm_ATBT_10 proc~mat_mat_rel_atbt_opt->proc~mm_atbt_10 proc~mm_atbt_11 formatmul_opts::mm_ATBT_11 proc~mat_mat_rel_atbt_opt->proc~mm_atbt_11 proc~mm_atbt_12 formatmul_opts::mm_ATBT_12 proc~mat_mat_rel_atbt_opt->proc~mm_atbt_12 proc~mm_atbt_13 formatmul_opts::mm_ATBT_13 proc~mat_mat_rel_atbt_opt->proc~mm_atbt_13 proc~mm_atbt_2 formatmul_opts::mm_ATBT_2 proc~mat_mat_rel_atbt_opt->proc~mm_atbt_2 proc~mm_atbt_3 formatmul_opts::mm_ATBT_3 proc~mat_mat_rel_atbt_opt->proc~mm_atbt_3 proc~mm_atbt_4 formatmul_opts::mm_ATBT_4 proc~mat_mat_rel_atbt_opt->proc~mm_atbt_4 proc~mm_atbt_5 formatmul_opts::mm_ATBT_5 proc~mat_mat_rel_atbt_opt->proc~mm_atbt_5 proc~mm_atbt_6 formatmul_opts::mm_ATBT_6 proc~mat_mat_rel_atbt_opt->proc~mm_atbt_6 proc~mm_atbt_7 formatmul_opts::mm_ATBT_7 proc~mat_mat_rel_atbt_opt->proc~mm_atbt_7 proc~mm_atbt_8 formatmul_opts::mm_ATBT_8 proc~mat_mat_rel_atbt_opt->proc~mm_atbt_8 proc~mm_atbt_9 formatmul_opts::mm_ATBT_9 proc~mat_mat_rel_atbt_opt->proc~mm_atbt_9 interface~gemm external_interfaces_matmul::gemm proc~mm_atbt_2->interface~gemm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~mat_mat_rel_atbt~~CalledByGraph proc~mat_mat_rel_atbt formatmul::mat_mat_rel_ATBT proc~mat_mat_rel formatmul::mat_mat_rel proc~mat_mat_rel->proc~mat_mat_rel_atbt interface~matmul formatmul::matmul interface~matmul->proc~mat_mat_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mat_mat_rel_ATBT ( A , B , C , option ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) character ( * ), intent ( in ), optional :: option if ( present ( option )) then call mat_mat_rel_ATBT_opt ( A , B , C , option ) else call mat_mat_rel_ATBT_opt ( A , B , C , 'm2' ) end if end subroutine mat_mat_rel_ATBT","tags":"","loc":"proc/mat_mat_rel_atbt.html"},{"title":"mat_vec_rel_Av – ForMatmul","text":"private pure subroutine mat_vec_rel_Av(A, v, w, option) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) real(kind=rk), intent(inout), contiguous :: w (:) character(len=*), intent(in), optional :: option Calls proc~~mat_vec_rel_av~~CallsGraph proc~mat_vec_rel_av formatmul::mat_vec_rel_Av proc~mat_vec_rel_av_opt formatmul_opts::mat_vec_rel_Av_opt proc~mat_vec_rel_av->proc~mat_vec_rel_av_opt proc~mv_av_1 formatmul_opts::mv_Av_1 proc~mat_vec_rel_av_opt->proc~mv_av_1 proc~mv_av_2 formatmul_opts::mv_Av_2 proc~mat_vec_rel_av_opt->proc~mv_av_2 proc~mv_av_3 formatmul_opts::mv_Av_3 proc~mat_vec_rel_av_opt->proc~mv_av_3 proc~mv_av_4 formatmul_opts::mv_Av_4 proc~mat_vec_rel_av_opt->proc~mv_av_4 proc~mv_av_5 formatmul_opts::mv_Av_5 proc~mat_vec_rel_av_opt->proc~mv_av_5 proc~mv_av_6 formatmul_opts::mv_Av_6 proc~mat_vec_rel_av_opt->proc~mv_av_6 proc~mv_av_7 formatmul_opts::mv_Av_7 proc~mat_vec_rel_av_opt->proc~mv_av_7 proc~mv_av_8 formatmul_opts::mv_Av_8 proc~mat_vec_rel_av_opt->proc~mv_av_8 interface~gemv external_interfaces_matmul::gemv proc~mv_av_2->interface~gemv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~mat_vec_rel_av~~CalledByGraph proc~mat_vec_rel_av formatmul::mat_vec_rel_Av proc~mat_vec_rel formatmul::mat_vec_rel proc~mat_vec_rel->proc~mat_vec_rel_av interface~matmul formatmul::matmul interface~matmul->proc~mat_vec_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mat_vec_rel_Av ( A , v , w , option ) real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) real ( rk ), intent ( inout ), contiguous :: w (:) character ( * ), intent ( in ), optional :: option if ( present ( option )) then call mat_vec_rel_Av_opt ( A , v , w , option ) else call mat_vec_rel_Av_opt ( A , v , w , 'm2' ) end if end subroutine mat_vec_rel_Av","tags":"","loc":"proc/mat_vec_rel_av.html"},{"title":"mat_vec_rel_ATv – ForMatmul","text":"private pure subroutine mat_vec_rel_ATv(A, v, w, option) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) real(kind=rk), intent(inout), contiguous :: w (:) character(len=*), intent(in), optional :: option Calls proc~~mat_vec_rel_atv~~CallsGraph proc~mat_vec_rel_atv formatmul::mat_vec_rel_ATv proc~mat_vec_rel_atv_opt formatmul_opts::mat_vec_rel_ATv_opt proc~mat_vec_rel_atv->proc~mat_vec_rel_atv_opt proc~mv_atv_1 formatmul_opts::mv_ATv_1 proc~mat_vec_rel_atv_opt->proc~mv_atv_1 proc~mv_atv_2 formatmul_opts::mv_ATv_2 proc~mat_vec_rel_atv_opt->proc~mv_atv_2 proc~mv_atv_3 formatmul_opts::mv_ATv_3 proc~mat_vec_rel_atv_opt->proc~mv_atv_3 proc~mv_atv_4 formatmul_opts::mv_ATv_4 proc~mat_vec_rel_atv_opt->proc~mv_atv_4 proc~mv_atv_5 formatmul_opts::mv_ATv_5 proc~mat_vec_rel_atv_opt->proc~mv_atv_5 proc~mv_atv_6 formatmul_opts::mv_ATv_6 proc~mat_vec_rel_atv_opt->proc~mv_atv_6 proc~mv_atv_7 formatmul_opts::mv_ATv_7 proc~mat_vec_rel_atv_opt->proc~mv_atv_7 proc~mv_atv_8 formatmul_opts::mv_ATv_8 proc~mat_vec_rel_atv_opt->proc~mv_atv_8 interface~gemv external_interfaces_matmul::gemv proc~mv_atv_2->interface~gemv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~mat_vec_rel_atv~~CalledByGraph proc~mat_vec_rel_atv formatmul::mat_vec_rel_ATv proc~mat_vec_rel formatmul::mat_vec_rel proc~mat_vec_rel->proc~mat_vec_rel_atv interface~matmul formatmul::matmul interface~matmul->proc~mat_vec_rel Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine mat_vec_rel_ATv ( A , v , w , option ) real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) real ( rk ), intent ( inout ), contiguous :: w (:) character ( * ), intent ( in ), optional :: option if ( present ( option )) then call mat_vec_rel_ATv_opt ( A , v , w , option ) else call mat_vec_rel_ATv_opt ( A , v , w , 'm2' ) end if end subroutine mat_vec_rel_ATv","tags":"","loc":"proc/mat_vec_rel_atv.html"},{"title":"matmul – ForMatmul","text":"public interface matmul Calls interface~~matmul~~CallsGraph interface~matmul formatmul::matmul proc~mat_mat_block_rel formatmul::mat_mat_block_rel interface~matmul->proc~mat_mat_block_rel proc~mat_mat_coarray_rel formatmul::mat_mat_coarray_rel interface~matmul->proc~mat_mat_coarray_rel proc~mat_mat_rel formatmul::mat_mat_rel interface~matmul->proc~mat_mat_rel proc~mat_vec_block_rel formatmul::mat_vec_block_rel interface~matmul->proc~mat_vec_block_rel proc~mat_vec_coarray_rel formatmul::mat_vec_coarray_rel interface~matmul->proc~mat_vec_coarray_rel proc~mat_vec_rel formatmul::mat_vec_rel interface~matmul->proc~mat_vec_rel proc~compute_block_ranges formatmul::compute_block_ranges proc~mat_mat_block_rel->proc~compute_block_ranges proc~mat_mat_coarray_rel->proc~compute_block_ranges proc~mat_mat_rel_ab formatmul::mat_mat_rel_AB proc~mat_mat_rel->proc~mat_mat_rel_ab proc~mat_mat_rel_abt formatmul::mat_mat_rel_ABT proc~mat_mat_rel->proc~mat_mat_rel_abt proc~mat_mat_rel_atb formatmul::mat_mat_rel_ATB proc~mat_mat_rel->proc~mat_mat_rel_atb proc~mat_mat_rel_atbt formatmul::mat_mat_rel_ATBT proc~mat_mat_rel->proc~mat_mat_rel_atbt proc~mat_vec_block_rel->proc~compute_block_ranges proc~mat_vec_coarray_rel->proc~compute_block_ranges proc~mat_vec_rel_atv formatmul::mat_vec_rel_ATv proc~mat_vec_rel->proc~mat_vec_rel_atv proc~mat_vec_rel_av formatmul::mat_vec_rel_Av proc~mat_vec_rel->proc~mat_vec_rel_av proc~mat_mat_rel_ab_opt formatmul_opts::mat_mat_rel_AB_opt proc~mat_mat_rel_ab->proc~mat_mat_rel_ab_opt proc~mat_mat_rel_abt_opt formatmul_opts::mat_mat_rel_ABT_opt proc~mat_mat_rel_abt->proc~mat_mat_rel_abt_opt proc~mat_mat_rel_atb_opt formatmul_opts::mat_mat_rel_ATB_opt proc~mat_mat_rel_atb->proc~mat_mat_rel_atb_opt proc~mat_mat_rel_atbt_opt formatmul_opts::mat_mat_rel_ATBT_opt proc~mat_mat_rel_atbt->proc~mat_mat_rel_atbt_opt proc~mat_vec_rel_atv_opt formatmul_opts::mat_vec_rel_ATv_opt proc~mat_vec_rel_atv->proc~mat_vec_rel_atv_opt proc~mat_vec_rel_av_opt formatmul_opts::mat_vec_rel_Av_opt proc~mat_vec_rel_av->proc~mat_vec_rel_av_opt proc~mm_ab_1 formatmul_opts::mm_AB_1 proc~mat_mat_rel_ab_opt->proc~mm_ab_1 proc~mm_ab_10 formatmul_opts::mm_AB_10 proc~mat_mat_rel_ab_opt->proc~mm_ab_10 proc~mm_ab_11 formatmul_opts::mm_AB_11 proc~mat_mat_rel_ab_opt->proc~mm_ab_11 proc~mm_ab_12 formatmul_opts::mm_AB_12 proc~mat_mat_rel_ab_opt->proc~mm_ab_12 proc~mm_ab_13 formatmul_opts::mm_AB_13 proc~mat_mat_rel_ab_opt->proc~mm_ab_13 proc~mm_ab_2 formatmul_opts::mm_AB_2 proc~mat_mat_rel_ab_opt->proc~mm_ab_2 proc~mm_ab_3 formatmul_opts::mm_AB_3 proc~mat_mat_rel_ab_opt->proc~mm_ab_3 proc~mm_ab_4 formatmul_opts::mm_AB_4 proc~mat_mat_rel_ab_opt->proc~mm_ab_4 proc~mm_ab_5 formatmul_opts::mm_AB_5 proc~mat_mat_rel_ab_opt->proc~mm_ab_5 proc~mm_ab_6 formatmul_opts::mm_AB_6 proc~mat_mat_rel_ab_opt->proc~mm_ab_6 proc~mm_ab_7 formatmul_opts::mm_AB_7 proc~mat_mat_rel_ab_opt->proc~mm_ab_7 proc~mm_ab_8 formatmul_opts::mm_AB_8 proc~mat_mat_rel_ab_opt->proc~mm_ab_8 proc~mm_ab_9 formatmul_opts::mm_AB_9 proc~mat_mat_rel_ab_opt->proc~mm_ab_9 proc~mm_abt_1 formatmul_opts::mm_ABT_1 proc~mat_mat_rel_abt_opt->proc~mm_abt_1 proc~mm_abt_10 formatmul_opts::mm_ABT_10 proc~mat_mat_rel_abt_opt->proc~mm_abt_10 proc~mm_abt_11 formatmul_opts::mm_ABT_11 proc~mat_mat_rel_abt_opt->proc~mm_abt_11 proc~mm_abt_12 formatmul_opts::mm_ABT_12 proc~mat_mat_rel_abt_opt->proc~mm_abt_12 proc~mm_abt_13 formatmul_opts::mm_ABT_13 proc~mat_mat_rel_abt_opt->proc~mm_abt_13 proc~mm_abt_2 formatmul_opts::mm_ABT_2 proc~mat_mat_rel_abt_opt->proc~mm_abt_2 proc~mm_abt_3 formatmul_opts::mm_ABT_3 proc~mat_mat_rel_abt_opt->proc~mm_abt_3 proc~mm_abt_4 formatmul_opts::mm_ABT_4 proc~mat_mat_rel_abt_opt->proc~mm_abt_4 proc~mm_abt_5 formatmul_opts::mm_ABT_5 proc~mat_mat_rel_abt_opt->proc~mm_abt_5 proc~mm_abt_6 formatmul_opts::mm_ABT_6 proc~mat_mat_rel_abt_opt->proc~mm_abt_6 proc~mm_abt_7 formatmul_opts::mm_ABT_7 proc~mat_mat_rel_abt_opt->proc~mm_abt_7 proc~mm_abt_8 formatmul_opts::mm_ABT_8 proc~mat_mat_rel_abt_opt->proc~mm_abt_8 proc~mm_abt_9 formatmul_opts::mm_ABT_9 proc~mat_mat_rel_abt_opt->proc~mm_abt_9 proc~mm_atb_1 formatmul_opts::mm_ATB_1 proc~mat_mat_rel_atb_opt->proc~mm_atb_1 proc~mm_atb_10 formatmul_opts::mm_ATB_10 proc~mat_mat_rel_atb_opt->proc~mm_atb_10 proc~mm_atb_11 formatmul_opts::mm_ATB_11 proc~mat_mat_rel_atb_opt->proc~mm_atb_11 proc~mm_atb_12 formatmul_opts::mm_ATB_12 proc~mat_mat_rel_atb_opt->proc~mm_atb_12 proc~mm_atb_13 formatmul_opts::mm_ATB_13 proc~mat_mat_rel_atb_opt->proc~mm_atb_13 proc~mm_atb_2 formatmul_opts::mm_ATB_2 proc~mat_mat_rel_atb_opt->proc~mm_atb_2 proc~mm_atb_3 formatmul_opts::mm_ATB_3 proc~mat_mat_rel_atb_opt->proc~mm_atb_3 proc~mm_atb_4 formatmul_opts::mm_ATB_4 proc~mat_mat_rel_atb_opt->proc~mm_atb_4 proc~mm_atb_5 formatmul_opts::mm_ATB_5 proc~mat_mat_rel_atb_opt->proc~mm_atb_5 proc~mm_atb_6 formatmul_opts::mm_ATB_6 proc~mat_mat_rel_atb_opt->proc~mm_atb_6 proc~mm_atb_7 formatmul_opts::mm_ATB_7 proc~mat_mat_rel_atb_opt->proc~mm_atb_7 proc~mm_atb_8 formatmul_opts::mm_ATB_8 proc~mat_mat_rel_atb_opt->proc~mm_atb_8 proc~mm_atb_9 formatmul_opts::mm_ATB_9 proc~mat_mat_rel_atb_opt->proc~mm_atb_9 proc~mm_atbt_1 formatmul_opts::mm_ATBT_1 proc~mat_mat_rel_atbt_opt->proc~mm_atbt_1 proc~mm_atbt_10 formatmul_opts::mm_ATBT_10 proc~mat_mat_rel_atbt_opt->proc~mm_atbt_10 proc~mm_atbt_11 formatmul_opts::mm_ATBT_11 proc~mat_mat_rel_atbt_opt->proc~mm_atbt_11 proc~mm_atbt_12 formatmul_opts::mm_ATBT_12 proc~mat_mat_rel_atbt_opt->proc~mm_atbt_12 proc~mm_atbt_13 formatmul_opts::mm_ATBT_13 proc~mat_mat_rel_atbt_opt->proc~mm_atbt_13 proc~mm_atbt_2 formatmul_opts::mm_ATBT_2 proc~mat_mat_rel_atbt_opt->proc~mm_atbt_2 proc~mm_atbt_3 formatmul_opts::mm_ATBT_3 proc~mat_mat_rel_atbt_opt->proc~mm_atbt_3 proc~mm_atbt_4 formatmul_opts::mm_ATBT_4 proc~mat_mat_rel_atbt_opt->proc~mm_atbt_4 proc~mm_atbt_5 formatmul_opts::mm_ATBT_5 proc~mat_mat_rel_atbt_opt->proc~mm_atbt_5 proc~mm_atbt_6 formatmul_opts::mm_ATBT_6 proc~mat_mat_rel_atbt_opt->proc~mm_atbt_6 proc~mm_atbt_7 formatmul_opts::mm_ATBT_7 proc~mat_mat_rel_atbt_opt->proc~mm_atbt_7 proc~mm_atbt_8 formatmul_opts::mm_ATBT_8 proc~mat_mat_rel_atbt_opt->proc~mm_atbt_8 proc~mm_atbt_9 formatmul_opts::mm_ATBT_9 proc~mat_mat_rel_atbt_opt->proc~mm_atbt_9 proc~mv_atv_1 formatmul_opts::mv_ATv_1 proc~mat_vec_rel_atv_opt->proc~mv_atv_1 proc~mv_atv_2 formatmul_opts::mv_ATv_2 proc~mat_vec_rel_atv_opt->proc~mv_atv_2 proc~mv_atv_3 formatmul_opts::mv_ATv_3 proc~mat_vec_rel_atv_opt->proc~mv_atv_3 proc~mv_atv_4 formatmul_opts::mv_ATv_4 proc~mat_vec_rel_atv_opt->proc~mv_atv_4 proc~mv_atv_5 formatmul_opts::mv_ATv_5 proc~mat_vec_rel_atv_opt->proc~mv_atv_5 proc~mv_atv_6 formatmul_opts::mv_ATv_6 proc~mat_vec_rel_atv_opt->proc~mv_atv_6 proc~mv_atv_7 formatmul_opts::mv_ATv_7 proc~mat_vec_rel_atv_opt->proc~mv_atv_7 proc~mv_atv_8 formatmul_opts::mv_ATv_8 proc~mat_vec_rel_atv_opt->proc~mv_atv_8 proc~mv_av_1 formatmul_opts::mv_Av_1 proc~mat_vec_rel_av_opt->proc~mv_av_1 proc~mv_av_2 formatmul_opts::mv_Av_2 proc~mat_vec_rel_av_opt->proc~mv_av_2 proc~mv_av_3 formatmul_opts::mv_Av_3 proc~mat_vec_rel_av_opt->proc~mv_av_3 proc~mv_av_4 formatmul_opts::mv_Av_4 proc~mat_vec_rel_av_opt->proc~mv_av_4 proc~mv_av_5 formatmul_opts::mv_Av_5 proc~mat_vec_rel_av_opt->proc~mv_av_5 proc~mv_av_6 formatmul_opts::mv_Av_6 proc~mat_vec_rel_av_opt->proc~mv_av_6 proc~mv_av_7 formatmul_opts::mv_Av_7 proc~mat_vec_rel_av_opt->proc~mv_av_7 proc~mv_av_8 formatmul_opts::mv_Av_8 proc~mat_vec_rel_av_opt->proc~mv_av_8 interface~gemm external_interfaces_matmul::gemm proc~mm_ab_2->interface~gemm proc~mm_abt_2->interface~gemm proc~mm_atb_2->interface~gemm proc~mm_atbt_2->interface~gemm interface~gemv external_interfaces_matmul::gemv proc~mv_atv_2->interface~gemv proc~mv_av_2->interface~gemv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function mat_mat_rel (A, B, transA, transB, option) result(C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) logical, intent(in), optional :: transA logical, intent(in), optional :: transB character(len=*), intent(in), optional :: option Return Value real(kind=rk), allocatable, (:,:) private pure function mat_mat_block_rel (a, b, transA, transB, option, nblock) result(c) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: a (:,:) real(kind=rk), intent(in), contiguous :: b (:,:) logical, intent(in), optional :: transA logical, intent(in), optional :: transB character(len=*), intent(in), optional :: option integer, intent(in) :: nblock Return Value real(kind=rk), allocatable, (:,:) private impure function mat_mat_coarray_rel (a, b, transA, transB, option, coarray) result(c) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: a (:,:) real(kind=rk), intent(in), contiguous :: b (:,:) logical, intent(in), optional :: transA logical, intent(in), optional :: transB character(len=*), intent(in), optional :: option logical, intent(in) :: coarray Return Value real(kind=rk), allocatable, (:,:) private pure function mat_vec_rel (A, v, transA, option) result(w) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) logical, intent(in), optional :: transA character(len=*), intent(in), optional :: option Return Value real(kind=rk), allocatable, (:) private pure function mat_vec_block_rel (A, v, transA, option, nblock) result(w) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) logical, intent(in), optional :: transA character(len=*), intent(in), optional :: option integer, intent(in) :: nblock Return Value real(kind=rk), allocatable, (:) private impure function mat_vec_coarray_rel (A, v, transA, option, coarray) result(w) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) logical, intent(in), optional :: transA character(len=*), intent(in), optional :: option logical, intent(in) :: coarray Return Value real(kind=rk), allocatable, (:)","tags":"","loc":"interface/matmul.html"},{"title":"external_interfaces_matmul – ForMatmul","text":"Uses kinds module~~external_interfaces_matmul~~UsesGraph module~external_interfaces_matmul external_interfaces_matmul kinds kinds module~external_interfaces_matmul->kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~external_interfaces_matmul~~UsedByGraph module~external_interfaces_matmul external_interfaces_matmul proc~mm_ab_2 formatmul_opts::mm_AB_2 proc~mm_ab_2->module~external_interfaces_matmul proc~mm_abt_2 formatmul_opts::mm_ABT_2 proc~mm_abt_2->module~external_interfaces_matmul proc~mm_atb_2 formatmul_opts::mm_ATB_2 proc~mm_atb_2->module~external_interfaces_matmul proc~mm_atbt_2 formatmul_opts::mm_ATBT_2 proc~mm_atbt_2->module~external_interfaces_matmul proc~mv_atv_2 formatmul_opts::mv_ATv_2 proc~mv_atv_2->module~external_interfaces_matmul proc~mv_av_2 formatmul_opts::mv_Av_2 proc~mv_av_2->module~external_interfaces_matmul Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface gemm public pure subroutine dgemm(f_transa, f_transb, f_m, f_n, f_k, f_alpha, f_a, f_lda, f_b, f_ldb, f_beta, f_c, f_ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: f_transa character(len=1), intent(in) :: f_transb integer, intent(in) :: f_m integer, intent(in) :: f_n integer, intent(in) :: f_k real(kind=rk), intent(in) :: f_alpha real(kind=rk), intent(in) :: f_a (f_lda,*) integer, intent(in) :: f_lda real(kind=rk), intent(in) :: f_b (f_ldb,*) integer, intent(in) :: f_ldb real(kind=rk), intent(in) :: f_beta real(kind=rk), intent(inout) :: f_c (f_ldc,*) integer, intent(in) :: f_ldc public pure subroutine sgemm(f_transa, f_transb, f_m, f_n, f_k, f_alpha, f_a, f_lda, f_b, f_ldb, f_beta, f_c, f_ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: f_transa character(len=1), intent(in) :: f_transb integer, intent(in) :: f_m integer, intent(in) :: f_n integer, intent(in) :: f_k real(kind=rk), intent(in) :: f_alpha real(kind=rk), intent(in) :: f_a (f_lda,*) integer, intent(in) :: f_lda real(kind=rk), intent(in) :: f_b (f_ldb,*) integer, intent(in) :: f_ldb real(kind=rk), intent(in) :: f_beta real(kind=rk), intent(inout) :: f_c (f_ldc,*) integer, intent(in) :: f_ldc public pure subroutine dgemm(f_transa, f_transb, f_m, f_n, f_k, f_alpha, f_a, f_lda, f_b, f_ldb, f_beta, f_c, f_ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: f_transa character(len=1), intent(in) :: f_transb integer, intent(in) :: f_m integer, intent(in) :: f_n integer, intent(in) :: f_k real(kind=rk), intent(in) :: f_alpha real(kind=rk), intent(in) :: f_a (f_lda,*) integer, intent(in) :: f_lda real(kind=rk), intent(in) :: f_b (f_ldb,*) integer, intent(in) :: f_ldb real(kind=rk), intent(in) :: f_beta real(kind=rk), intent(inout) :: f_c (f_ldc,*) integer, intent(in) :: f_ldc public        interface gemv public pure subroutine dgemv(f_trans, f_m, f_n, f_alpha, f_a, f_lda, f_x, f_incx, f_beta, f_y, f_incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: f_trans integer, intent(in) :: f_m integer, intent(in) :: f_n real(kind=rk), intent(in) :: f_alpha real(kind=rk), intent(in) :: f_a (f_lda,*) integer, intent(in) :: f_lda real(kind=rk), intent(in) :: f_x (*) integer, intent(in) :: f_incx real(kind=rk), intent(in) :: f_beta real(kind=rk), intent(inout) :: f_y (*) integer, intent(in) :: f_incy public pure subroutine sgemv(f_trans, f_m, f_n, f_alpha, f_a, f_lda, f_x, f_incx, f_beta, f_y, f_incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: f_trans integer, intent(in) :: f_m integer, intent(in) :: f_n real(kind=rk), intent(in) :: f_alpha real(kind=rk), intent(in) :: f_a (f_lda,*) integer, intent(in) :: f_lda real(kind=rk), intent(in) :: f_x (*) integer, intent(in) :: f_incx real(kind=rk), intent(in) :: f_beta real(kind=rk), intent(inout) :: f_y (*) integer, intent(in) :: f_incy public pure subroutine dgemv(f_trans, f_m, f_n, f_alpha, f_a, f_lda, f_x, f_incx, f_beta, f_y, f_incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: f_trans integer, intent(in) :: f_m integer, intent(in) :: f_n real(kind=rk), intent(in) :: f_alpha real(kind=rk), intent(in) :: f_a (f_lda,*) integer, intent(in) :: f_lda real(kind=rk), intent(in) :: f_x (*) integer, intent(in) :: f_incx real(kind=rk), intent(in) :: f_beta real(kind=rk), intent(inout) :: f_y (*) integer, intent(in) :: f_incy","tags":"","loc":"module/external_interfaces_matmul.html"},{"title":"formatmul_opts – ForMatmul","text":"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Uses kinds module~~formatmul_opts~~UsesGraph module~formatmul_opts formatmul_opts kinds kinds module~formatmul_opts->kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~formatmul_opts~~UsedByGraph module~formatmul_opts formatmul_opts module~formatmul formatmul module~formatmul->module~formatmul_opts program~test_matmul10 test_matmul10 program~test_matmul10->module~formatmul program~test_matmul11 test_matmul11 program~test_matmul11->module~formatmul program~test_matmul12 test_matmul12 program~test_matmul12->module~formatmul program~test_matmul13 test_matmul13 program~test_matmul13->module~formatmul program~test_matmul14 test_matmul14 program~test_matmul14->module~formatmul program~test_matmul15 test_matmul15 program~test_matmul15->module~formatmul program~test_matmul3 test_matmul3 program~test_matmul3->module~formatmul program~test_matmul4 test_matmul4 program~test_matmul4->module~formatmul program~test_matmul5 test_matmul5 program~test_matmul5->module~formatmul program~test_matmul6 test_matmul6 program~test_matmul6->module~formatmul program~test_matmul7 test_matmul7 program~test_matmul7->module~formatmul program~test_matmul8 test_matmul8 program~test_matmul8->module~formatmul program~test_matmul9 test_matmul9 program~test_matmul9->module~formatmul Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public pure subroutine mat_mat_rel_AB_opt (A, B, C, option) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) character(len=*), intent(in) :: option public pure subroutine mat_mat_rel_ATB_opt (A, B, C, option) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) character(len=*), intent(in) :: option public pure subroutine mat_mat_rel_ABT_opt (A, B, C, option) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) character(len=*), intent(in) :: option public pure subroutine mat_mat_rel_ATBT_opt (A, B, C, option) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) character(len=*), intent(in) :: option public pure subroutine mat_vec_rel_Av_opt (A, v, w, option) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) real(kind=rk), intent(inout), contiguous :: w (:) character(len=*), intent(in) :: option public pure subroutine mat_vec_rel_ATv_opt (A, v, w, option) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) real(kind=rk), intent(inout), contiguous :: w (:) character(len=*), intent(in) :: option private pure subroutine mm_AB_1 (A, B, C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) private pure subroutine mm_AB_2 (A, B, C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) private pure subroutine mm_AB_3 (A, B, C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) private pure subroutine mm_AB_4 (A, B, C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) private pure subroutine mm_AB_5 (A, B, C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) private pure subroutine mm_AB_6 (A, B, C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) private pure subroutine mm_AB_7 (A, B, C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) private pure subroutine mm_AB_8 (A, B, C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) private pure subroutine mm_AB_9 (A, B, C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) private pure subroutine mm_AB_10 (A, B, C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) private pure subroutine mm_AB_11 (A, B, C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) private pure subroutine mm_AB_12 (A, B, C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) private pure subroutine mm_AB_13 (A, B, C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) private pure subroutine mm_ATB_1 (A, B, C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) private pure subroutine mm_ATB_2 (A, B, C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) private pure subroutine mm_ATB_3 (A, B, C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) private pure subroutine mm_ATB_4 (A, B, C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) private pure subroutine mm_ATB_5 (A, B, C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) private pure subroutine mm_ATB_6 (A, B, C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) private pure subroutine mm_ATB_7 (A, B, C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) private pure subroutine mm_ATB_8 (A, B, C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) private pure subroutine mm_ATB_9 (A, B, C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) private pure subroutine mm_ATB_10 (A, B, C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) private pure subroutine mm_ATB_11 (A, B, C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) private pure subroutine mm_ATB_12 (A, B, C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) private pure subroutine mm_ATB_13 (A, B, C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) private pure subroutine mm_ABT_1 (A, B, C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) private pure subroutine mm_ABT_2 (A, B, C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) private pure subroutine mm_ABT_3 (A, B, C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) private pure subroutine mm_ABT_4 (A, B, C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) private pure subroutine mm_ABT_5 (A, B, C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) private pure subroutine mm_ABT_6 (A, B, C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) private pure subroutine mm_ABT_7 (A, B, C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) private pure subroutine mm_ABT_8 (A, B, C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) private pure subroutine mm_ABT_9 (A, B, C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) private pure subroutine mm_ABT_10 (A, B, C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) private pure subroutine mm_ABT_11 (A, B, C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) private pure subroutine mm_ABT_12 (A, B, C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) private pure subroutine mm_ABT_13 (A, B, C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) private pure subroutine mm_ATBT_1 (A, B, C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) private pure subroutine mm_ATBT_2 (A, B, C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) private pure subroutine mm_ATBT_3 (A, B, C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) private pure subroutine mm_ATBT_4 (A, B, C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) private pure subroutine mm_ATBT_5 (A, B, C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) private pure subroutine mm_ATBT_6 (A, B, C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) private pure subroutine mm_ATBT_7 (A, B, C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) private pure subroutine mm_ATBT_8 (A, B, C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) private pure subroutine mm_ATBT_9 (A, B, C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) private pure subroutine mm_ATBT_10 (A, B, C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) private pure subroutine mm_ATBT_11 (A, B, C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) private pure subroutine mm_ATBT_12 (A, B, C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) private pure subroutine mm_ATBT_13 (A, B, C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) private pure subroutine mv_Av_1 (A, v, w) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) real(kind=rk), intent(inout), contiguous :: w (:) private pure subroutine mv_Av_2 (A, v, w) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) real(kind=rk), intent(inout), contiguous :: w (:) private pure subroutine mv_Av_3 (A, v, w) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) real(kind=rk), intent(inout), contiguous :: w (:) private pure subroutine mv_Av_4 (A, v, w) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) real(kind=rk), intent(inout), contiguous :: w (:) private pure subroutine mv_Av_5 (A, v, w) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) real(kind=rk), intent(inout), contiguous :: w (:) private pure subroutine mv_Av_6 (A, v, w) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) real(kind=rk), intent(inout), contiguous :: w (:) private pure subroutine mv_Av_7 (A, v, w) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) real(kind=rk), intent(inout), contiguous :: w (:) private pure subroutine mv_Av_8 (A, v, w) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) real(kind=rk), intent(inout), contiguous :: w (:) private pure subroutine mv_ATv_1 (A, v, w) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) real(kind=rk), intent(inout), contiguous :: w (:) private pure subroutine mv_ATv_2 (A, v, w) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) real(kind=rk), intent(inout), contiguous :: w (:) private pure subroutine mv_ATv_3 (A, v, w) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) real(kind=rk), intent(inout), contiguous :: w (:) private pure subroutine mv_ATv_4 (A, v, w) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) real(kind=rk), intent(inout), contiguous :: w (:) private pure subroutine mv_ATv_5 (A, v, w) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) real(kind=rk), intent(inout), contiguous :: w (:) private pure subroutine mv_ATv_6 (A, v, w) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) real(kind=rk), intent(inout), contiguous :: w (:) private pure subroutine mv_ATv_7 (A, v, w) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) real(kind=rk), intent(inout), contiguous :: w (:) private pure subroutine mv_ATv_8 (A, v, w) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) real(kind=rk), intent(inout), contiguous :: w (:)","tags":"","loc":"module/formatmul_opts.html"},{"title":"formatmul – ForMatmul","text":"Uses kinds formatmul_opts module~~formatmul~~UsesGraph module~formatmul formatmul kinds kinds module~formatmul->kinds module~formatmul_opts formatmul_opts module~formatmul->module~formatmul_opts module~formatmul_opts->kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~formatmul~~UsedByGraph module~formatmul formatmul program~test_matmul10 test_matmul10 program~test_matmul10->module~formatmul program~test_matmul11 test_matmul11 program~test_matmul11->module~formatmul program~test_matmul12 test_matmul12 program~test_matmul12->module~formatmul program~test_matmul13 test_matmul13 program~test_matmul13->module~formatmul program~test_matmul14 test_matmul14 program~test_matmul14->module~formatmul program~test_matmul15 test_matmul15 program~test_matmul15->module~formatmul program~test_matmul3 test_matmul3 program~test_matmul3->module~formatmul program~test_matmul4 test_matmul4 program~test_matmul4->module~formatmul program~test_matmul5 test_matmul5 program~test_matmul5->module~formatmul program~test_matmul6 test_matmul6 program~test_matmul6->module~formatmul program~test_matmul7 test_matmul7 program~test_matmul7->module~formatmul program~test_matmul8 test_matmul8 program~test_matmul8->module~formatmul program~test_matmul9 test_matmul9 program~test_matmul9->module~formatmul Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface matmul private pure function mat_mat_rel (A, B, transA, transB, option) result(C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) logical, intent(in), optional :: transA logical, intent(in), optional :: transB character(len=*), intent(in), optional :: option Return Value real(kind=rk), allocatable, (:,:) private pure function mat_mat_block_rel (a, b, transA, transB, option, nblock) result(c) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: a (:,:) real(kind=rk), intent(in), contiguous :: b (:,:) logical, intent(in), optional :: transA logical, intent(in), optional :: transB character(len=*), intent(in), optional :: option integer, intent(in) :: nblock Return Value real(kind=rk), allocatable, (:,:) private impure function mat_mat_coarray_rel (a, b, transA, transB, option, coarray) result(c) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: a (:,:) real(kind=rk), intent(in), contiguous :: b (:,:) logical, intent(in), optional :: transA logical, intent(in), optional :: transB character(len=*), intent(in), optional :: option logical, intent(in) :: coarray Return Value real(kind=rk), allocatable, (:,:) private pure function mat_vec_rel (A, v, transA, option) result(w) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) logical, intent(in), optional :: transA character(len=*), intent(in), optional :: option Return Value real(kind=rk), allocatable, (:) private pure function mat_vec_block_rel (A, v, transA, option, nblock) result(w) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) logical, intent(in), optional :: transA character(len=*), intent(in), optional :: option integer, intent(in) :: nblock Return Value real(kind=rk), allocatable, (:) private impure function mat_vec_coarray_rel (A, v, transA, option, coarray) result(w) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) logical, intent(in), optional :: transA character(len=*), intent(in), optional :: option logical, intent(in) :: coarray Return Value real(kind=rk), allocatable, (:) Functions private impure function mat_mat_coarray_rel (a, b, transA, transB, option, coarray) result(c) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: a (:,:) real(kind=rk), intent(in), contiguous :: b (:,:) logical, intent(in), optional :: transA logical, intent(in), optional :: transB character(len=*), intent(in), optional :: option logical, intent(in) :: coarray Return Value real(kind=rk), allocatable, (:,:) private impure function mat_vec_coarray_rel (A, v, transA, option, coarray) result(w) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) logical, intent(in), optional :: transA character(len=*), intent(in), optional :: option logical, intent(in) :: coarray Return Value real(kind=rk), allocatable, (:) private pure function mat_mat_block_rel (a, b, transA, transB, option, nblock) result(c) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: a (:,:) real(kind=rk), intent(in), contiguous :: b (:,:) logical, intent(in), optional :: transA logical, intent(in), optional :: transB character(len=*), intent(in), optional :: option integer, intent(in) :: nblock Return Value real(kind=rk), allocatable, (:,:) private pure function mat_vec_block_rel (A, v, transA, option, nblock) result(w) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) logical, intent(in), optional :: transA character(len=*), intent(in), optional :: option integer, intent(in) :: nblock Return Value real(kind=rk), allocatable, (:) private pure function mat_mat_rel (A, B, transA, transB, option) result(C) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) logical, intent(in), optional :: transA logical, intent(in), optional :: transB character(len=*), intent(in), optional :: option Return Value real(kind=rk), allocatable, (:,:) private pure function mat_vec_rel (A, v, transA, option) result(w) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) logical, intent(in), optional :: transA character(len=*), intent(in), optional :: option Return Value real(kind=rk), allocatable, (:) Subroutines private pure subroutine compute_block_ranges (d, nimg, block_size, start_elem, end_elem) Calculate block sizes and ranges.\nauthor: Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name integer, intent(in) :: d integer, intent(in) :: nimg integer, intent(out) :: block_size (nimg) integer, intent(out) :: start_elem (nimg) integer, intent(out) :: end_elem (nimg) private pure subroutine mat_mat_rel_AB (A, B, C, option) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) character(len=*), intent(in), optional :: option private pure subroutine mat_mat_rel_ATB (A, B, C, option) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) character(len=*), intent(in), optional :: option private pure subroutine mat_mat_rel_ABT (A, B, C, option) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) character(len=*), intent(in), optional :: option private pure subroutine mat_mat_rel_ATBT (A, B, C, option) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: B (:,:) real(kind=rk), intent(inout), contiguous :: C (:,:) character(len=*), intent(in), optional :: option private pure subroutine mat_vec_rel_Av (A, v, w, option) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) real(kind=rk), intent(inout), contiguous :: w (:) character(len=*), intent(in), optional :: option private pure subroutine mat_vec_rel_ATv (A, v, w, option) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: A (:,:) real(kind=rk), intent(in), contiguous :: v (:) real(kind=rk), intent(inout), contiguous :: w (:) character(len=*), intent(in), optional :: option","tags":"","loc":"module/formatmul.html"},{"title":"test_matmul3 – ForMatmul","text":"Uses formatmul kinds forunittest program~~test_matmul3~~UsesGraph program~test_matmul3 test_matmul3 forunittest forunittest program~test_matmul3->forunittest kinds kinds program~test_matmul3->kinds module~formatmul formatmul program~test_matmul3->module~formatmul module~formatmul->kinds module~formatmul_opts formatmul_opts module~formatmul->module~formatmul_opts module~formatmul_opts->kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~test_matmul3~~CallsGraph program~test_matmul3 test_matmul3 check check program~test_matmul3->check Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:,:) real(kind=rk), allocatable :: B (:,:) real(kind=rk), allocatable :: C_ref (:,:) real(kind=rk), allocatable :: C (:,:) integer :: m integer :: n integer :: o type(unit_test) :: ut Source Code program test_matmul3 use kinds use formatmul use forunittest implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C_ref (:,:), C (:,:) integer :: m , n , o type ( unit_test ) :: ut ! C(m,o) = A(m,n).B(n,o) m = 300 n = 200 o = 100 allocate ( A ( m , n ), B ( n , o )) call random_number ( A ) call random_number ( B ) A = A * 10 0.0_rk B = B * 10 0.0_rk C_ref = matmul ( A , B ) C = matmul ( A , B ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.1' ) C = matmul ( A , B , option = 'm1' ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.2' ) C = matmul ( A , B , option = 'm2' ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.3' ) C = matmul ( A , B , option = 'm3' ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.4' ) C = matmul ( A , B , option = 'm4' ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.5' ) C = matmul ( A , B , option = 'm5' ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.6' ) C = matmul ( A , B , option = 'm6' ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.7' ) C = matmul ( A , B , option = 'm7' ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.8' ) C = matmul ( A , B , option = 'm8' ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.9' ) C = matmul ( A , B , option = 'm9' ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.10' ) ! C = matmul(A,B, option='m10') ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul3.11') ! C = matmul(A,B, option='m11') ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul3.12') C = matmul ( A , B , option = 'm12' ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.13' ) C = matmul ( A , B , option = 'm13' ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.14' ) C = matmul ( A , B , nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.15' ) C = matmul ( A , B , option = 'm1' , nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.16' ) C = matmul ( A , B , option = 'm2' , nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.17' ) C = matmul ( A , B , option = 'm3' , nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.18' ) C = matmul ( A , B , option = 'm4' , nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.19' ) C = matmul ( A , B , option = 'm5' , nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.20' ) C = matmul ( A , B , option = 'm6' , nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.21' ) C = matmul ( A , B , option = 'm7' , nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.22' ) C = matmul ( A , B , option = 'm8' , nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.23' ) C = matmul ( A , B , option = 'm9' , nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.24' ) ! C = matmul(A,B, option='m10', nblock=4) ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul3.25') ! C = matmul(A,B, option='m11', nblock=4) ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul3.26') C = matmul ( A , B , option = 'm12' , nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.27' ) C = matmul ( A , B , option = 'm13' , nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.28' ) C = matmul ( A , B , option = 'm1' , transA = . false ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.29' ) C = matmul ( A , B , option = 'm2' , transA = . false ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.30' ) C = matmul ( A , B , option = 'm3' , transA = . false ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.31' ) C = matmul ( A , B , option = 'm4' , transA = . false ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.32' ) C = matmul ( A , B , option = 'm5' , transA = . false ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.33' ) C = matmul ( A , B , option = 'm6' , transA = . false ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.34' ) C = matmul ( A , B , option = 'm7' , transA = . false ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.35' ) C = matmul ( A , B , option = 'm8' , transA = . false ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.36' ) C = matmul ( A , B , option = 'm9' , transA = . false ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.37' ) ! C = matmul(A,B, option='m10', transA=.false., transB=.false.) ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul3.38') ! C = matmul(A,B, option='m11', transA=.false., transB=.false.) ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul3.39') C = matmul ( A , B , option = 'm12' , transA = . false ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.40' ) C = matmul ( A , B , option = 'm13' , transA = . false ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.41' ) C = matmul ( A , B , nblock = 4 , transA = . false ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.42' ) C = matmul ( A , B , option = 'm1' , nblock = 4 , transA = . false ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.43' ) C = matmul ( A , B , option = 'm2' , nblock = 4 , transA = . false ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.44' ) C = matmul ( A , B , option = 'm3' , nblock = 4 , transA = . false ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.45' ) C = matmul ( A , B , option = 'm4' , nblock = 4 , transA = . false ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.46' ) C = matmul ( A , B , option = 'm5' , nblock = 4 , transA = . false ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.47' ) C = matmul ( A , B , option = 'm6' , nblock = 4 , transA = . false ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.48' ) C = matmul ( A , B , option = 'm7' , nblock = 4 , transA = . false ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.49' ) C = matmul ( A , B , option = 'm8' , nblock = 4 , transA = . false ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.50' ) C = matmul ( A , B , option = 'm9' , nblock = 4 , transA = . false ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.51' ) ! C = matmul(A,B, option='m10', nblock=4, transA=.false., transB=.false.) ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul3.52') ! C = matmul(A,B, option='m11', nblock=4, transA=.false., transB=.false.) ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul3.53') C = matmul ( A , B , option = 'm12' , nblock = 4 , transA = . false ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.54' ) C = matmul ( A , B , option = 'm13' , nblock = 4 , transA = . false ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.55' ) end program test_matmul3","tags":"","loc":"program/test_matmul3.html"},{"title":"test_matmul6 – ForMatmul","text":"Uses formatmul kinds forunittest program~~test_matmul6~~UsesGraph program~test_matmul6 test_matmul6 forunittest forunittest program~test_matmul6->forunittest kinds kinds program~test_matmul6->kinds module~formatmul formatmul program~test_matmul6->module~formatmul module~formatmul->kinds module~formatmul_opts formatmul_opts module~formatmul->module~formatmul_opts module~formatmul_opts->kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~test_matmul6~~CallsGraph program~test_matmul6 test_matmul6 check check program~test_matmul6->check Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:,:) real(kind=rk), allocatable :: B (:,:) real(kind=rk), allocatable :: C_ref (:,:) real(kind=rk), allocatable :: C (:,:) integer :: m integer :: n integer :: o type(unit_test) :: ut Source Code program test_matmul6 use kinds use formatmul use forunittest implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C_ref (:,:), C (:,:) integer :: m , n , o type ( unit_test ) :: ut ! C(m,o) = A(n,m).B(o,n) m = 300 n = 200 o = 100 allocate ( A ( n , m ), B ( o , n )) call random_number ( A ) call random_number ( B ) A = A * 10 0.0_rk B = B * 10 0.0_rk C_ref = matmul ( transpose ( A ), transpose ( B )) C = matmul ( A , B , transA = . true ., transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul6.1' ) C = matmul ( A , B , option = 'm1' , transA = . true ., transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul6.2' ) C = matmul ( A , B , option = 'm2' , transA = . true ., transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul6.3' ) C = matmul ( A , B , option = 'm3' , transA = . true ., transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul6.4' ) C = matmul ( A , B , option = 'm4' , transA = . true ., transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul6.5' ) C = matmul ( A , B , option = 'm5' , transA = . true ., transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul6.6' ) C = matmul ( A , B , option = 'm6' , transA = . true ., transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul6.7' ) C = matmul ( A , B , option = 'm7' , transA = . true ., transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul6.8' ) C = matmul ( A , B , option = 'm8' , transA = . true ., transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul6.9' ) C = matmul ( A , B , option = 'm9' , transA = . true ., transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul6.10' ) ! C = matmul(A,B, option='m10', transA=.true., transB=.true.) ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul6.11') ! C = matmul(A,B, option='m11', transA=.true., transB=.true.) ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul6.12') C = matmul ( A , B , option = 'm12' , transA = . true ., transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul6.13' ) C = matmul ( A , B , option = 'm13' , transA = . true ., transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul6.14' ) C = matmul ( A , B , transA = . true ., transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul6.15' ) C = matmul ( A , B , option = 'm1' , transA = . true ., transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul6.16' ) C = matmul ( A , B , option = 'm2' , transA = . true ., transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul6.17' ) C = matmul ( A , B , option = 'm3' , transA = . true ., transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul6.18' ) C = matmul ( A , B , option = 'm4' , transA = . true ., transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul6.19' ) C = matmul ( A , B , option = 'm5' , transA = . true ., transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul6.20' ) C = matmul ( A , B , option = 'm6' , transA = . true ., transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul6.21' ) C = matmul ( A , B , option = 'm7' , transA = . true ., transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul6.22' ) C = matmul ( A , B , option = 'm8' , transA = . true ., transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul6.23' ) C = matmul ( A , B , option = 'm9' , transA = . true ., transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul6.24' ) ! C = matmul(A,B, option='m10', transA=.true., transB=.true., nblock=4) ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul6.25') ! C = matmul(A,B, option='m11', transA=.true., transB=.true., nblock=4) ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul6.26') C = matmul ( A , B , option = 'm12' , transA = . true ., transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul6.27' ) C = matmul ( A , B , option = 'm13' , transA = . true ., transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul6.28' ) end program test_matmul6","tags":"","loc":"program/test_matmul6.html"},{"title":"test_matmul14 – ForMatmul","text":"Uses formatmul kinds forunittest program~~test_matmul14~~UsesGraph program~test_matmul14 test_matmul14 forunittest forunittest program~test_matmul14->forunittest kinds kinds program~test_matmul14->kinds module~formatmul formatmul program~test_matmul14->module~formatmul module~formatmul->kinds module~formatmul_opts formatmul_opts module~formatmul->module~formatmul_opts module~formatmul_opts->kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~test_matmul14~~CallsGraph program~test_matmul14 test_matmul14 check check program~test_matmul14->check Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:,:) real(kind=rk), allocatable :: v (:) real(kind=rk), allocatable :: w_ref (:) real(kind=rk), allocatable :: w (:) integer :: m integer :: n integer :: im type(unit_test) :: ut Source Code program test_matmul14 use kinds use formatmul use forunittest implicit none real ( rk ), allocatable :: A (:,:), v (:) real ( rk ), allocatable :: w_ref (:), w (:) integer :: m , n , im type ( unit_test ) :: ut #if defined(USE_COARRAY) im = this_image () #else im = 1 #endif ! w(m) = A(m,n).v(n) m = 500 n = 300 allocate ( A ( m , n ), v ( n )) call random_number ( A ) call random_number ( v ) A = A * 10 0.0_rk v = v * 10 0.0_rk w_ref = matmul ( A , v ) w = matmul ( A , v , coarray = . true .) if ( im == 1 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul14.1' ) w = matmul ( A , v , option = 'm1' , coarray = . true .) if ( im == 1 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul14.2' ) w = matmul ( A , v , option = 'm2' , coarray = . true .) if ( im == 1 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul14.3' ) w = matmul ( A , v , option = 'm3' , coarray = . true .) if ( im == 1 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul14.4' ) w = matmul ( A , v , option = 'm4' , coarray = . true .) if ( im == 1 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul14.5' ) w = matmul ( A , v , option = 'm5' , coarray = . true .) if ( im == 1 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul14.6' ) w = matmul ( A , v , option = 'm6' , coarray = . true .) if ( im == 1 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul14.7' ) ! w = matmul(A,v, option='m7', coarray=.true.) ! if (im==1) call ut%check(w, w_ref, tol=1e-5_rk, msg='test_matmul14.8') ! w = matmul(A,v, option='m8', coarray=.true.) ! if (im==1) call ut%check(w, w_ref, tol=1e-5_rk, msg='test_matmul14.9') end program test_matmul14","tags":"","loc":"program/test_matmul14.html"},{"title":"test_matmul13 – ForMatmul","text":"Uses formatmul kinds forunittest program~~test_matmul13~~UsesGraph program~test_matmul13 test_matmul13 forunittest forunittest program~test_matmul13->forunittest kinds kinds program~test_matmul13->kinds module~formatmul formatmul program~test_matmul13->module~formatmul module~formatmul->kinds module~formatmul_opts formatmul_opts module~formatmul->module~formatmul_opts module~formatmul_opts->kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~test_matmul13~~CallsGraph program~test_matmul13 test_matmul13 check check program~test_matmul13->check Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:,:) real(kind=rk), allocatable :: B (:,:) real(kind=rk), allocatable :: C_ref (:,:) real(kind=rk), allocatable :: C (:,:) integer :: m integer :: n integer :: o integer :: im type(unit_test) :: ut Source Code program test_matmul13 use kinds use formatmul use forunittest implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C_ref (:,:), C (:,:) integer :: m , n , o , im type ( unit_test ) :: ut #if defined(USE_COARRAY) im = this_image () #else im = 1 #endif ! C(m,o) = A(n,m).B(o,n) m = 500 n = 400 o = 300 allocate ( A ( n , m ), B ( o , n )) call random_number ( A ) call random_number ( B ) A = A * 10 0.0_rk B = B * 10 0.0_rk C_ref = matmul ( transpose ( A ), transpose ( B )) C = matmul ( A , B , transA = . true ., transB = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul13.1' ) C = matmul ( A , B , option = 'm1' , transA = . true ., transB = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul13.2' ) C = matmul ( A , B , option = 'm2' , transA = . true ., transB = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul13.3' ) C = matmul ( A , B , option = 'm3' , transA = . true ., transB = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul13.4' ) C = matmul ( A , B , option = 'm4' , transA = . true ., transB = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul13.5' ) C = matmul ( A , B , option = 'm5' , transA = . true ., transB = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul13.6' ) C = matmul ( A , B , option = 'm6' , transA = . true ., transB = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul13.7' ) C = matmul ( A , B , option = 'm7' , transA = . true ., transB = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul13.8' ) C = matmul ( A , B , option = 'm8' , transA = . true ., transB = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul13.9' ) C = matmul ( A , B , option = 'm9' , transA = . true ., transB = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul13.10' ) ! C = matmul(A,B, option='m10', transA=.true., transB=.true., coarray=.true.) ! if (im==1) call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul13.11') ! C = matmul(A,B, option='m11', transA=.true., transB=.true., coarray=.true.) ! if (im==1) call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul13.12') C = matmul ( A , B , option = 'm12' , transA = . true ., transB = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul13.13' ) C = matmul ( A , B , option = 'm13' , transA = . true ., transB = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul13.14' ) end program test_matmul13","tags":"","loc":"program/test_matmul13.html"},{"title":"test_matmul11 – ForMatmul","text":"Uses formatmul kinds forunittest program~~test_matmul11~~UsesGraph program~test_matmul11 test_matmul11 forunittest forunittest program~test_matmul11->forunittest kinds kinds program~test_matmul11->kinds module~formatmul formatmul program~test_matmul11->module~formatmul module~formatmul->kinds module~formatmul_opts formatmul_opts module~formatmul->module~formatmul_opts module~formatmul_opts->kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~test_matmul11~~CallsGraph program~test_matmul11 test_matmul11 check check program~test_matmul11->check Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:,:) real(kind=rk), allocatable :: B (:,:) real(kind=rk), allocatable :: C_ref (:,:) real(kind=rk), allocatable :: C (:,:) integer :: m integer :: n integer :: o integer :: im type(unit_test) :: ut Source Code program test_matmul11 use kinds use formatmul use forunittest implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C_ref (:,:), C (:,:) integer :: m , n , o , im type ( unit_test ) :: ut #if defined(USE_COARRAY) im = this_image () #else im = 1 #endif ! C(m,o) = A(n,m).B(n,o) m = 500 n = 400 o = 300 allocate ( A ( n , m ), B ( n , o )) call random_number ( A ) call random_number ( B ) A = A * 10 0.0_rk B = B * 10 0.0_rk C_ref = matmul ( transpose ( A ), B ) C = matmul ( A , B , transA = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul11.1' ) C = matmul ( A , B , option = 'm1' , transA = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul11.2' ) C = matmul ( A , B , option = 'm2' , transA = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul11.3' ) C = matmul ( A , B , option = 'm3' , transA = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul11.4' ) C = matmul ( A , B , option = 'm4' , transA = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul11.5' ) C = matmul ( A , B , option = 'm5' , transA = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul11.6' ) C = matmul ( A , B , option = 'm6' , transA = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul11.7' ) C = matmul ( A , B , option = 'm7' , transA = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul11.8' ) C = matmul ( A , B , option = 'm8' , transA = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul11.9' ) C = matmul ( A , B , option = 'm9' , transA = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul11.10' ) ! C = matmul(A,B, option='m10', transA=.true., coarray=.true.) ! if (im==1) call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul11.11') ! C = matmul(A,B, option='m11', transA=.true., coarray=.true.) ! if (im==1) call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul11.12') C = matmul ( A , B , option = 'm12' , transA = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul11.13' ) C = matmul ( A , B , option = 'm13' , transA = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul11.14' ) end program test_matmul11","tags":"","loc":"program/test_matmul11.html"},{"title":"test_matmul10 – ForMatmul","text":"Uses formatmul kinds forunittest program~~test_matmul10~~UsesGraph program~test_matmul10 test_matmul10 forunittest forunittest program~test_matmul10->forunittest kinds kinds program~test_matmul10->kinds module~formatmul formatmul program~test_matmul10->module~formatmul module~formatmul->kinds module~formatmul_opts formatmul_opts module~formatmul->module~formatmul_opts module~formatmul_opts->kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~test_matmul10~~CallsGraph program~test_matmul10 test_matmul10 check check program~test_matmul10->check Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:,:) real(kind=rk), allocatable :: B (:,:) real(kind=rk), allocatable :: C_ref (:,:) real(kind=rk), allocatable :: C (:,:) integer :: m integer :: n integer :: o integer :: im type(unit_test) :: ut Source Code program test_matmul10 use kinds use formatmul use forunittest implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C_ref (:,:), C (:,:) integer :: m , n , o , im type ( unit_test ) :: ut #if defined(USE_COARRAY) im = this_image () #else im = 1 #endif ! C(m,o) = A(m,n).B(n,o) m = 500 n = 400 o = 300 allocate ( A ( m , n ), B ( n , o )) call random_number ( A ) call random_number ( B ) A = A * 10 0.0_rk B = B * 10 0.0_rk C_ref = matmul ( A , B ) C = matmul ( A , B , coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul10.1' ) C = matmul ( A , B , option = 'm1' , coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul10.2' ) C = matmul ( A , B , option = 'm2' , coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul10.3' ) C = matmul ( A , B , option = 'm3' , coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul10.4' ) C = matmul ( A , B , option = 'm4' , coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul10.5' ) C = matmul ( A , B , option = 'm5' , coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul10.6' ) C = matmul ( A , B , option = 'm6' , coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul10.7' ) C = matmul ( A , B , option = 'm7' , coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul10.8' ) C = matmul ( A , B , option = 'm8' , coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul10.9' ) C = matmul ( A , B , option = 'm9' , coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul10.10' ) !    C = matmul(A,B, option='m10', coarray=.true.) !    if (im==1) call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul10.11') !    C = matmul(A,B, option='m11', coarray=.true.) !    if (im==1) call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul10.12') C = matmul ( A , B , option = 'm12' , coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul10.13' ) C = matmul ( A , B , option = 'm13' , coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul10.14' ) end program test_matmul10","tags":"","loc":"program/test_matmul10.html"},{"title":"test_matmul5 – ForMatmul","text":"Uses formatmul kinds forunittest program~~test_matmul5~~UsesGraph program~test_matmul5 test_matmul5 forunittest forunittest program~test_matmul5->forunittest kinds kinds program~test_matmul5->kinds module~formatmul formatmul program~test_matmul5->module~formatmul module~formatmul->kinds module~formatmul_opts formatmul_opts module~formatmul->module~formatmul_opts module~formatmul_opts->kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~test_matmul5~~CallsGraph program~test_matmul5 test_matmul5 check check program~test_matmul5->check Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:,:) real(kind=rk), allocatable :: B (:,:) real(kind=rk), allocatable :: C_ref (:,:) real(kind=rk), allocatable :: C (:,:) integer :: m integer :: n integer :: o type(unit_test) :: ut Source Code program test_matmul5 use kinds use formatmul use forunittest implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C_ref (:,:), C (:,:) integer :: m , n , o type ( unit_test ) :: ut ! C(m,o) = A(m,n).B(o,n) m = 300 n = 200 o = 100 allocate ( A ( m , n ), B ( o , n )) call random_number ( A ) call random_number ( B ) A = A * 10 0.0_rk B = B * 10 0.0_rk C_ref = matmul ( A , transpose ( B )) C = matmul ( A , B , transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.1' ) C = matmul ( A , B , option = 'm1' , transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.2' ) C = matmul ( A , B , option = 'm2' , transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.3' ) C = matmul ( A , B , option = 'm3' , transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.4' ) C = matmul ( A , B , option = 'm4' , transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.5' ) C = matmul ( A , B , option = 'm5' , transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.6' ) C = matmul ( A , B , option = 'm6' , transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.7' ) C = matmul ( A , B , option = 'm7' , transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.8' ) C = matmul ( A , B , option = 'm8' , transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.9' ) C = matmul ( A , B , option = 'm9' , transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.10' ) ! C = matmul(A,B, option='m10', transB=.true.) ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul5.11') ! C = matmul(A,B, option='m11', transB=.true.) ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul5.12') C = matmul ( A , B , option = 'm12' , transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.13' ) C = matmul ( A , B , option = 'm13' , transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.14' ) C = matmul ( A , B , transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.15' ) C = matmul ( A , B , option = 'm1' , transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.16' ) C = matmul ( A , B , option = 'm2' , transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.17' ) C = matmul ( A , B , option = 'm3' , transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.18' ) C = matmul ( A , B , option = 'm4' , transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.19' ) C = matmul ( A , B , option = 'm5' , transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.20' ) C = matmul ( A , B , option = 'm6' , transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.21' ) C = matmul ( A , B , option = 'm7' , transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.22' ) C = matmul ( A , B , option = 'm8' , transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.23' ) C = matmul ( A , B , option = 'm9' , transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.24' ) ! C = matmul(A,B, option='m10', transB=.true., nblock=4) ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul5.25') ! C = matmul(A,B, option='m11', transB=.true., nblock=4) ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul5.26') C = matmul ( A , B , option = 'm12' , transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.27' ) C = matmul ( A , B , option = 'm13' , transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.28' ) C = matmul ( A , B , transA = . false ., transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.29' ) C = matmul ( A , B , option = 'm1' , transA = . false ., transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.30' ) C = matmul ( A , B , option = 'm2' , transA = . false ., transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.31' ) C = matmul ( A , B , option = 'm3' , transA = . false ., transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.32' ) C = matmul ( A , B , option = 'm4' , transA = . false ., transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.33' ) C = matmul ( A , B , option = 'm5' , transA = . false ., transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.34' ) C = matmul ( A , B , option = 'm6' , transA = . false ., transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.35' ) C = matmul ( A , B , option = 'm7' , transA = . false ., transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.36' ) C = matmul ( A , B , option = 'm8' , transA = . false ., transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.37' ) C = matmul ( A , B , option = 'm9' , transA = . false ., transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.38' ) ! C = matmul(A,B, option='m10', transA=.false., transB=.true.) ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul5.39') ! C = matmul(A,B, option='m11', transA=.false., transB=.true.) ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul5.40') C = matmul ( A , B , option = 'm12' , transA = . false ., transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.41' ) C = matmul ( A , B , option = 'm13' , transA = . false ., transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.42' ) C = matmul ( A , B , transA = . false ., transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.43' ) C = matmul ( A , B , option = 'm1' , transA = . false ., transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.44' ) C = matmul ( A , B , option = 'm2' , transA = . false ., transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.45' ) C = matmul ( A , B , option = 'm3' , transA = . false ., transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.46' ) C = matmul ( A , B , option = 'm4' , transA = . false ., transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.47' ) C = matmul ( A , B , option = 'm5' , transA = . false ., transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.48' ) C = matmul ( A , B , option = 'm6' , transA = . false ., transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.49' ) C = matmul ( A , B , option = 'm7' , transA = . false ., transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.50' ) C = matmul ( A , B , option = 'm8' , transA = . false ., transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.51' ) C = matmul ( A , B , option = 'm9' , transA = . false ., transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.52' ) ! C = matmul(A,B, option='m10', transA=.false., transB=.true., nblock=4) ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul5.53') ! C = matmul(A,B, option='m11', transA=.false., transB=.true., nblock=4) ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul5.54') C = matmul ( A , B , option = 'm12' , transA = . false ., transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.55' ) C = matmul ( A , B , option = 'm13' , transA = . false ., transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.56' ) end program test_matmul5","tags":"","loc":"program/test_matmul5.html"},{"title":"test_matmul9 – ForMatmul","text":"Uses formatmul kinds forunittest program~~test_matmul9~~UsesGraph program~test_matmul9 test_matmul9 forunittest forunittest program~test_matmul9->forunittest kinds kinds program~test_matmul9->kinds module~formatmul formatmul program~test_matmul9->module~formatmul module~formatmul->kinds module~formatmul_opts formatmul_opts module~formatmul->module~formatmul_opts module~formatmul_opts->kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~test_matmul9~~CallsGraph program~test_matmul9 test_matmul9 check check program~test_matmul9->check Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:,:) real(kind=rk), allocatable :: v (:) real(kind=rk), allocatable :: w_ref (:) real(kind=rk), allocatable :: w (:) integer :: m integer :: n type(unit_test) :: ut Source Code program test_matmul9 use kinds use formatmul use forunittest implicit none real ( rk ), allocatable :: A (:,:), v (:) real ( rk ), allocatable :: w_ref (:), w (:) integer :: m , n type ( unit_test ) :: ut ! w(n) = v(m).A(m,n) m = 100 n = 300 allocate ( A ( m , n ), v ( m )) call random_number ( A ) call random_number ( v ) A = A * 10 0.0_rk v = v * 10 0.0_rk w_ref = matmul ( v , A ) w = matmul ( A , v , transA = . true .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul9.1' ) w = matmul ( A , v , option = 'm1' , transA = . true .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul9.2' ) w = matmul ( A , v , option = 'm2' , transA = . true .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul9.3' ) w = matmul ( A , v , option = 'm3' , transA = . true .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul9.4' ) w = matmul ( A , v , option = 'm4' , transA = . true .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul9.5' ) w = matmul ( A , v , option = 'm5' , transA = . true .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul9.6' ) w = matmul ( A , v , option = 'm6' , transA = . true .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul9.7' ) ! w = matmul(A,v, option='m7', transA=.true.) ! call ut%check(w, w_ref, tol=1e-5_rk, msg='test_matmul9.8') ! w = matmul(A,v, option='m8', transA=.true.) ! call ut%check(w, w_ref, tol=1e-5_rk, msg='test_matmul9.9') w = matmul ( A , v , transA = . true ., nblock = 4 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul9.10' ) w = matmul ( A , v , option = 'm1' , transA = . true ., nblock = 4 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul9.11' ) w = matmul ( A , v , option = 'm2' , transA = . true ., nblock = 4 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul9.12' ) w = matmul ( A , v , option = 'm3' , transA = . true ., nblock = 4 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul9.13' ) w = matmul ( A , v , option = 'm4' , transA = . true ., nblock = 4 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul9.14' ) w = matmul ( A , v , option = 'm5' , transA = . true ., nblock = 4 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul9.15' ) w = matmul ( A , v , option = 'm6' , transA = . true ., nblock = 4 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul9.16' ) ! w = matmul(A,v, option='m7', transA=.true., nblock=4) ! call ut%check(w, w_ref, tol=1e-5_rk, msg='test_matmul9.17') ! w = matmul(A,v, option='m8', transA=.true., nblock=4) ! call ut%check(w, w_ref, tol=1e-5_rk, msg='test_matmul9.18') end program test_matmul9","tags":"","loc":"program/test_matmul9.html"},{"title":"test_matmul8 – ForMatmul","text":"Uses formatmul kinds forunittest program~~test_matmul8~~UsesGraph program~test_matmul8 test_matmul8 forunittest forunittest program~test_matmul8->forunittest kinds kinds program~test_matmul8->kinds module~formatmul formatmul program~test_matmul8->module~formatmul module~formatmul->kinds module~formatmul_opts formatmul_opts module~formatmul->module~formatmul_opts module~formatmul_opts->kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~test_matmul8~~CallsGraph program~test_matmul8 test_matmul8 check check program~test_matmul8->check Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:,:) real(kind=rk), allocatable :: v (:) real(kind=rk), allocatable :: w_ref (:) real(kind=rk), allocatable :: w (:) integer :: m integer :: n type(unit_test) :: ut Source Code program test_matmul8 use kinds use formatmul use forunittest implicit none real ( rk ), allocatable :: A (:,:), v (:) real ( rk ), allocatable :: w_ref (:), w (:) integer :: m , n type ( unit_test ) :: ut ! w(m) = A(n,m).v(n) m = 100 n = 300 allocate ( A ( n , m ), v ( n )) call random_number ( A ) call random_number ( v ) A = A * 10 0.0_rk v = v * 10 0.0_rk w_ref = matmul ( transpose ( A ), v ) w = matmul ( A , v , transA = . true .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul8.1' ) w = matmul ( A , v , option = 'm1' , transA = . true .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul8.2' ) w = matmul ( A , v , option = 'm2' , transA = . true .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul8.3' ) w = matmul ( A , v , option = 'm3' , transA = . true .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul8.4' ) w = matmul ( A , v , option = 'm4' , transA = . true .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul8.5' ) w = matmul ( A , v , option = 'm5' , transA = . true .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul8.6' ) w = matmul ( A , v , option = 'm6' , transA = . true .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul8.7' ) ! w = matmul(A,v, option='m7', transA=.true.) ! call ut%check(w, w_ref, tol=1e-5_rk, msg='test_matmul8.8') ! w = matmul(A,v, option='m8', transA=.true.) ! call ut%check(w, w_ref, tol=1e-5_rk, msg='test_matmul8.9') w = matmul ( A , v , transA = . true ., nblock = 4 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul8.10' ) w = matmul ( A , v , option = 'm1' , transA = . true ., nblock = 4 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul8.11' ) w = matmul ( A , v , option = 'm2' , transA = . true ., nblock = 4 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul8.12' ) w = matmul ( A , v , option = 'm3' , transA = . true ., nblock = 4 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul8.13' ) w = matmul ( A , v , option = 'm4' , transA = . true ., nblock = 4 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul8.14' ) w = matmul ( A , v , option = 'm5' , transA = . true ., nblock = 4 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul8.15' ) w = matmul ( A , v , option = 'm6' , transA = . true ., nblock = 4 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul8.16' ) ! w = matmul(A,v, option='m7', transA=.true., nblock=4) ! call ut%check(w, w_ref, tol=1e-5_rk, msg='test_matmul8.17') ! w = matmul(A,v, option='m8', transA=.true., nblock=4) ! call ut%check(w, w_ref, tol=1e-5_rk, msg='test_matmul8.18') end program test_matmul8","tags":"","loc":"program/test_matmul8.html"},{"title":"test_matmul15 – ForMatmul","text":"Uses formatmul kinds forunittest program~~test_matmul15~~UsesGraph program~test_matmul15 test_matmul15 forunittest forunittest program~test_matmul15->forunittest kinds kinds program~test_matmul15->kinds module~formatmul formatmul program~test_matmul15->module~formatmul module~formatmul->kinds module~formatmul_opts formatmul_opts module~formatmul->module~formatmul_opts module~formatmul_opts->kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~test_matmul15~~CallsGraph program~test_matmul15 test_matmul15 check check program~test_matmul15->check Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:,:) real(kind=rk), allocatable :: v (:) real(kind=rk), allocatable :: w_ref (:) real(kind=rk), allocatable :: w (:) integer :: m integer :: n integer :: im type(unit_test) :: ut Source Code program test_matmul15 use kinds use formatmul use forunittest implicit none real ( rk ), allocatable :: A (:,:), v (:) real ( rk ), allocatable :: w_ref (:), w (:) integer :: m , n , im type ( unit_test ) :: ut #if defined(USE_COARRAY) im = this_image () #else im = 1 #endif ! w(m) = A(n,m).v(n) m = 100 n = 300 allocate ( A ( n , m ), v ( n )) call random_number ( A ) call random_number ( v ) A = A * 10 0.0_rk v = v * 10 0.0_rk w_ref = matmul ( transpose ( A ), v ) w = matmul ( A , v , transA = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul15.1' ) w = matmul ( A , v , option = 'm1' , transA = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul15.2' ) w = matmul ( A , v , option = 'm2' , transA = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul15.3' ) w = matmul ( A , v , option = 'm3' , transA = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul15.4' ) w = matmul ( A , v , option = 'm4' , transA = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul15.5' ) w = matmul ( A , v , option = 'm5' , transA = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul15.6' ) w = matmul ( A , v , option = 'm6' , transA = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul15.7' ) ! w = matmul(A,v, option='m7', transA=.true., coarray=.true.) ! if (im==1) call ut%check(w, w_ref, tol=1e-5_rk, msg='test_matmul15.8') ! w = matmul(A,v, option='m8', transA=.true., coarray=.true.) ! if (im==1) call ut%check(w, w_ref, tol=1e-5_rk, msg='test_matmul15.9') end program test_matmul15","tags":"","loc":"program/test_matmul15.html"},{"title":"test_matmul12 – ForMatmul","text":"Uses formatmul kinds forunittest program~~test_matmul12~~UsesGraph program~test_matmul12 test_matmul12 forunittest forunittest program~test_matmul12->forunittest kinds kinds program~test_matmul12->kinds module~formatmul formatmul program~test_matmul12->module~formatmul module~formatmul->kinds module~formatmul_opts formatmul_opts module~formatmul->module~formatmul_opts module~formatmul_opts->kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~test_matmul12~~CallsGraph program~test_matmul12 test_matmul12 check check program~test_matmul12->check Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:,:) real(kind=rk), allocatable :: B (:,:) real(kind=rk), allocatable :: C_ref (:,:) real(kind=rk), allocatable :: C (:,:) integer :: m integer :: n integer :: o integer :: im type(unit_test) :: ut Source Code program test_matmul12 use kinds use formatmul use forunittest implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C_ref (:,:), C (:,:) integer :: m , n , o , im type ( unit_test ) :: ut #if defined(USE_COARRAY) im = this_image () #else im = 1 #endif ! C(m,o) = A(m,n).B(o,n) m = 500 n = 400 o = 300 allocate ( A ( m , n ), B ( o , n )) call random_number ( A ) call random_number ( B ) A = A * 10 0.0_rk B = B * 10 0.0_rk C_ref = matmul ( A , transpose ( B )) C = matmul ( A , B , transB = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul12.1' ) C = matmul ( A , B , option = 'm1' , transB = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul12.2' ) C = matmul ( A , B , option = 'm2' , transB = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul12.3' ) C = matmul ( A , B , option = 'm3' , transB = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul12.4' ) C = matmul ( A , B , option = 'm4' , transB = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul12.5' ) C = matmul ( A , B , option = 'm5' , transB = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul12.6' ) C = matmul ( A , B , option = 'm6' , transB = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul12.7' ) C = matmul ( A , B , option = 'm7' , transB = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul12.8' ) C = matmul ( A , B , option = 'm8' , transB = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul12.9' ) C = matmul ( A , B , option = 'm9' , transB = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul12.10' ) ! C = matmul(A,B, option='m10', transB=.true., coarray=.true.) ! if (im==1) call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul12.11') ! C = matmul(A,B, option='m11', transB=.true., coarray=.true.) ! if (im==1) call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul12.12') C = matmul ( A , B , option = 'm12' , transB = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul12.13' ) C = matmul ( A , B , option = 'm13' , transB = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul12.14' ) end program test_matmul12","tags":"","loc":"program/test_matmul12.html"},{"title":"test_matmul7 – ForMatmul","text":"Uses formatmul kinds forunittest program~~test_matmul7~~UsesGraph program~test_matmul7 test_matmul7 forunittest forunittest program~test_matmul7->forunittest kinds kinds program~test_matmul7->kinds module~formatmul formatmul program~test_matmul7->module~formatmul module~formatmul->kinds module~formatmul_opts formatmul_opts module~formatmul->module~formatmul_opts module~formatmul_opts->kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~test_matmul7~~CallsGraph program~test_matmul7 test_matmul7 check check program~test_matmul7->check Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:,:) real(kind=rk), allocatable :: v (:) real(kind=rk), allocatable :: w_ref (:) real(kind=rk), allocatable :: w (:) integer :: m integer :: n type(unit_test) :: ut Source Code program test_matmul7 use kinds use formatmul use forunittest implicit none real ( rk ), allocatable :: A (:,:), v (:) real ( rk ), allocatable :: w_ref (:), w (:) integer :: m , n type ( unit_test ) :: ut ! w(m) = A(m,n).v(n) m = 100 n = 300 allocate ( A ( m , n ), v ( n )) call random_number ( A ) call random_number ( v ) A = A * 10 0.0_rk v = v * 10 0.0_rk w_ref = matmul ( A , v ) w = matmul ( A , v ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.1' ) w = matmul ( A , v , option = 'm1' ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.2' ) w = matmul ( A , v , option = 'm2' ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.3' ) w = matmul ( A , v , option = 'm3' ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.4' ) w = matmul ( A , v , option = 'm4' ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.5' ) w = matmul ( A , v , option = 'm5' ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.6' ) w = matmul ( A , v , option = 'm6' ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.7' ) ! w = matmul(A,v, option='m7') ! call ut%check(w, w_ref, tol=1e-5_rk, msg='test_matmul7.8') ! w = matmul(A,v, option='m8') ! call ut%check(w, w_ref, tol=1e-5_rk, msg='test_matmul7.9') w = matmul ( A , v , nblock = 4 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.10' ) w = matmul ( A , v , option = 'm1' , nblock = 4 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.11' ) w = matmul ( A , v , option = 'm2' , nblock = 4 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.12' ) w = matmul ( A , v , option = 'm3' , nblock = 4 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.13' ) w = matmul ( A , v , option = 'm4' , nblock = 4 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.14' ) w = matmul ( A , v , option = 'm5' , nblock = 4 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.15' ) w = matmul ( A , v , option = 'm6' , nblock = 4 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.16' ) ! w = matmul(A,v, option='m7', nblock=4) ! call ut%check(w, w_ref, tol=1e-5_rk, msg='test_matmul7.17') ! w = matmul(A,v, option='m8', nblock=4) ! call ut%check(w, w_ref, tol=1e-5_rk, msg='test_matmul7.18') w = matmul ( A , v , option = 'm1' , transA = . false .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.19' ) w = matmul ( A , v , option = 'm2' , transA = . false .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.20' ) w = matmul ( A , v , option = 'm3' , transA = . false .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.21' ) w = matmul ( A , v , option = 'm4' , transA = . false .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.22' ) w = matmul ( A , v , option = 'm5' , transA = . false .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.23' ) w = matmul ( A , v , option = 'm6' , transA = . false .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.24' ) ! w = matmul(A,v, option='m7', transA=.false.) ! call ut%check(w, w_ref, tol=1e-5_rk, msg='test_matmul7.25') ! w = matmul(A,v, option='m8', transA=.false.) ! call ut%check(w, w_ref, tol=1e-5_rk, msg='test_matmul7.26') w = matmul ( A , v , nblock = 4 , transA = . false .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.27' ) w = matmul ( A , v , option = 'm1' , nblock = 4 , transA = . false .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.28' ) w = matmul ( A , v , option = 'm2' , nblock = 4 , transA = . false .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.29' ) w = matmul ( A , v , option = 'm3' , nblock = 4 , transA = . false .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.30' ) w = matmul ( A , v , option = 'm4' , nblock = 4 , transA = . false .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.31' ) w = matmul ( A , v , option = 'm5' , nblock = 4 , transA = . false .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.32' ) w = matmul ( A , v , option = 'm6' , nblock = 4 , transA = . false .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.33' ) ! w = matmul(A,v, option='m7', nblock=4, transA=.false.) ! call ut%check(w, w_ref, tol=1e-5_rk, msg='test_matmul7.34') ! w = matmul(A,v, option='m8', nblock=4, transA=.false.) ! call ut%check(w, w_ref, tol=1e-5_rk, msg='test_matmul7.35') end program test_matmul7","tags":"","loc":"program/test_matmul7.html"},{"title":"test_matmul4 – ForMatmul","text":"Uses formatmul kinds forunittest program~~test_matmul4~~UsesGraph program~test_matmul4 test_matmul4 forunittest forunittest program~test_matmul4->forunittest kinds kinds program~test_matmul4->kinds module~formatmul formatmul program~test_matmul4->module~formatmul module~formatmul->kinds module~formatmul_opts formatmul_opts module~formatmul->module~formatmul_opts module~formatmul_opts->kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~test_matmul4~~CallsGraph program~test_matmul4 test_matmul4 check check program~test_matmul4->check Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), allocatable :: A (:,:) real(kind=rk), allocatable :: B (:,:) real(kind=rk), allocatable :: C_ref (:,:) real(kind=rk), allocatable :: C (:,:) integer :: m integer :: n integer :: o type(unit_test) :: ut Source Code program test_matmul4 use kinds use formatmul use forunittest implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C_ref (:,:), C (:,:) integer :: m , n , o type ( unit_test ) :: ut ! C(m,o) = A(n,m).B(n,o) m = 300 n = 200 o = 100 allocate ( A ( n , m ), B ( n , o )) call random_number ( A ) call random_number ( B ) A = A * 10 0.0_rk B = B * 10 0.0_rk C_ref = matmul ( transpose ( A ), B ) C = matmul ( A , B , transA = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.1' ) C = matmul ( A , B , option = 'm1' , transA = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.2' ) C = matmul ( A , B , option = 'm2' , transA = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.3' ) C = matmul ( A , B , option = 'm3' , transA = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.4' ) C = matmul ( A , B , option = 'm4' , transA = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.5' ) C = matmul ( A , B , option = 'm5' , transA = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.6' ) C = matmul ( A , B , option = 'm6' , transA = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.7' ) C = matmul ( A , B , option = 'm7' , transA = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.8' ) C = matmul ( A , B , option = 'm8' , transA = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.9' ) C = matmul ( A , B , option = 'm9' , transA = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.10' ) ! C = matmul(A,B, option='m10', transA=.true.) ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul4.11') ! C = matmul(A,B, option='m11', transA=.true.) ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul4.12') C = matmul ( A , B , option = 'm12' , transA = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.13' ) C = matmul ( A , B , option = 'm13' , transA = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.14' ) C = matmul ( A , B , transA = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.15' ) C = matmul ( A , B , option = 'm1' , transA = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.16' ) C = matmul ( A , B , option = 'm2' , transA = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.17' ) C = matmul ( A , B , option = 'm3' , transA = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.18' ) C = matmul ( A , B , option = 'm4' , transA = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.19' ) C = matmul ( A , B , option = 'm5' , transA = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.20' ) C = matmul ( A , B , option = 'm6' , transA = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.21' ) C = matmul ( A , B , option = 'm7' , transA = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.22' ) C = matmul ( A , B , option = 'm8' , transA = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.23' ) C = matmul ( A , B , option = 'm9' , transA = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.24' ) ! C = matmul(A,B, option='m10', transA=.true., nblock=4) ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul4.25') ! C = matmul(A,B, option='m11', transA=.true., nblock=4) ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul4.26') C = matmul ( A , B , option = 'm12' , transA = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.27' ) C = matmul ( A , B , option = 'm13' , transA = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.28' ) C = matmul ( A , B , transA = . true ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.29' ) C = matmul ( A , B , option = 'm1' , transA = . true ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.30' ) C = matmul ( A , B , option = 'm2' , transA = . true ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.31' ) C = matmul ( A , B , option = 'm3' , transA = . true ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.32' ) C = matmul ( A , B , option = 'm4' , transA = . true ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.33' ) C = matmul ( A , B , option = 'm5' , transA = . true ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.34' ) C = matmul ( A , B , option = 'm6' , transA = . true ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.35' ) C = matmul ( A , B , option = 'm7' , transA = . true ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.36' ) C = matmul ( A , B , option = 'm8' , transA = . true ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.37' ) C = matmul ( A , B , option = 'm9' , transA = . true ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.38' ) ! C = matmul(A,B, option='m10', transA=.true., transB=.false.) ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul4.39') ! C = matmul(A,B, option='m11', transA=.true., transB=.false.) ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul4.40') C = matmul ( A , B , option = 'm12' , transA = . true ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.41' ) C = matmul ( A , B , option = 'm13' , transA = . true ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.42' ) C = matmul ( A , B , transA = . true ., transB = . false ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.43' ) C = matmul ( A , B , option = 'm1' , transA = . true ., transB = . false ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.44' ) C = matmul ( A , B , option = 'm2' , transA = . true ., transB = . false ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.45' ) C = matmul ( A , B , option = 'm3' , transA = . true ., transB = . false ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.46' ) C = matmul ( A , B , option = 'm4' , transA = . true ., transB = . false ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.47' ) C = matmul ( A , B , option = 'm5' , transA = . true ., transB = . false ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.48' ) C = matmul ( A , B , option = 'm6' , transA = . true ., transB = . false ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.49' ) C = matmul ( A , B , option = 'm7' , transA = . true ., transB = . false ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.50' ) C = matmul ( A , B , option = 'm8' , transA = . true ., transB = . false ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.51' ) C = matmul ( A , B , option = 'm9' , transA = . true ., transB = . false ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.52' ) ! C = matmul(A,B, option='m10', transA=.true., transB=.false., nblock=4) ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul4.53') ! C = matmul(A,B, option='m11', transA=.true., transB=.false., nblock=4) ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul4.54') C = matmul ( A , B , option = 'm12' , transA = . true ., transB = . false ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.55' ) C = matmul ( A , B , option = 'm13' , transA = . true ., transB = . false ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.56' ) end program test_matmul4","tags":"","loc":"program/test_matmul4.html"},{"title":"test1.f90 – ForMatmul","text":"This file depends on sourcefile~~test1.f90~~EfferentGraph sourcefile~test1.f90 test1.f90 sourcefile~formatmul.f90 formatmul.f90 sourcefile~test1.f90->sourcefile~formatmul.f90 sourcefile~formatmul_opts.f90 formatmul_opts.f90 sourcefile~formatmul.f90->sourcefile~formatmul_opts.f90 sourcefile~external_interfaces.f90 external_interfaces.f90 sourcefile~formatmul_opts.f90->sourcefile~external_interfaces.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program test_matmul3 use kinds use formatmul use forunittest implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C_ref (:,:), C (:,:) integer :: m , n , o type ( unit_test ) :: ut ! C(m,o) = A(m,n).B(n,o) m = 300 n = 200 o = 100 allocate ( A ( m , n ), B ( n , o )) call random_number ( A ) call random_number ( B ) A = A * 10 0.0_rk B = B * 10 0.0_rk C_ref = matmul ( A , B ) C = matmul ( A , B ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.1' ) C = matmul ( A , B , option = 'm1' ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.2' ) C = matmul ( A , B , option = 'm2' ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.3' ) C = matmul ( A , B , option = 'm3' ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.4' ) C = matmul ( A , B , option = 'm4' ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.5' ) C = matmul ( A , B , option = 'm5' ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.6' ) C = matmul ( A , B , option = 'm6' ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.7' ) C = matmul ( A , B , option = 'm7' ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.8' ) C = matmul ( A , B , option = 'm8' ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.9' ) C = matmul ( A , B , option = 'm9' ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.10' ) ! C = matmul(A,B, option='m10') ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul3.11') ! C = matmul(A,B, option='m11') ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul3.12') C = matmul ( A , B , option = 'm12' ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.13' ) C = matmul ( A , B , option = 'm13' ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.14' ) C = matmul ( A , B , nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.15' ) C = matmul ( A , B , option = 'm1' , nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.16' ) C = matmul ( A , B , option = 'm2' , nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.17' ) C = matmul ( A , B , option = 'm3' , nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.18' ) C = matmul ( A , B , option = 'm4' , nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.19' ) C = matmul ( A , B , option = 'm5' , nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.20' ) C = matmul ( A , B , option = 'm6' , nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.21' ) C = matmul ( A , B , option = 'm7' , nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.22' ) C = matmul ( A , B , option = 'm8' , nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.23' ) C = matmul ( A , B , option = 'm9' , nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.24' ) ! C = matmul(A,B, option='m10', nblock=4) ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul3.25') ! C = matmul(A,B, option='m11', nblock=4) ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul3.26') C = matmul ( A , B , option = 'm12' , nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.27' ) C = matmul ( A , B , option = 'm13' , nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.28' ) C = matmul ( A , B , option = 'm1' , transA = . false ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.29' ) C = matmul ( A , B , option = 'm2' , transA = . false ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.30' ) C = matmul ( A , B , option = 'm3' , transA = . false ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.31' ) C = matmul ( A , B , option = 'm4' , transA = . false ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.32' ) C = matmul ( A , B , option = 'm5' , transA = . false ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.33' ) C = matmul ( A , B , option = 'm6' , transA = . false ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.34' ) C = matmul ( A , B , option = 'm7' , transA = . false ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.35' ) C = matmul ( A , B , option = 'm8' , transA = . false ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.36' ) C = matmul ( A , B , option = 'm9' , transA = . false ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.37' ) ! C = matmul(A,B, option='m10', transA=.false., transB=.false.) ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul3.38') ! C = matmul(A,B, option='m11', transA=.false., transB=.false.) ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul3.39') C = matmul ( A , B , option = 'm12' , transA = . false ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.40' ) C = matmul ( A , B , option = 'm13' , transA = . false ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.41' ) C = matmul ( A , B , nblock = 4 , transA = . false ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.42' ) C = matmul ( A , B , option = 'm1' , nblock = 4 , transA = . false ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.43' ) C = matmul ( A , B , option = 'm2' , nblock = 4 , transA = . false ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.44' ) C = matmul ( A , B , option = 'm3' , nblock = 4 , transA = . false ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.45' ) C = matmul ( A , B , option = 'm4' , nblock = 4 , transA = . false ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.46' ) C = matmul ( A , B , option = 'm5' , nblock = 4 , transA = . false ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.47' ) C = matmul ( A , B , option = 'm6' , nblock = 4 , transA = . false ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.48' ) C = matmul ( A , B , option = 'm7' , nblock = 4 , transA = . false ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.49' ) C = matmul ( A , B , option = 'm8' , nblock = 4 , transA = . false ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.50' ) C = matmul ( A , B , option = 'm9' , nblock = 4 , transA = . false ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.51' ) ! C = matmul(A,B, option='m10', nblock=4, transA=.false., transB=.false.) ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul3.52') ! C = matmul(A,B, option='m11', nblock=4, transA=.false., transB=.false.) ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul3.53') C = matmul ( A , B , option = 'm12' , nblock = 4 , transA = . false ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.54' ) C = matmul ( A , B , option = 'm13' , nblock = 4 , transA = . false ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul3.55' ) end program test_matmul3","tags":"","loc":"sourcefile/test1.f90.html"},{"title":"test4.f90 – ForMatmul","text":"This file depends on sourcefile~~test4.f90~~EfferentGraph sourcefile~test4.f90 test4.f90 sourcefile~formatmul.f90 formatmul.f90 sourcefile~test4.f90->sourcefile~formatmul.f90 sourcefile~formatmul_opts.f90 formatmul_opts.f90 sourcefile~formatmul.f90->sourcefile~formatmul_opts.f90 sourcefile~external_interfaces.f90 external_interfaces.f90 sourcefile~formatmul_opts.f90->sourcefile~external_interfaces.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program test_matmul6 use kinds use formatmul use forunittest implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C_ref (:,:), C (:,:) integer :: m , n , o type ( unit_test ) :: ut ! C(m,o) = A(n,m).B(o,n) m = 300 n = 200 o = 100 allocate ( A ( n , m ), B ( o , n )) call random_number ( A ) call random_number ( B ) A = A * 10 0.0_rk B = B * 10 0.0_rk C_ref = matmul ( transpose ( A ), transpose ( B )) C = matmul ( A , B , transA = . true ., transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul6.1' ) C = matmul ( A , B , option = 'm1' , transA = . true ., transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul6.2' ) C = matmul ( A , B , option = 'm2' , transA = . true ., transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul6.3' ) C = matmul ( A , B , option = 'm3' , transA = . true ., transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul6.4' ) C = matmul ( A , B , option = 'm4' , transA = . true ., transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul6.5' ) C = matmul ( A , B , option = 'm5' , transA = . true ., transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul6.6' ) C = matmul ( A , B , option = 'm6' , transA = . true ., transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul6.7' ) C = matmul ( A , B , option = 'm7' , transA = . true ., transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul6.8' ) C = matmul ( A , B , option = 'm8' , transA = . true ., transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul6.9' ) C = matmul ( A , B , option = 'm9' , transA = . true ., transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul6.10' ) ! C = matmul(A,B, option='m10', transA=.true., transB=.true.) ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul6.11') ! C = matmul(A,B, option='m11', transA=.true., transB=.true.) ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul6.12') C = matmul ( A , B , option = 'm12' , transA = . true ., transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul6.13' ) C = matmul ( A , B , option = 'm13' , transA = . true ., transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul6.14' ) C = matmul ( A , B , transA = . true ., transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul6.15' ) C = matmul ( A , B , option = 'm1' , transA = . true ., transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul6.16' ) C = matmul ( A , B , option = 'm2' , transA = . true ., transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul6.17' ) C = matmul ( A , B , option = 'm3' , transA = . true ., transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul6.18' ) C = matmul ( A , B , option = 'm4' , transA = . true ., transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul6.19' ) C = matmul ( A , B , option = 'm5' , transA = . true ., transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul6.20' ) C = matmul ( A , B , option = 'm6' , transA = . true ., transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul6.21' ) C = matmul ( A , B , option = 'm7' , transA = . true ., transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul6.22' ) C = matmul ( A , B , option = 'm8' , transA = . true ., transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul6.23' ) C = matmul ( A , B , option = 'm9' , transA = . true ., transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul6.24' ) ! C = matmul(A,B, option='m10', transA=.true., transB=.true., nblock=4) ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul6.25') ! C = matmul(A,B, option='m11', transA=.true., transB=.true., nblock=4) ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul6.26') C = matmul ( A , B , option = 'm12' , transA = . true ., transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul6.27' ) C = matmul ( A , B , option = 'm13' , transA = . true ., transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul6.28' ) end program test_matmul6","tags":"","loc":"sourcefile/test4.f90.html"},{"title":"test12.f90 – ForMatmul","text":"This file depends on sourcefile~~test12.f90~~EfferentGraph sourcefile~test12.f90 test12.f90 sourcefile~formatmul.f90 formatmul.f90 sourcefile~test12.f90->sourcefile~formatmul.f90 sourcefile~formatmul_opts.f90 formatmul_opts.f90 sourcefile~formatmul.f90->sourcefile~formatmul_opts.f90 sourcefile~external_interfaces.f90 external_interfaces.f90 sourcefile~formatmul_opts.f90->sourcefile~external_interfaces.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program test_matmul14 use kinds use formatmul use forunittest implicit none real ( rk ), allocatable :: A (:,:), v (:) real ( rk ), allocatable :: w_ref (:), w (:) integer :: m , n , im type ( unit_test ) :: ut #if defined(USE_COARRAY) im = this_image () #else im = 1 #endif ! w(m) = A(m,n).v(n) m = 500 n = 300 allocate ( A ( m , n ), v ( n )) call random_number ( A ) call random_number ( v ) A = A * 10 0.0_rk v = v * 10 0.0_rk w_ref = matmul ( A , v ) w = matmul ( A , v , coarray = . true .) if ( im == 1 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul14.1' ) w = matmul ( A , v , option = 'm1' , coarray = . true .) if ( im == 1 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul14.2' ) w = matmul ( A , v , option = 'm2' , coarray = . true .) if ( im == 1 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul14.3' ) w = matmul ( A , v , option = 'm3' , coarray = . true .) if ( im == 1 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul14.4' ) w = matmul ( A , v , option = 'm4' , coarray = . true .) if ( im == 1 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul14.5' ) w = matmul ( A , v , option = 'm5' , coarray = . true .) if ( im == 1 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul14.6' ) w = matmul ( A , v , option = 'm6' , coarray = . true .) if ( im == 1 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul14.7' ) ! w = matmul(A,v, option='m7', coarray=.true.) ! if (im==1) call ut%check(w, w_ref, tol=1e-5_rk, msg='test_matmul14.8') ! w = matmul(A,v, option='m8', coarray=.true.) ! if (im==1) call ut%check(w, w_ref, tol=1e-5_rk, msg='test_matmul14.9') end program test_matmul14","tags":"","loc":"sourcefile/test12.f90.html"},{"title":"external_interfaces.f90 – ForMatmul","text":"Files dependent on this one sourcefile~~external_interfaces.f90~~AfferentGraph sourcefile~external_interfaces.f90 external_interfaces.f90 sourcefile~formatmul_opts.f90 formatmul_opts.f90 sourcefile~formatmul_opts.f90->sourcefile~external_interfaces.f90 sourcefile~formatmul.f90 formatmul.f90 sourcefile~formatmul.f90->sourcefile~formatmul_opts.f90 sourcefile~test1.f90 test1.f90 sourcefile~test1.f90->sourcefile~formatmul.f90 sourcefile~test10.f90 test10.f90 sourcefile~test10.f90->sourcefile~formatmul.f90 sourcefile~test11.f90 test11.f90 sourcefile~test11.f90->sourcefile~formatmul.f90 sourcefile~test12.f90 test12.f90 sourcefile~test12.f90->sourcefile~formatmul.f90 sourcefile~test13.f90 test13.f90 sourcefile~test13.f90->sourcefile~formatmul.f90 sourcefile~test2.f90 test2.f90 sourcefile~test2.f90->sourcefile~formatmul.f90 sourcefile~test3.f90 test3.f90 sourcefile~test3.f90->sourcefile~formatmul.f90 sourcefile~test4.f90 test4.f90 sourcefile~test4.f90->sourcefile~formatmul.f90 sourcefile~test5.f90 test5.f90 sourcefile~test5.f90->sourcefile~formatmul.f90 sourcefile~test6.f90 test6.f90 sourcefile~test6.f90->sourcefile~formatmul.f90 sourcefile~test7.f90 test7.f90 sourcefile~test7.f90->sourcefile~formatmul.f90 sourcefile~test8.f90 test8.f90 sourcefile~test8.f90->sourcefile~formatmul.f90 sourcefile~test9.f90 test9.f90 sourcefile~test9.f90->sourcefile~formatmul.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module external_interfaces_matmul use kinds implicit none interface gemm #if defined(REAL64) pure subroutine dgemm ( f_transa , f_transb , f_m , f_n , f_k , f_alpha , f_a , f_lda , f_b , f_ldb , f_beta , f_c , f_ldc ) import rk integer , intent ( in ) :: f_ldc integer , intent ( in ) :: f_ldb integer , intent ( in ) :: f_lda character , intent ( in ) :: f_transa character , intent ( in ) :: f_transb integer , intent ( in ) :: f_m integer , intent ( in ) :: f_n integer , intent ( in ) :: f_k real ( rk ), intent ( in ) :: f_alpha real ( rk ), intent ( in ) :: f_a ( f_lda , * ) real ( rk ), intent ( in ) :: f_b ( f_ldb , * ) real ( rk ), intent ( in ) :: f_beta real ( rk ), intent ( inout ) :: f_c ( f_ldc , * ) end subroutine dgemm #elif defined(REAL32) pure subroutine sgemm ( f_transa , f_transb , f_m , f_n , f_k , f_alpha , f_a , f_lda , f_b , f_ldb , f_beta , f_c , f_ldc ) import rk integer , intent ( in ) :: f_ldc integer , intent ( in ) :: f_ldb integer , intent ( in ) :: f_lda character , intent ( in ) :: f_transa character , intent ( in ) :: f_transb integer , intent ( in ) :: f_m integer , intent ( in ) :: f_n integer , intent ( in ) :: f_k real ( rk ), intent ( in ) :: f_alpha real ( rk ), intent ( in ) :: f_a ( f_lda , * ) real ( rk ), intent ( in ) :: f_b ( f_ldb , * ) real ( rk ), intent ( in ) :: f_beta real ( rk ), intent ( inout ) :: f_c ( f_ldc , * ) end subroutine sgemm #else pure subroutine dgemm ( f_transa , f_transb , f_m , f_n , f_k , f_alpha , f_a , f_lda , f_b , f_ldb , f_beta , f_c , f_ldc ) import rk integer , intent ( in ) :: f_ldc integer , intent ( in ) :: f_ldb integer , intent ( in ) :: f_lda character , intent ( in ) :: f_transa character , intent ( in ) :: f_transb integer , intent ( in ) :: f_m integer , intent ( in ) :: f_n integer , intent ( in ) :: f_k real ( rk ), intent ( in ) :: f_alpha real ( rk ), intent ( in ) :: f_a ( f_lda , * ) real ( rk ), intent ( in ) :: f_b ( f_ldb , * ) real ( rk ), intent ( in ) :: f_beta real ( rk ), intent ( inout ) :: f_c ( f_ldc , * ) end subroutine dgemm #endif end interface interface gemv #if defined(REAL64) pure subroutine dgemv ( f_trans , f_m , f_n , f_alpha , f_a , f_lda , f_x , f_incx , f_beta , f_y , f_incy ) import rk integer , intent ( in ) :: f_m integer , intent ( in ) :: f_n integer , intent ( in ) :: f_lda character , intent ( in ) :: f_trans real ( rk ), intent ( in ) :: f_alpha real ( rk ), intent ( in ) :: f_a ( f_lda , * ) real ( rk ), intent ( in ) :: f_x ( * ) integer , intent ( in ) :: f_incx real ( rk ), intent ( in ) :: f_beta real ( rk ), intent ( inout ) :: f_y ( * ) integer , intent ( in ) :: f_incy end subroutine dgemv #elif defined(REAL32) pure subroutine sgemv ( f_trans , f_m , f_n , f_alpha , f_a , f_lda , f_x , f_incx , f_beta , f_y , f_incy ) import rk integer , intent ( in ) :: f_m integer , intent ( in ) :: f_n integer , intent ( in ) :: f_lda character , intent ( in ) :: f_trans real ( rk ), intent ( in ) :: f_alpha real ( rk ), intent ( in ) :: f_a ( f_lda , * ) real ( rk ), intent ( in ) :: f_x ( * ) integer , intent ( in ) :: f_incx real ( rk ), intent ( in ) :: f_beta real ( rk ), intent ( inout ) :: f_y ( * ) integer , intent ( in ) :: f_incy end subroutine sgemv #else pure subroutine dgemv ( f_trans , f_m , f_n , f_alpha , f_a , f_lda , f_x , f_incx , f_beta , f_y , f_incy ) import rk integer , intent ( in ) :: f_m integer , intent ( in ) :: f_n integer , intent ( in ) :: f_lda character , intent ( in ) :: f_trans real ( rk ), intent ( in ) :: f_alpha real ( rk ), intent ( in ) :: f_a ( f_lda , * ) real ( rk ), intent ( in ) :: f_x ( * ) integer , intent ( in ) :: f_incx real ( rk ), intent ( in ) :: f_beta real ( rk ), intent ( inout ) :: f_y ( * ) integer , intent ( in ) :: f_incy end subroutine dgemv #endif end interface end module external_interfaces_matmul","tags":"","loc":"sourcefile/external_interfaces.f90.html"},{"title":"test11.f90 – ForMatmul","text":"This file depends on sourcefile~~test11.f90~~EfferentGraph sourcefile~test11.f90 test11.f90 sourcefile~formatmul.f90 formatmul.f90 sourcefile~test11.f90->sourcefile~formatmul.f90 sourcefile~formatmul_opts.f90 formatmul_opts.f90 sourcefile~formatmul.f90->sourcefile~formatmul_opts.f90 sourcefile~external_interfaces.f90 external_interfaces.f90 sourcefile~formatmul_opts.f90->sourcefile~external_interfaces.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program test_matmul13 use kinds use formatmul use forunittest implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C_ref (:,:), C (:,:) integer :: m , n , o , im type ( unit_test ) :: ut #if defined(USE_COARRAY) im = this_image () #else im = 1 #endif ! C(m,o) = A(n,m).B(o,n) m = 500 n = 400 o = 300 allocate ( A ( n , m ), B ( o , n )) call random_number ( A ) call random_number ( B ) A = A * 10 0.0_rk B = B * 10 0.0_rk C_ref = matmul ( transpose ( A ), transpose ( B )) C = matmul ( A , B , transA = . true ., transB = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul13.1' ) C = matmul ( A , B , option = 'm1' , transA = . true ., transB = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul13.2' ) C = matmul ( A , B , option = 'm2' , transA = . true ., transB = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul13.3' ) C = matmul ( A , B , option = 'm3' , transA = . true ., transB = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul13.4' ) C = matmul ( A , B , option = 'm4' , transA = . true ., transB = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul13.5' ) C = matmul ( A , B , option = 'm5' , transA = . true ., transB = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul13.6' ) C = matmul ( A , B , option = 'm6' , transA = . true ., transB = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul13.7' ) C = matmul ( A , B , option = 'm7' , transA = . true ., transB = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul13.8' ) C = matmul ( A , B , option = 'm8' , transA = . true ., transB = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul13.9' ) C = matmul ( A , B , option = 'm9' , transA = . true ., transB = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul13.10' ) ! C = matmul(A,B, option='m10', transA=.true., transB=.true., coarray=.true.) ! if (im==1) call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul13.11') ! C = matmul(A,B, option='m11', transA=.true., transB=.true., coarray=.true.) ! if (im==1) call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul13.12') C = matmul ( A , B , option = 'm12' , transA = . true ., transB = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul13.13' ) C = matmul ( A , B , option = 'm13' , transA = . true ., transB = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul13.14' ) end program test_matmul13","tags":"","loc":"sourcefile/test11.f90.html"},{"title":"test9.f90 – ForMatmul","text":"This file depends on sourcefile~~test9.f90~~EfferentGraph sourcefile~test9.f90 test9.f90 sourcefile~formatmul.f90 formatmul.f90 sourcefile~test9.f90->sourcefile~formatmul.f90 sourcefile~formatmul_opts.f90 formatmul_opts.f90 sourcefile~formatmul.f90->sourcefile~formatmul_opts.f90 sourcefile~external_interfaces.f90 external_interfaces.f90 sourcefile~formatmul_opts.f90->sourcefile~external_interfaces.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program test_matmul11 use kinds use formatmul use forunittest implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C_ref (:,:), C (:,:) integer :: m , n , o , im type ( unit_test ) :: ut #if defined(USE_COARRAY) im = this_image () #else im = 1 #endif ! C(m,o) = A(n,m).B(n,o) m = 500 n = 400 o = 300 allocate ( A ( n , m ), B ( n , o )) call random_number ( A ) call random_number ( B ) A = A * 10 0.0_rk B = B * 10 0.0_rk C_ref = matmul ( transpose ( A ), B ) C = matmul ( A , B , transA = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul11.1' ) C = matmul ( A , B , option = 'm1' , transA = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul11.2' ) C = matmul ( A , B , option = 'm2' , transA = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul11.3' ) C = matmul ( A , B , option = 'm3' , transA = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul11.4' ) C = matmul ( A , B , option = 'm4' , transA = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul11.5' ) C = matmul ( A , B , option = 'm5' , transA = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul11.6' ) C = matmul ( A , B , option = 'm6' , transA = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul11.7' ) C = matmul ( A , B , option = 'm7' , transA = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul11.8' ) C = matmul ( A , B , option = 'm8' , transA = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul11.9' ) C = matmul ( A , B , option = 'm9' , transA = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul11.10' ) ! C = matmul(A,B, option='m10', transA=.true., coarray=.true.) ! if (im==1) call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul11.11') ! C = matmul(A,B, option='m11', transA=.true., coarray=.true.) ! if (im==1) call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul11.12') C = matmul ( A , B , option = 'm12' , transA = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul11.13' ) C = matmul ( A , B , option = 'm13' , transA = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul11.14' ) end program test_matmul11","tags":"","loc":"sourcefile/test9.f90.html"},{"title":"test8.f90 – ForMatmul","text":"This file depends on sourcefile~~test8.f90~~EfferentGraph sourcefile~test8.f90 test8.f90 sourcefile~formatmul.f90 formatmul.f90 sourcefile~test8.f90->sourcefile~formatmul.f90 sourcefile~formatmul_opts.f90 formatmul_opts.f90 sourcefile~formatmul.f90->sourcefile~formatmul_opts.f90 sourcefile~external_interfaces.f90 external_interfaces.f90 sourcefile~formatmul_opts.f90->sourcefile~external_interfaces.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program test_matmul10 use kinds use formatmul use forunittest implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C_ref (:,:), C (:,:) integer :: m , n , o , im type ( unit_test ) :: ut #if defined(USE_COARRAY) im = this_image () #else im = 1 #endif ! C(m,o) = A(m,n).B(n,o) m = 500 n = 400 o = 300 allocate ( A ( m , n ), B ( n , o )) call random_number ( A ) call random_number ( B ) A = A * 10 0.0_rk B = B * 10 0.0_rk C_ref = matmul ( A , B ) C = matmul ( A , B , coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul10.1' ) C = matmul ( A , B , option = 'm1' , coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul10.2' ) C = matmul ( A , B , option = 'm2' , coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul10.3' ) C = matmul ( A , B , option = 'm3' , coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul10.4' ) C = matmul ( A , B , option = 'm4' , coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul10.5' ) C = matmul ( A , B , option = 'm5' , coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul10.6' ) C = matmul ( A , B , option = 'm6' , coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul10.7' ) C = matmul ( A , B , option = 'm7' , coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul10.8' ) C = matmul ( A , B , option = 'm8' , coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul10.9' ) C = matmul ( A , B , option = 'm9' , coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul10.10' ) !    C = matmul(A,B, option='m10', coarray=.true.) !    if (im==1) call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul10.11') !    C = matmul(A,B, option='m11', coarray=.true.) !    if (im==1) call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul10.12') C = matmul ( A , B , option = 'm12' , coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul10.13' ) C = matmul ( A , B , option = 'm13' , coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul10.14' ) end program test_matmul10","tags":"","loc":"sourcefile/test8.f90.html"},{"title":"formatmul_opts.f90 – ForMatmul","text":"This file depends on sourcefile~~formatmul_opts.f90~~EfferentGraph sourcefile~formatmul_opts.f90 formatmul_opts.f90 sourcefile~external_interfaces.f90 external_interfaces.f90 sourcefile~formatmul_opts.f90->sourcefile~external_interfaces.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~formatmul_opts.f90~~AfferentGraph sourcefile~formatmul_opts.f90 formatmul_opts.f90 sourcefile~formatmul.f90 formatmul.f90 sourcefile~formatmul.f90->sourcefile~formatmul_opts.f90 sourcefile~test1.f90 test1.f90 sourcefile~test1.f90->sourcefile~formatmul.f90 sourcefile~test10.f90 test10.f90 sourcefile~test10.f90->sourcefile~formatmul.f90 sourcefile~test11.f90 test11.f90 sourcefile~test11.f90->sourcefile~formatmul.f90 sourcefile~test12.f90 test12.f90 sourcefile~test12.f90->sourcefile~formatmul.f90 sourcefile~test13.f90 test13.f90 sourcefile~test13.f90->sourcefile~formatmul.f90 sourcefile~test2.f90 test2.f90 sourcefile~test2.f90->sourcefile~formatmul.f90 sourcefile~test3.f90 test3.f90 sourcefile~test3.f90->sourcefile~formatmul.f90 sourcefile~test4.f90 test4.f90 sourcefile~test4.f90->sourcefile~formatmul.f90 sourcefile~test5.f90 test5.f90 sourcefile~test5.f90->sourcefile~formatmul.f90 sourcefile~test6.f90 test6.f90 sourcefile~test6.f90->sourcefile~formatmul.f90 sourcefile~test7.f90 test7.f90 sourcefile~test7.f90->sourcefile~formatmul.f90 sourcefile~test8.f90 test8.f90 sourcefile~test8.f90->sourcefile~formatmul.f90 sourcefile~test9.f90 test9.f90 sourcefile~test9.f90->sourcefile~formatmul.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module formatmul_opts use kinds implicit none private public & mat_mat_rel_AB_opt , & mat_mat_rel_ATB_opt , & mat_mat_rel_ABT_opt , & mat_mat_rel_ATBT_opt , & mat_vec_rel_Av_opt , & mat_vec_rel_Atv_opt contains !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mat_mat_rel_AB_opt ( A , B , C , option ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) character ( * ), intent ( in ) :: option select case ( option ) case ( 'm1' ) call mm_AB_1 ( A , B , C ) case ( 'm2' ) call mm_AB_2 ( A , B , C ) case ( 'm3' ) call mm_AB_3 ( A , B , C ) case ( 'm4' ) call mm_AB_4 ( A , B , C ) case ( 'm5' ) call mm_AB_5 ( A , B , C ) case ( 'm6' ) call mm_AB_6 ( A , B , C ) case ( 'm7' ) call mm_AB_7 ( A , B , C ) case ( 'm8' ) call mm_AB_8 ( A , B , C ) case ( 'm9' ) call mm_AB_9 ( A , B , C ) case ( 'm10' ) call mm_AB_10 ( A , B , C ) case ( 'm11' ) call mm_AB_11 ( A , B , C ) case ( 'm12' ) call mm_AB_12 ( A , B , C ) case ( 'm13' ) call mm_AB_13 ( A , B , C ) end select end subroutine mat_mat_rel_AB_opt !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mat_mat_rel_ATB_opt ( A , B , C , option ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) character ( * ), intent ( in ) :: option select case ( option ) case ( 'm1' ) call mm_ATB_1 ( A , B , C ) case ( 'm2' ) call mm_ATB_2 ( A , B , C ) case ( 'm3' ) call mm_ATB_3 ( A , B , C ) case ( 'm4' ) call mm_ATB_4 ( A , B , C ) case ( 'm5' ) call mm_ATB_5 ( A , B , C ) case ( 'm6' ) call mm_ATB_6 ( A , B , C ) case ( 'm7' ) call mm_ATB_7 ( A , B , C ) case ( 'm8' ) call mm_ATB_8 ( A , B , C ) case ( 'm9' ) call mm_ATB_9 ( A , B , C ) case ( 'm10' ) call mm_ATB_10 ( A , B , C ) case ( 'm11' ) call mm_ATB_11 ( A , B , C ) case ( 'm12' ) call mm_ATB_12 ( A , B , C ) case ( 'm13' ) call mm_ATB_13 ( A , B , C ) end select end subroutine mat_mat_rel_ATB_opt !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mat_mat_rel_ABT_opt ( A , B , C , option ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) character ( * ), intent ( in ) :: option select case ( option ) case ( 'm1' ) call mm_ABT_1 ( A , B , C ) case ( 'm2' ) call mm_ABT_2 ( A , B , C ) case ( 'm3' ) call mm_ABT_3 ( A , B , C ) case ( 'm4' ) call mm_ABT_4 ( A , B , C ) case ( 'm5' ) call mm_ABT_5 ( A , B , C ) case ( 'm6' ) call mm_ABT_6 ( A , B , C ) case ( 'm7' ) call mm_ABT_7 ( A , B , C ) case ( 'm8' ) call mm_ABT_8 ( A , B , C ) case ( 'm9' ) call mm_ABT_9 ( A , B , C ) case ( 'm10' ) call mm_ABT_10 ( A , B , C ) case ( 'm11' ) call mm_ABT_11 ( A , B , C ) case ( 'm12' ) call mm_ABT_12 ( A , B , C ) case ( 'm13' ) call mm_ABT_13 ( A , B , C ) end select end subroutine mat_mat_rel_ABT_opt !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mat_mat_rel_ATBT_opt ( A , B , C , option ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) character ( * ), intent ( in ) :: option select case ( option ) case ( 'm1' ) call mm_ATBT_1 ( A , B , C ) case ( 'm2' ) call mm_ATBT_2 ( A , B , C ) case ( 'm3' ) call mm_ATBT_3 ( A , B , C ) case ( 'm4' ) call mm_ATBT_4 ( A , B , C ) case ( 'm5' ) call mm_ATBT_5 ( A , B , C ) case ( 'm6' ) call mm_ATBT_6 ( A , B , C ) case ( 'm7' ) call mm_ATBT_7 ( A , B , C ) case ( 'm8' ) call mm_ATBT_8 ( A , B , C ) case ( 'm9' ) call mm_ATBT_9 ( A , B , C ) case ( 'm10' ) call mm_ATBT_10 ( A , B , C ) case ( 'm11' ) call mm_ATBT_11 ( A , B , C ) case ( 'm12' ) call mm_ATBT_12 ( A , B , C ) case ( 'm13' ) call mm_ATBT_13 ( A , B , C ) end select end subroutine mat_mat_rel_ATBT_opt !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mat_vec_rel_Av_opt ( A , v , w , option ) real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) real ( rk ), intent ( inout ), contiguous :: w (:) character ( * ), intent ( in ) :: option select case ( option ) case ( 'm1' ) call mv_Av_1 ( A , v , w ) case ( 'm2' ) call mv_Av_2 ( A , v , w ) case ( 'm3' ) call mv_Av_3 ( A , v , w ) case ( 'm4' ) call mv_Av_4 ( A , v , w ) case ( 'm5' ) call mv_Av_5 ( A , v , w ) case ( 'm6' ) call mv_Av_6 ( A , v , w ) case ( 'm7' ) call mv_Av_7 ( A , v , w ) case ( 'm8' ) call mv_Av_8 ( A , v , w ) end select end subroutine mat_vec_rel_Av_opt !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mat_vec_rel_ATv_opt ( A , v , w , option ) real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) real ( rk ), intent ( inout ), contiguous :: w (:) character ( * ), intent ( in ) :: option select case ( option ) case ( 'm1' ) call mv_ATv_1 ( A , v , w ) case ( 'm2' ) call mv_ATv_2 ( A , v , w ) case ( 'm3' ) call mv_ATv_3 ( A , v , w ) case ( 'm4' ) call mv_ATv_4 ( A , v , w ) case ( 'm5' ) call mv_ATv_5 ( A , v , w ) case ( 'm6' ) call mv_ATv_6 ( A , v , w ) case ( 'm7' ) call mv_ATv_7 ( A , v , w ) case ( 'm8' ) call mv_ATv_8 ( A , v , w ) end select end subroutine mat_vec_rel_ATv_opt !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mm_AB_1 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) C = matmul ( A , B ) end subroutine mm_AB_1 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mm_AB_2 ( A , B , C ) use external_interfaces_matmul real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n m = size ( A , 1 ) n = size ( A , 2 ) ! Call BLAS gemm subroutine for matrix-matrix multiplication. call gemm ( 'N' , 'N' , m , size ( B , 2 ), n , 1.0_rk , A , m , B , n , 0.0_rk , C , m ) end subroutine mm_AB_2 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mm_AB_3 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 1 ) n = size ( A , 2 ) p = size ( B , 2 ) do i = 1 , m do j = 1 , n do k = 1 , p c ( i , k ) = c ( i , k ) + a ( i , j ) * b ( j , k ) end do end do end do end subroutine mm_AB_3 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mm_AB_4 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 1 ) n = size ( A , 2 ) p = size ( B , 2 ) do i = 1 , m do j = 1 , p do k = 1 , n c ( i , j ) = c ( i , j ) + a ( i , k ) * b ( k , j ) end do end do end do end subroutine mm_AB_4 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mm_AB_5 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 1 ) n = size ( A , 2 ) p = size ( B , 2 ) do i = 1 , n do j = 1 , m do k = 1 , p c ( j , k ) = c ( j , k ) + a ( j , i ) * b ( i , k ) end do end do end do end subroutine mm_AB_5 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mm_AB_6 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 1 ) n = size ( A , 2 ) p = size ( B , 2 ) do i = 1 , n do j = 1 , p do k = 1 , m c ( k , j ) = c ( k , j ) + a ( k , i ) * b ( i , j ) end do end do end do end subroutine mm_AB_6 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mm_AB_7 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 1 ) n = size ( A , 2 ) p = size ( B , 2 ) do i = 1 , p do j = 1 , m do k = 1 , n c ( j , i ) = c ( j , i ) + a ( j , k ) * b ( k , i ) end do end do end do end subroutine mm_AB_7 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mm_AB_8 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 1 ) n = size ( A , 2 ) p = size ( B , 2 ) do i = 1 , p do j = 1 , n do k = 1 , m c ( k , i ) = c ( k , i ) + a ( k , j ) * b ( j , i ) end do end do end do end subroutine mm_AB_8 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mm_AB_9 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , p integer :: i , k m = size ( A , 1 ) p = size ( B , 2 ) do i = 1 , p do k = 1 , m c ( k , i ) = dot_product ( a ( k ,:), b (:, i )) end do end do end subroutine mm_AB_9 !=============================================================================== !=============================================================================== !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! GFORTRAN DOESNT SUPPORT SHARED ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> author: Seyed Ali Ghasemi pure subroutine mm_AB_10 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , p integer :: i , k m = size ( A , 1 ) p = size ( B , 2 ) error stop 'ForMatMul: shared is not supported in gfortran' !   do concurrent (i = 1: p) shared(m, p) ! check shared variables !     do k = 1, m !         c(k,i) = dot_product(a(k,:), b(:,i)) !     end do !   end do end subroutine mm_AB_10 !=============================================================================== !=============================================================================== !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! GFORTRAN DOESNT SUPPORT SHARED ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> author: Seyed Ali Ghasemi pure subroutine mm_AB_11 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 1 ) n = size ( A , 2 ) p = size ( B , 2 ) error stop 'ForMatMul: shared is not supported in gfortran' !    do concurrent (i = 1: p) shared(m, n, p) ! check shared variables !         do j=1,n !             do k=1,m !                 c(k,i) = c(k,i) + a(k,j)*b(j,i) !             end do !         end do !     end do end subroutine mm_AB_11 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mm_AB_12 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) interface pure subroutine impure_mm_AB_12 ( f_a , f_b , f_c ) import rk real ( rk ), intent ( in ) :: f_a (:,:), f_b (:,:) real ( rk ), intent ( inout ) :: f_c (:,:) end subroutine impure_mm_AB_12 end interface call impure_mm_AB_12 ( a , b , c ) end subroutine mm_AB_12 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mm_AB_13 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) interface pure subroutine impure_mm_AB_13 ( f_a , f_b , f_c ) import rk real ( rk ), intent ( in ) :: f_a (:,:), f_b (:,:) real ( rk ), intent ( inout ) :: f_c (:,:) end subroutine impure_mm_AB_13 end interface call impure_mm_AB_13 ( a , b , c ) end subroutine mm_AB_13 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mm_ATB_1 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) C = matmul ( transpose ( A ), B ) end subroutine mm_ATB_1 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mm_ATB_2 ( A , B , C ) use external_interfaces_matmul real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n m = size ( A , 2 ) n = size ( A , 1 ) ! Call BLAS gemm subroutine for matrix-matrix multiplication. call gemm ( 'T' , 'N' , m , size ( B , 2 ), n , 1.0_rk , A , n , B , n , 0.0_rk , C , m ) end subroutine mm_ATB_2 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mm_ATB_3 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 2 ) n = size ( A , 1 ) p = size ( B , 2 ) do i = 1 , m do j = 1 , n do k = 1 , p c ( i , k ) = c ( i , k ) + a ( j , i ) * b ( j , k ) end do end do end do end subroutine mm_ATB_3 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mm_ATB_4 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 2 ) n = size ( A , 1 ) p = size ( B , 2 ) do i = 1 , m do j = 1 , p do k = 1 , n c ( i , j ) = c ( i , j ) + a ( k , i ) * b ( k , j ) end do end do end do end subroutine mm_ATB_4 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mm_ATB_5 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 2 ) n = size ( A , 1 ) p = size ( B , 2 ) do i = 1 , n do j = 1 , m do k = 1 , p c ( j , k ) = c ( j , k ) + a ( i , j ) * b ( i , k ) end do end do end do end subroutine mm_ATB_5 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mm_ATB_6 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 2 ) n = size ( A , 1 ) p = size ( B , 2 ) do i = 1 , n do j = 1 , p do k = 1 , m c ( k , j ) = c ( k , j ) + a ( i , k ) * b ( i , j ) end do end do end do end subroutine mm_ATB_6 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mm_ATB_7 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 2 ) n = size ( A , 1 ) p = size ( B , 2 ) do i = 1 , p do j = 1 , m do k = 1 , n c ( j , i ) = c ( j , i ) + a ( k , j ) * b ( k , i ) end do end do end do end subroutine mm_ATB_7 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mm_ATB_8 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 2 ) n = size ( A , 1 ) p = size ( B , 2 ) do i = 1 , p do j = 1 , n do k = 1 , m c ( k , i ) = c ( k , i ) + a ( j , k ) * b ( j , i ) end do end do end do end subroutine mm_ATB_8 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mm_ATB_9 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , p integer :: i , k m = size ( A , 2 ) p = size ( B , 2 ) do i = 1 , p do k = 1 , m c ( k , i ) = dot_product ( a (:, k ), b (:, i )) end do end do end subroutine mm_ATB_9 !=============================================================================== !=============================================================================== !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! GFORTRAN DOESNT SUPPORT SHARED ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> author: Seyed Ali Ghasemi pure subroutine mm_ATB_10 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , p integer :: i , k m = size ( A , 2 ) p = size ( B , 2 ) error stop 'ForMatMul: shared is not supported in gfortran' !   do concurrent (i = 1: p) shared(m, p) ! check shared variables !     do k = 1, m !         c(k,i) = dot_product(a(:,k), b(:,i)) !     end do !   end do end subroutine mm_ATB_10 !=============================================================================== !=============================================================================== !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! GFORTRAN DOESNT SUPPORT SHARED ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> author: Seyed Ali Ghasemi pure subroutine mm_ATB_11 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 2 ) n = size ( A , 1 ) p = size ( B , 2 ) error stop 'ForMatMul: shared is not supported in gfortran' !    do concurrent (i = 1: p) shared(m, n, p) ! check shared variables !         do j=1,n !             do k=1,m !                 c(k,i) = c(k,i) + a(j,k)*b(j,i) !             end do !         end do !     end do end subroutine mm_ATB_11 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mm_ATB_12 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) interface pure subroutine impure_mm_ATB_12 ( f_a , f_b , f_c ) import rk real ( rk ), intent ( in ) :: f_a (:,:), f_b (:,:) real ( rk ), intent ( inout ) :: f_c (:,:) end subroutine impure_mm_ATB_12 end interface call impure_mm_ATB_12 ( a , b , c ) end subroutine mm_ATB_12 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mm_ATB_13 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) interface pure subroutine impure_mm_ATB_13 ( f_a , f_b , f_c ) import rk real ( rk ), intent ( in ) :: f_a (:,:), f_b (:,:) real ( rk ), intent ( inout ) :: f_c (:,:) end subroutine impure_mm_ATB_13 end interface call impure_mm_ATB_13 ( a , b , c ) end subroutine mm_ATB_13 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mm_ABT_1 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) C = matmul ( A , transpose ( B )) end subroutine mm_ABT_1 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mm_ABT_2 ( A , B , C ) use external_interfaces_matmul real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , p m = size ( A , 1 ) p = size ( B , 1 ) ! Call BLAS gemm subroutine for matrix-matrix multiplication. call gemm ( 'N' , 'T' , m , p , size ( A , 2 ), 1.0_rk , A , m , B , p , 0.0_rk , C , m ) end subroutine mm_ABT_2 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mm_ABT_3 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 1 ) n = size ( A , 2 ) p = size ( B , 1 ) do i = 1 , m do j = 1 , n do k = 1 , p c ( i , k ) = c ( i , k ) + a ( i , j ) * b ( k , j ) end do end do end do end subroutine mm_ABT_3 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mm_ABT_4 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 1 ) n = size ( A , 2 ) p = size ( B , 1 ) do i = 1 , m do j = 1 , p do k = 1 , n c ( i , j ) = c ( i , j ) + a ( i , k ) * b ( j , k ) end do end do end do end subroutine mm_ABT_4 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mm_ABT_5 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 1 ) n = size ( A , 2 ) p = size ( B , 1 ) do i = 1 , n do j = 1 , m do k = 1 , p c ( j , k ) = c ( j , k ) + a ( j , i ) * b ( k , i ) end do end do end do end subroutine mm_ABT_5 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mm_ABT_6 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 1 ) n = size ( A , 2 ) p = size ( B , 1 ) do i = 1 , n do j = 1 , p do k = 1 , m c ( k , j ) = c ( k , j ) + a ( k , i ) * b ( j , i ) end do end do end do end subroutine mm_ABT_6 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mm_ABT_7 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 1 ) n = size ( A , 2 ) p = size ( B , 1 ) do i = 1 , p do j = 1 , m do k = 1 , n c ( j , i ) = c ( j , i ) + a ( j , k ) * b ( i , k ) end do end do end do end subroutine mm_ABT_7 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mm_ABT_8 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 1 ) n = size ( A , 2 ) p = size ( B , 1 ) do i = 1 , p do j = 1 , n do k = 1 , m c ( k , i ) = c ( k , i ) + a ( k , j ) * b ( i , j ) end do end do end do end subroutine mm_ABT_8 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mm_ABT_9 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , p integer :: i , k m = size ( A , 1 ) p = size ( B , 1 ) do i = 1 , p do k = 1 , m c ( k , i ) = dot_product ( a ( k ,:), b ( i ,:)) end do end do end subroutine mm_ABT_9 !=============================================================================== !=============================================================================== !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! GFORTRAN DOESNT SUPPORT SHARED ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> author: Seyed Ali Ghasemi pure subroutine mm_ABT_10 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , p integer :: i , k m = size ( A , 1 ) p = size ( B , 1 ) error stop 'ForMatMul: shared is not supported in gfortran' !   do concurrent (i = 1: p) shared(m, p) ! check shared variables !     do k = 1, m !         c(k,i) = dot_product(a(k,:), b(i,:)) !     end do !   end do end subroutine mm_ABT_10 !=============================================================================== !=============================================================================== !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! GFORTRAN DOESNT SUPPORT SHARED ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> author: Seyed Ali Ghasemi pure subroutine mm_ABT_11 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 1 ) n = size ( A , 2 ) p = size ( B , 1 ) error stop 'ForMatMul: shared is not supported in gfortran' !    do concurrent (i = 1: p) shared(m, n, p) ! check shared variables !         do j=1,n !             do k=1,m !                 c(k,i) = c(k,i) + a(k,j)*b(i,j) !             end do !         end do !     end do end subroutine mm_ABT_11 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mm_ABT_12 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) interface pure subroutine impure_mm_ABT_12 ( f_a , f_b , f_c ) import rk real ( rk ), intent ( in ) :: f_a (:,:), f_b (:,:) real ( rk ), intent ( inout ) :: f_c (:,:) end subroutine impure_mm_ABT_12 end interface call impure_mm_ABT_12 ( a , b , c ) end subroutine mm_ABT_12 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mm_ABT_13 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) interface pure subroutine impure_mm_ABT_13 ( f_a , f_b , f_c ) import rk real ( rk ), intent ( in ) :: f_a (:,:), f_b (:,:) real ( rk ), intent ( inout ) :: f_c (:,:) end subroutine impure_mm_ABT_13 end interface call impure_mm_ABT_13 ( a , b , c ) end subroutine mm_ABT_13 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mm_ATBT_1 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) C = matmul ( transpose ( A ), transpose ( B )) end subroutine mm_ATBT_1 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mm_ATBT_2 ( A , B , C ) use external_interfaces_matmul real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p m = size ( A , 2 ) n = size ( A , 1 ) p = size ( B , 1 ) ! Call BLAS gemm subroutine for matrix-matrix multiplication. call gemm ( 'T' , 'T' , m , p , n , 1.0_rk , A , n , B , p , 0.0_rk , C , m ) end subroutine mm_ATBT_2 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mm_ATBT_3 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 2 ) n = size ( A , 1 ) p = size ( B , 1 ) do i = 1 , m do j = 1 , n do k = 1 , p c ( i , k ) = c ( i , k ) + a ( j , i ) * b ( k , j ) end do end do end do end subroutine mm_ATBT_3 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mm_ATBT_4 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 2 ) n = size ( A , 1 ) p = size ( B , 1 ) do i = 1 , m do j = 1 , p do k = 1 , n c ( i , j ) = c ( i , j ) + a ( k , i ) * b ( j , k ) end do end do end do end subroutine mm_ATBT_4 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mm_ATBT_5 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 2 ) n = size ( A , 1 ) p = size ( B , 1 ) do i = 1 , n do j = 1 , m do k = 1 , p c ( j , k ) = c ( j , k ) + a ( i , j ) * b ( k , i ) end do end do end do end subroutine mm_ATBT_5 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mm_ATBT_6 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 2 ) n = size ( A , 1 ) p = size ( B , 1 ) do i = 1 , n do j = 1 , p do k = 1 , m c ( k , j ) = c ( k , j ) + a ( i , k ) * b ( j , i ) end do end do end do end subroutine mm_ATBT_6 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mm_ATBT_7 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 2 ) n = size ( A , 1 ) p = size ( B , 1 ) do i = 1 , p do j = 1 , m do k = 1 , n c ( j , i ) = c ( j , i ) + a ( k , j ) * b ( i , k ) end do end do end do end subroutine mm_ATBT_7 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mm_ATBT_8 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 2 ) n = size ( A , 1 ) p = size ( B , 1 ) do i = 1 , p do j = 1 , n do k = 1 , m c ( k , i ) = c ( k , i ) + a ( j , k ) * b ( i , j ) end do end do end do end subroutine mm_ATBT_8 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mm_ATBT_9 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , p integer :: i , k m = size ( A , 2 ) p = size ( B , 1 ) do i = 1 , p do k = 1 , m c ( k , i ) = dot_product ( a (:, k ), b ( i ,:)) end do end do end subroutine mm_ATBT_9 !=============================================================================== !=============================================================================== !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! GFORTRAN DOESNT SUPPORT SHARED ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> author: Seyed Ali Ghasemi pure subroutine mm_ATBT_10 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , p integer :: i , k m = size ( A , 2 ) p = size ( B , 1 ) error stop 'ForMatMul: shared is not supported in gfortran' !   do concurrent (i = 1: p) shared(m, p) ! check shared variables !     do k = 1, m !         c(k,i) = dot_product(a(:,k), b(i,:)) !     end do !   end do end subroutine mm_ATBT_10 !=============================================================================== !=============================================================================== !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! GFORTRAN DOESNT SUPPORT SHARED ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> author: Seyed Ali Ghasemi pure subroutine mm_ATBT_11 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) integer :: m , n , p integer :: i , j , k m = size ( A , 2 ) n = size ( A , 1 ) p = size ( B , 1 ) error stop 'ForMatMul: shared is not supported in gfortran' !    do concurrent (i = 1: p) shared(m, n, p) ! check shared variables !         do j=1,n !             do k=1,m !                 c(k,i) = c(k,i) + a(j,k)*b(i,j) !             end do !         end do !     end do end subroutine mm_ATBT_11 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mm_ATBT_12 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) interface pure subroutine impure_mm_ATBT_12 ( f_a , f_b , f_c ) import rk real ( rk ), intent ( in ) :: f_a (:,:), f_b (:,:) real ( rk ), intent ( inout ) :: f_c (:,:) end subroutine impure_mm_ATBT_12 end interface call impure_mm_ATBT_12 ( a , b , c ) end subroutine mm_ATBT_12 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mm_ATBT_13 ( A , B , C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) interface pure subroutine impure_mm_ATBT_13 ( f_a , f_b , f_c ) import rk real ( rk ), intent ( in ) :: f_a (:,:), f_b (:,:) real ( rk ), intent ( inout ) :: f_c (:,:) end subroutine impure_mm_ATBT_13 end interface call impure_mm_ATBT_13 ( a , b , c ) end subroutine mm_ATBT_13 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mv_Av_1 ( A , v , w ) real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) real ( rk ), intent ( inout ), contiguous :: w (:) w = matmul ( A , v ) end subroutine mv_Av_1 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mv_Av_2 ( A , v , w ) use external_interfaces_matmul real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) real ( rk ), intent ( inout ), contiguous :: w (:) integer :: m m = size ( A , 1 ) ! Call BLAS gemv subroutine for matrix-vector multiplication. call gemv ( 'N' , m , size ( A , 2 ), 1.0_rk , A , m , v , 1 , 0.0_rk , w , 1 ) end subroutine mv_Av_2 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mv_Av_3 ( A , v , w ) real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) real ( rk ), intent ( inout ), contiguous :: w (:) integer :: m , n integer :: i , j m = size ( A , 1 ) n = size ( A , 2 ) do i = 1 , m do j = 1 , n w ( i ) = w ( i ) + a ( i , j ) * v ( j ) end do end do end subroutine mv_Av_3 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mv_Av_4 ( A , v , w ) real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) real ( rk ), intent ( inout ), contiguous :: w (:) integer :: m , n integer :: i , j m = size ( A , 1 ) n = size ( A , 2 ) do j = 1 , n do i = 1 , m w ( i ) = w ( i ) + a ( i , j ) * v ( j ) end do end do end subroutine mv_Av_4 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mv_Av_5 ( A , v , w ) real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) real ( rk ), intent ( inout ), contiguous :: w (:) integer :: m integer :: k m = size ( A , 1 ) do k = 1 , m w ( k ) = dot_product ( a ( k ,:), v (:)) end do end subroutine mv_Av_5 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mv_Av_6 ( A , v , w ) real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) real ( rk ), intent ( inout ), contiguous :: w (:) integer :: n integer :: k n = size ( A , 2 ) do k = 1 , n w (:) = w (:) + a (:, k ) * v ( k ) end do end subroutine mv_Av_6 !=============================================================================== !=============================================================================== !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! GFORTRAN DOESNT SUPPORT SHARED ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> author: Seyed Ali Ghasemi pure subroutine mv_Av_7 ( A , v , w ) real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) real ( rk ), intent ( inout ), contiguous :: w (:) integer :: m , n integer :: k m = size ( A , 1 ) error stop 'ForMatMul: shared is not supported in gfortran' !   do concurrent (k = 1: m) shared(m,a,v) ! check shared variables !      w(k) = dot_product(a(k,:), v(:)) !   end do end subroutine mv_Av_7 !=============================================================================== !=============================================================================== !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! GFORTRAN DOESNT SUPPORT SHARED ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> author: Seyed Ali Ghasemi pure subroutine mv_Av_8 ( A , v , w ) real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) real ( rk ), intent ( inout ), contiguous :: w (:) integer :: m , n integer :: i , j m = size ( A , 1 ) n = size ( A , 2 ) error stop 'ForMatMul: shared is not supported in gfortran' !   do concurrent(i=1:m) shared(m, n, a, v) ! check shared variables !      do j=1,n !         w(i) = w(i) + a(i,j)*v(j) !      end do !   end do end subroutine mv_Av_8 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mv_ATv_1 ( A , v , w ) real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) real ( rk ), intent ( inout ), contiguous :: w (:) w = matmul ( transpose ( A ), v ) end subroutine mv_ATv_1 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mv_ATv_2 ( A , v , w ) use external_interfaces_matmul real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) real ( rk ), intent ( inout ), contiguous :: w (:) integer :: m m = size ( A , 1 ) ! Call BLAS gemv subroutine for matrix-vector multiplication. call gemv ( 'T' , m , size ( A , 2 ), 1.0_rk , A , m , v , 1 , 0.0_rk , w , 1 ) end subroutine mv_ATv_2 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mv_ATv_3 ( A , v , w ) real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) real ( rk ), intent ( inout ), contiguous :: w (:) integer :: m , n integer :: i , j m = size ( A , 2 ) n = size ( A , 1 ) do i = 1 , m do j = 1 , n w ( i ) = w ( i ) + a ( j , i ) * v ( j ) end do end do end subroutine mv_ATv_3 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mv_ATv_4 ( A , v , w ) real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) real ( rk ), intent ( inout ), contiguous :: w (:) integer :: m , n integer :: i , j m = size ( A , 2 ) n = size ( A , 1 ) do j = 1 , n do i = 1 , m w ( i ) = w ( i ) + a ( j , i ) * v ( j ) end do end do end subroutine mv_ATv_4 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mv_ATv_5 ( A , v , w ) real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) real ( rk ), intent ( inout ), contiguous :: w (:) integer :: m integer :: k m = size ( A , 2 ) do k = 1 , m w ( k ) = dot_product ( a (:, k ), v (:)) end do end subroutine mv_ATv_5 !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mv_ATv_6 ( A , v , w ) real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) real ( rk ), intent ( inout ), contiguous :: w (:) integer :: n integer :: k n = size ( A , 1 ) do k = 1 , n w (:) = w (:) + a ( k ,:) * v ( k ) end do end subroutine mv_ATv_6 !=============================================================================== !=============================================================================== !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! GFORTRAN DOESNT SUPPORT SHARED ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> author: Seyed Ali Ghasemi pure subroutine mv_ATv_7 ( A , v , w ) real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) real ( rk ), intent ( inout ), contiguous :: w (:) integer :: m , n integer :: k m = size ( A , 2 ) error stop 'ForMatMul: shared is not supported in gfortran' !   do concurrent (k = 1: m) shared(m,a,v) ! check shared variables !      w(k) = dot_product(a(:,k), v(:)) !   end do end subroutine mv_ATv_7 !=============================================================================== !=============================================================================== !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! GFORTRAN DOESNT SUPPORT SHARED ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> author: Seyed Ali Ghasemi pure subroutine mv_ATv_8 ( A , v , w ) real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) real ( rk ), intent ( inout ), contiguous :: w (:) integer :: m , n integer :: i , j m = size ( A , 2 ) n = size ( A , 1 ) error stop 'ForMatMul: shared is not supported in gfortran' !   do concurrent(i=1:m) shared(m, n, a, v) ! check shared variables !      do j=1,n !         w(i) = w(i) + a(j,i)*v(j) !      end do !   end do end subroutine mv_ATv_8 !=============================================================================== end module formatmul_opts !> author: Seyed Ali Ghasemi impure subroutine impure_mm_AB_12 ( a , b , c ) use kinds implicit none real ( rk ), intent ( in ) :: a (:,:), b (:,:) real ( rk ), intent ( inout ) :: c (:,:) integer :: m , p integer :: i , k m = size ( A , 1 ) p = size ( B , 2 ) !$OMP PARALLEL DO PRIVATE(i, k) do i = 1 , p do k = 1 , m c ( k , i ) = dot_product ( a ( k ,:), b (:, i )) end do end do !$OMP END PARALLEL DO end subroutine impure_mm_AB_12 !> author: Seyed Ali Ghasemi impure subroutine impure_mm_AB_13 ( a , b , c ) use kinds implicit none real ( rk ), intent ( in ) :: a (:,:), b (:,:) real ( rk ), intent ( inout ) :: c (:,:) integer :: m , p integer :: i , k m = size ( A , 1 ) p = size ( B , 2 ) !$OMP PARALLEL DO DEFAULT(NONE) PRIVATE(i, k) SHARED(m, p, a, b, c) do i = 1 , p do k = 1 , m c ( k , i ) = dot_product ( a ( k ,:), b (:, i )) end do end do !$OMP END PARALLEL DO end subroutine impure_mm_AB_13 !> author: Seyed Ali Ghasemi impure subroutine impure_mm_ATB_12 ( a , b , c ) use kinds implicit none real ( rk ), intent ( in ) :: a (:,:), b (:,:) real ( rk ), intent ( inout ) :: c (:,:) integer :: m , p integer :: i , k m = size ( A , 2 ) p = size ( B , 2 ) !$OMP PARALLEL DO PRIVATE(i, k) do i = 1 , p do k = 1 , m c ( k , i ) = dot_product ( a (:, k ), b (:, i )) end do end do !$OMP END PARALLEL DO end subroutine impure_mm_ATB_12 !> author: Seyed Ali Ghasemi impure subroutine impure_mm_ATB_13 ( a , b , c ) use kinds implicit none real ( rk ), intent ( in ) :: a (:,:), b (:,:) real ( rk ), intent ( inout ) :: c (:,:) integer :: m , p integer :: i , k m = size ( A , 2 ) p = size ( B , 2 ) !$OMP PARALLEL DO DEFAULT(NONE) PRIVATE(i, k) SHARED(m, p, a, b, c) do i = 1 , p do k = 1 , m c ( k , i ) = dot_product ( a (:, k ), b (:, i )) end do end do !$OMP END PARALLEL DO end subroutine impure_mm_ATB_13 !> author: Seyed Ali Ghasemi impure subroutine impure_mm_ABT_12 ( a , b , c ) use kinds implicit none real ( rk ), intent ( in ) :: a (:,:), b (:,:) real ( rk ), intent ( inout ) :: c (:,:) integer :: m , p integer :: i , k m = size ( A , 1 ) p = size ( B , 1 ) !$OMP PARALLEL DO PRIVATE(i, k) do i = 1 , p do k = 1 , m c ( k , i ) = dot_product ( a ( k ,:), b ( i ,:)) end do end do !$OMP END PARALLEL DO end subroutine impure_mm_ABT_12 !> author: Seyed Ali Ghasemi impure subroutine impure_mm_ABT_13 ( a , b , c ) use kinds implicit none real ( rk ), intent ( in ) :: a (:,:), b (:,:) real ( rk ), intent ( inout ) :: c (:,:) integer :: m , p integer :: i , k m = size ( A , 1 ) p = size ( B , 1 ) !$OMP PARALLEL DO DEFAULT(NONE) PRIVATE(i, k) SHARED(m, p, a, b, c) do i = 1 , p do k = 1 , m c ( k , i ) = dot_product ( a ( k ,:), b ( i ,:)) end do end do !$OMP END PARALLEL DO end subroutine impure_mm_ABT_13 !> author: Seyed Ali Ghasemi impure subroutine impure_mm_ATBT_12 ( a , b , c ) use kinds implicit none real ( rk ), intent ( in ) :: a (:,:), b (:,:) real ( rk ), intent ( inout ) :: c (:,:) integer :: m , p integer :: i , k m = size ( A , 2 ) p = size ( B , 1 ) !$OMP PARALLEL DO PRIVATE(i, k) do i = 1 , p do k = 1 , m c ( k , i ) = dot_product ( a (:, k ), b ( i ,:)) end do end do !$OMP END PARALLEL DO end subroutine impure_mm_ATBT_12 !> author: Seyed Ali Ghasemi impure subroutine impure_mm_ATBT_13 ( a , b , c ) use kinds implicit none real ( rk ), intent ( in ) :: a (:,:), b (:,:) real ( rk ), intent ( inout ) :: c (:,:) integer :: m , p integer :: i , k m = size ( A , 2 ) p = size ( B , 1 ) !$OMP PARALLEL DO DEFAULT(NONE) PRIVATE(i, k) SHARED(m, p, a, b, c) do i = 1 , p do k = 1 , m c ( k , i ) = dot_product ( a (:, k ), b ( i ,:)) end do end do !$OMP END PARALLEL DO end subroutine impure_mm_ATBT_13","tags":"","loc":"sourcefile/formatmul_opts.f90.html"},{"title":"test3.f90 – ForMatmul","text":"This file depends on sourcefile~~test3.f90~~EfferentGraph sourcefile~test3.f90 test3.f90 sourcefile~formatmul.f90 formatmul.f90 sourcefile~test3.f90->sourcefile~formatmul.f90 sourcefile~formatmul_opts.f90 formatmul_opts.f90 sourcefile~formatmul.f90->sourcefile~formatmul_opts.f90 sourcefile~external_interfaces.f90 external_interfaces.f90 sourcefile~formatmul_opts.f90->sourcefile~external_interfaces.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program test_matmul5 use kinds use formatmul use forunittest implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C_ref (:,:), C (:,:) integer :: m , n , o type ( unit_test ) :: ut ! C(m,o) = A(m,n).B(o,n) m = 300 n = 200 o = 100 allocate ( A ( m , n ), B ( o , n )) call random_number ( A ) call random_number ( B ) A = A * 10 0.0_rk B = B * 10 0.0_rk C_ref = matmul ( A , transpose ( B )) C = matmul ( A , B , transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.1' ) C = matmul ( A , B , option = 'm1' , transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.2' ) C = matmul ( A , B , option = 'm2' , transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.3' ) C = matmul ( A , B , option = 'm3' , transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.4' ) C = matmul ( A , B , option = 'm4' , transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.5' ) C = matmul ( A , B , option = 'm5' , transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.6' ) C = matmul ( A , B , option = 'm6' , transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.7' ) C = matmul ( A , B , option = 'm7' , transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.8' ) C = matmul ( A , B , option = 'm8' , transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.9' ) C = matmul ( A , B , option = 'm9' , transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.10' ) ! C = matmul(A,B, option='m10', transB=.true.) ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul5.11') ! C = matmul(A,B, option='m11', transB=.true.) ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul5.12') C = matmul ( A , B , option = 'm12' , transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.13' ) C = matmul ( A , B , option = 'm13' , transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.14' ) C = matmul ( A , B , transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.15' ) C = matmul ( A , B , option = 'm1' , transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.16' ) C = matmul ( A , B , option = 'm2' , transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.17' ) C = matmul ( A , B , option = 'm3' , transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.18' ) C = matmul ( A , B , option = 'm4' , transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.19' ) C = matmul ( A , B , option = 'm5' , transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.20' ) C = matmul ( A , B , option = 'm6' , transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.21' ) C = matmul ( A , B , option = 'm7' , transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.22' ) C = matmul ( A , B , option = 'm8' , transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.23' ) C = matmul ( A , B , option = 'm9' , transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.24' ) ! C = matmul(A,B, option='m10', transB=.true., nblock=4) ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul5.25') ! C = matmul(A,B, option='m11', transB=.true., nblock=4) ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul5.26') C = matmul ( A , B , option = 'm12' , transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.27' ) C = matmul ( A , B , option = 'm13' , transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.28' ) C = matmul ( A , B , transA = . false ., transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.29' ) C = matmul ( A , B , option = 'm1' , transA = . false ., transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.30' ) C = matmul ( A , B , option = 'm2' , transA = . false ., transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.31' ) C = matmul ( A , B , option = 'm3' , transA = . false ., transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.32' ) C = matmul ( A , B , option = 'm4' , transA = . false ., transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.33' ) C = matmul ( A , B , option = 'm5' , transA = . false ., transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.34' ) C = matmul ( A , B , option = 'm6' , transA = . false ., transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.35' ) C = matmul ( A , B , option = 'm7' , transA = . false ., transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.36' ) C = matmul ( A , B , option = 'm8' , transA = . false ., transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.37' ) C = matmul ( A , B , option = 'm9' , transA = . false ., transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.38' ) ! C = matmul(A,B, option='m10', transA=.false., transB=.true.) ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul5.39') ! C = matmul(A,B, option='m11', transA=.false., transB=.true.) ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul5.40') C = matmul ( A , B , option = 'm12' , transA = . false ., transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.41' ) C = matmul ( A , B , option = 'm13' , transA = . false ., transB = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.42' ) C = matmul ( A , B , transA = . false ., transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.43' ) C = matmul ( A , B , option = 'm1' , transA = . false ., transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.44' ) C = matmul ( A , B , option = 'm2' , transA = . false ., transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.45' ) C = matmul ( A , B , option = 'm3' , transA = . false ., transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.46' ) C = matmul ( A , B , option = 'm4' , transA = . false ., transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.47' ) C = matmul ( A , B , option = 'm5' , transA = . false ., transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.48' ) C = matmul ( A , B , option = 'm6' , transA = . false ., transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.49' ) C = matmul ( A , B , option = 'm7' , transA = . false ., transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.50' ) C = matmul ( A , B , option = 'm8' , transA = . false ., transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.51' ) C = matmul ( A , B , option = 'm9' , transA = . false ., transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.52' ) ! C = matmul(A,B, option='m10', transA=.false., transB=.true., nblock=4) ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul5.53') ! C = matmul(A,B, option='m11', transA=.false., transB=.true., nblock=4) ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul5.54') C = matmul ( A , B , option = 'm12' , transA = . false ., transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.55' ) C = matmul ( A , B , option = 'm13' , transA = . false ., transB = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul5.56' ) end program test_matmul5","tags":"","loc":"sourcefile/test3.f90.html"},{"title":"formatmul.f90 – ForMatmul","text":"This file depends on sourcefile~~formatmul.f90~~EfferentGraph sourcefile~formatmul.f90 formatmul.f90 sourcefile~formatmul_opts.f90 formatmul_opts.f90 sourcefile~formatmul.f90->sourcefile~formatmul_opts.f90 sourcefile~external_interfaces.f90 external_interfaces.f90 sourcefile~formatmul_opts.f90->sourcefile~external_interfaces.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~formatmul.f90~~AfferentGraph sourcefile~formatmul.f90 formatmul.f90 sourcefile~test1.f90 test1.f90 sourcefile~test1.f90->sourcefile~formatmul.f90 sourcefile~test10.f90 test10.f90 sourcefile~test10.f90->sourcefile~formatmul.f90 sourcefile~test11.f90 test11.f90 sourcefile~test11.f90->sourcefile~formatmul.f90 sourcefile~test12.f90 test12.f90 sourcefile~test12.f90->sourcefile~formatmul.f90 sourcefile~test13.f90 test13.f90 sourcefile~test13.f90->sourcefile~formatmul.f90 sourcefile~test2.f90 test2.f90 sourcefile~test2.f90->sourcefile~formatmul.f90 sourcefile~test3.f90 test3.f90 sourcefile~test3.f90->sourcefile~formatmul.f90 sourcefile~test4.f90 test4.f90 sourcefile~test4.f90->sourcefile~formatmul.f90 sourcefile~test5.f90 test5.f90 sourcefile~test5.f90->sourcefile~formatmul.f90 sourcefile~test6.f90 test6.f90 sourcefile~test6.f90->sourcefile~formatmul.f90 sourcefile~test7.f90 test7.f90 sourcefile~test7.f90->sourcefile~formatmul.f90 sourcefile~test8.f90 test8.f90 sourcefile~test8.f90->sourcefile~formatmul.f90 sourcefile~test9.f90 test9.f90 sourcefile~test9.f90->sourcefile~formatmul.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module formatmul use kinds use formatmul_opts implicit none private public matmul interface matmul procedure :: mat_mat_rel procedure :: mat_mat_block_rel procedure :: mat_mat_coarray_rel procedure :: mat_vec_rel procedure :: mat_vec_block_rel procedure :: mat_vec_coarray_rel !   procedure :: vec_mat_rel ! Ambiguous interface end interface matmul contains !=============================================================================== !> author: Seyed Ali Ghasemi impure function mat_mat_coarray_rel ( a , b , transA , transB , option , coarray ) result ( c ) real ( rk ), intent ( in ), contiguous :: a (:,:), b (:,:) character ( * ), intent ( in ), optional :: option logical , intent ( in ), optional :: transA , transB real ( rk ), allocatable :: c (:,:) logical , intent ( in ) :: coarray #if defined (USE_COARRAY) integer :: i , im , nimg , n , m integer :: block_size ( num_images ()), start_elem ( num_images ()), end_elem ( num_images ()) real ( rk ), allocatable :: C_block (:,:)[:], B_block (:,:)[:], A_block (:,:)[:] if ( present ( transA ) . and . present ( transB )) then if (. not . transA . and . . not . transB ) then ! AB allocate ( C ( size ( A , 1 ), size ( B , 2 )), source = 0.0_rk ) im = this_image () nimg = num_images () m = size ( A , 1 ) n = size ( A , 2 ) call compute_block_ranges ( size ( B , 2 ), nimg , block_size , start_elem , end_elem ) allocate ( B_block ( n , block_size ( im ))[ * ], C_block ( m , block_size ( im ))[ * ]) B_block (:,:)[ im ] = B (:, start_elem ( im ): end_elem ( im )) C_block (:,:)[ im ] = matmul ( A , B_block (:,:)[ im ], transA = . false ., transB = . false ., option = option ) sync all if ( im == 1 ) then do i = 1 , nimg C (:, start_elem ( i ): end_elem ( i )) = C_block (:,:)[ i ] end do end if else if ( transA . and . transB ) then ! ATBT allocate ( C ( size ( A , 2 ), size ( B , 1 )), source = 0.0_rk ) im = this_image () nimg = num_images () m = size ( A , 1 ) n = size ( A , 2 ) call compute_block_ranges ( size ( A , 2 ), nimg , block_size , start_elem , end_elem ) allocate ( A_block ( m , block_size ( im ))[ * ], C_block ( block_size ( im ), size ( B , 1 ))[ * ]) A_block (:,:)[ im ] = A (:, start_elem ( im ): end_elem ( im )) C_block (:,:)[ im ] = matmul ( A_block (:,:)[ im ], B , transA = . true ., transB = . true ., option = option ) sync all if ( im == 1 ) then do i = 1 , nimg C ( start_elem ( i ): end_elem ( i ), :) = C_block (:,:)[ i ] end do end if else if ( transA . and . . not . transB ) then ! ATB allocate ( C ( size ( A , 2 ), size ( B , 2 )), source = 0.0_rk ) im = this_image () nimg = num_images () m = size ( A , 1 ) n = size ( A , 2 ) call compute_block_ranges ( size ( A , 2 ), nimg , block_size , start_elem , end_elem ) allocate ( A_block ( m , block_size ( im ))[ * ], C_block ( block_size ( im ), size ( B , 2 ))[ * ]) A_block (:,:)[ im ] = A (:, start_elem ( im ): end_elem ( im )) C_block (:,:)[ im ] = matmul ( A_block (:, :)[ im ], B , transA = . true ., transB = . false ., option = option ) sync all if ( im == 1 ) then do i = 1 , nimg C ( start_elem ( i ): end_elem ( i ), :) = C_block (:,:)[ i ] end do end if else if (. not . transA . and . transB ) then ! ABT allocate ( C ( size ( A , 1 ), size ( B , 1 )), source = 0.0_rk ) im = this_image () nimg = num_images () m = size ( A , 1 ) n = size ( A , 2 ) call compute_block_ranges ( size ( A , 2 ), nimg , block_size , start_elem , end_elem ) allocate ( A_block ( m , block_size ( im ))[ * ], B_block ( size ( B , 1 ), block_size ( im ))[ * ]) allocate ( C_block ( m , size ( B , 1 ))[ * ]) A_block (:,:)[ im ] = A (:, start_elem ( im ): end_elem ( im )) B_block (:,:)[ im ] = B (:, start_elem ( im ): end_elem ( im )) C_block (:,:)[ im ] = matmul ( A_block (:,:)[ im ], B_block (:,:)[ im ], transA = . false ., transB = . true ., option = option ) sync all if ( im == 1 ) then do i = 1 , nimg C (:, :) = C (:, :) + C_block (:,:)[ i ] end do end if end if else if ( present ( transA ) . or . present ( transB )) then if ( present ( transA )) then if ( transA ) then ! ATB allocate ( C ( size ( A , 2 ), size ( B , 2 )), source = 0.0_rk ) im = this_image () nimg = num_images () m = size ( A , 1 ) n = size ( A , 2 ) call compute_block_ranges ( size ( A , 2 ), nimg , block_size , start_elem , end_elem ) allocate ( A_block ( m , block_size ( im ))[ * ], C_block ( block_size ( im ), size ( B , 2 ))[ * ]) A_block (:,:)[ im ] = A (:, start_elem ( im ): end_elem ( im )) C_block (:,:)[ im ] = matmul ( A_block (:, :)[ im ], B , transA = . true ., transB = . false ., option = option ) sync all if ( im == 1 ) then do i = 1 , nimg C ( start_elem ( i ): end_elem ( i ), :) = C_block (:,:)[ i ] end do end if else if (. not . transA ) then ! ABT allocate ( C ( size ( A , 1 ), size ( B , 1 )), source = 0.0_rk ) im = this_image () nimg = num_images () m = size ( A , 1 ) n = size ( A , 2 ) call compute_block_ranges ( size ( A , 2 ), nimg , block_size , start_elem , end_elem ) allocate ( A_block ( m , block_size ( im ))[ * ], B_block ( size ( B , 1 ), block_size ( im ))[ * ]) allocate ( C_block ( m , size ( B , 1 ))[ * ]) A_block (:,:)[ im ] = A (:, start_elem ( im ): end_elem ( im )) B_block (:,:)[ im ] = B (:, start_elem ( im ): end_elem ( im )) C_block (:,:)[ im ] = matmul ( A_block (:,:)[ im ], B_block (:,:)[ im ], transA = . false ., transB = . true ., option = option ) sync all if ( im == 1 ) then do i = 1 , nimg C (:, :) = C (:, :) + C_block (:,:)[ i ] end do end if end if else if ( present ( transB )) then if ( transB ) then ! ABT allocate ( C ( size ( A , 1 ), size ( B , 1 )), source = 0.0_rk ) im = this_image () nimg = num_images () m = size ( A , 1 ) n = size ( A , 2 ) call compute_block_ranges ( size ( A , 2 ), nimg , block_size , start_elem , end_elem ) allocate ( A_block ( m , block_size ( im ))[ * ], B_block ( size ( B , 1 ), block_size ( im ))[ * ]) allocate ( C_block ( m , size ( B , 1 ))[ * ]) A_block (:,:)[ im ] = A (:, start_elem ( im ): end_elem ( im )) B_block (:,:)[ im ] = B (:, start_elem ( im ): end_elem ( im )) C_block (:,:)[ im ] = matmul ( A_block (:,:)[ im ], B_block (:,:)[ im ], transA = . false ., transB = . true ., option = option ) sync all if ( im == 1 ) then do i = 1 , nimg C (:, :) = C (:, :) + C_block (:,:)[ i ] end do end if else if (. not . transB ) then ! ATB allocate ( C ( size ( A , 2 ), size ( B , 2 )), source = 0.0_rk ) im = this_image () nimg = num_images () m = size ( A , 1 ) n = size ( A , 2 ) call compute_block_ranges ( size ( A , 2 ), nimg , block_size , start_elem , end_elem ) allocate ( A_block ( m , block_size ( im ))[ * ], C_block ( block_size ( im ), size ( B , 2 ))[ * ]) A_block (:,:)[ im ] = A (:, start_elem ( im ): end_elem ( im )) C_block (:,:)[ im ] = matmul ( A_block (:, :)[ im ], B , transA = . true ., transB = . false ., option = option ) sync all if ( im == 1 ) then do i = 1 , nimg C ( start_elem ( i ): end_elem ( i ), :) = C_block (:,:)[ i ] end do end if end if end if else if (. not . present ( transA ) . and . . not . present ( transB )) then ! AB allocate ( C ( size ( A , 1 ), size ( B , 2 )), source = 0.0_rk ) im = this_image () nimg = num_images () m = size ( A , 1 ) n = size ( A , 2 ) call compute_block_ranges ( size ( B , 2 ), nimg , block_size , start_elem , end_elem ) allocate ( B_block ( n , block_size ( im ))[ * ], C_block ( m , block_size ( im ))[ * ]) B_block (:,:)[ im ] = B (:, start_elem ( im ): end_elem ( im )) C_block (:,:)[ im ] = matmul ( A , B_block (:,:)[ im ], transA = . false ., transB = . false ., option = option ) sync all if ( im == 1 ) then do i = 1 , nimg C (:, start_elem ( i ): end_elem ( i )) = C_block (:,:)[ i ] end do end if end if #else C = matmul ( A , B , transA = transA , transB = transB , option = option ) #endif end function mat_mat_coarray_rel !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure function mat_vec_coarray_rel ( A , v , transA , option , coarray ) result ( w ) real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) character ( * ), intent ( in ), optional :: option logical , intent ( in ), optional :: transA real ( rk ), allocatable :: w (:) logical , intent ( in ) :: coarray #if defined (USE_COARRAY) integer :: i , im , nimg , n , m integer :: block_size ( num_images ()), start_elem ( num_images ()), end_elem ( num_images ()) real ( rk ), allocatable :: w_block (:)[:], v_block (:)[:], A_block (:,:)[:] if ( present ( transA )) then if ( transA ) then ! ATv allocate ( w ( size ( A , 2 )), source = 0.0_rk ) im = this_image () nimg = num_images () call compute_block_ranges ( size ( A , 2 ), nimg , block_size , start_elem , end_elem ) allocate ( w_block ( block_size ( im ))[ * ], A_block ( size ( A , 1 ), block_size ( im ))[ * ]) A_block (:,:)[ im ] = A (:, start_elem ( im ): end_elem ( im )) w_block (:)[ im ] = matmul ( A_block (:, :)[ im ], v , transA = . true ., option = option ) sync all if ( im == 1 ) then do i = 1 , nimg w ( start_elem ( i ): end_elem ( i )) = w_block (:)[ i ] end do end if else if (. not . transA ) then ! Av allocate ( w ( size ( A , 1 )), source = 0.0_rk ) im = this_image () nimg = num_images () call compute_block_ranges ( size ( A , 2 ), nimg , block_size , start_elem , end_elem ) allocate ( w_block ( size ( A , 1 ))[ * ], v_block ( block_size ( im ))[ * ], A_block ( size ( A , 1 ), block_size ( im ))[ * ]) A_block (:,:)[ im ] = A (:, start_elem ( im ): end_elem ( im )) v_block (:)[ im ] = v ( start_elem ( im ): end_elem ( im )) w_block (:)[ im ] = matmul ( A_block (:,:)[ im ], v_block (:)[ im ], transA = . false ., option = option ) sync all if ( im == 1 ) then do i = 1 , nimg w (:) = w (:) + w_block (:)[ i ] end do end if end if else if (. not . present ( transA )) then ! Av allocate ( w ( size ( A , 1 )), source = 0.0_rk ) im = this_image () nimg = num_images () call compute_block_ranges ( size ( A , 2 ), nimg , block_size , start_elem , end_elem ) allocate ( w_block ( size ( A , 1 ))[ * ], v_block ( block_size ( im ))[ * ], A_block ( size ( A , 1 ), block_size ( im ))[ * ]) A_block (:,:)[ im ] = A (:, start_elem ( im ): end_elem ( im )) v_block (:)[ im ] = v ( start_elem ( im ): end_elem ( im )) w_block (:)[ im ] = matmul ( A_block (:,:)[ im ], v_block (:)[ im ], transA = . false ., option = option ) sync all if ( im == 1 ) then do i = 1 , nimg w (:) = w (:) + w_block (:)[ i ] end do end if end if #else w = matmul ( A , v , transA = transA , option = option ) #endif end function mat_vec_coarray_rel !=============================================================================== !=============================================================================== !> Calculate block sizes and ranges. !> author: Seyed Ali Ghasemi pure subroutine compute_block_ranges ( d , nimg , block_size , start_elem , end_elem ) integer , intent ( in ) :: d , nimg integer , intent ( out ) :: block_size ( nimg ), start_elem ( nimg ), end_elem ( nimg ) integer :: i , remainder block_size = d / nimg remainder = mod ( d , nimg ) block_size ( 1 : remainder ) = block_size ( 1 : remainder ) + 1 start_elem ( 1 ) = 1 do i = 2 , nimg start_elem ( i ) = start_elem ( i - 1 ) + block_size ( i - 1 ) end do end_elem ( 1 ) = block_size ( 1 ) end_elem ( 2 :) = start_elem ( 2 :) + block_size ( 2 :) - 1 ! Check if the block sizes are valid. if ( minval ( block_size ) <= 0 ) error stop 'ForDot: reduce the number of images of coarray.' end subroutine compute_block_ranges !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure function mat_mat_block_rel ( a , b , transA , transB , option , nblock ) result ( c ) real ( rk ), intent ( in ), contiguous :: a (:,:), b (:,:) logical , intent ( in ), optional :: transA , transB character ( * ), intent ( in ), optional :: option integer , intent ( in ) :: nblock real ( rk ), allocatable :: c (:,:) integer :: ib , se , ee integer :: block_size ( nblock ), start_elem ( nblock ), end_elem ( nblock ) if ( present ( transA ) . and . present ( transB )) then if (. not . transA . and . . not . transB ) then ! AB allocate ( C ( size ( A , 1 ), size ( B , 2 )), source = 0.0_rk ) call compute_block_ranges ( size ( B , 2 ), nblock , block_size , start_elem , end_elem ) #if defined(USE_DO_CONCURRENT) do concurrent ( ib = 1 : nblock ) se = start_elem ( ib ) ee = end_elem ( ib ) C (:, se : ee ) = & C (:, se : ee ) + matmul ( A , B (:, se : ee ), transA = . false ., transB = . false ., option = option ) end do #else do ib = 1 , nblock se = start_elem ( ib ) ee = end_elem ( ib ) C (:, se : ee ) = & C (:, se : ee ) + matmul ( A , B (:, se : ee ), transA = . false ., transB = . false ., option = option ) end do #endif else if ( transA . and . transB ) then ! ATBT allocate ( C ( size ( A , 2 ), size ( B , 1 )), source = 0.0_rk ) call compute_block_ranges ( size ( A , 2 ), nblock , block_size , start_elem , end_elem ) #if defined(USE_DO_CONCURRENT) do concurrent ( ib = 1 : nblock ) se = start_elem ( ib ) ee = end_elem ( ib ) C ( se : ee , :) = & C ( se : ee , :) + matmul ( A (:, se : ee ), B , transA = . true ., transB = . true ., option = option ) end do #else do ib = 1 , nblock se = start_elem ( ib ) ee = end_elem ( ib ) C ( se : ee , :) = & C ( se : ee , :) + matmul ( A (:, se : ee ), B , transA = . true ., transB = . true ., option = option ) end do #endif else if ( transA . and . . not . transB ) then ! ATB allocate ( C ( size ( A , 2 ), size ( B , 2 )), source = 0.0_rk ) call compute_block_ranges ( size ( A , 2 ), nblock , block_size , start_elem , end_elem ) #if defined(USE_DO_CONCURRENT) do concurrent ( ib = 1 : nblock ) se = start_elem ( ib ) ee = end_elem ( ib ) C ( se : ee , :) = & C ( se : ee , :) + matmul ( A (:, se : ee ), B , transA = . true ., transB = . false ., option = option ) end do #else do ib = 1 , nblock se = start_elem ( ib ) ee = end_elem ( ib ) C ( se : ee , :) = & C ( se : ee , :) + matmul ( A (:, se : ee ), B , transA = . true ., transB = . false ., option = option ) end do #endif else if (. not . transA . and . transB ) then ! ABT allocate ( C ( size ( A , 1 ), size ( B , 1 )), source = 0.0_rk ) call compute_block_ranges ( size ( A , 2 ), nblock , block_size , start_elem , end_elem ) #if defined(USE_DO_CONCURRENT) do concurrent ( ib = 1 : nblock ) se = start_elem ( ib ) ee = end_elem ( ib ) C (:, :) = C (:, :) + & matmul ( A (:, se : ee ), B (:, se : ee ), transA = . false ., transB = . true ., option = option ) end do #else do ib = 1 , nblock se = start_elem ( ib ) ee = end_elem ( ib ) C (:, :) = C (:, :) + & matmul ( A (:, se : ee ), B (:, se : ee ), transA = . false ., transB = . true ., option = option ) end do #endif end if else if ( present ( transA ) . or . present ( transB )) then if ( present ( transA )) then if ( transA ) then ! ATB allocate ( C ( size ( A , 2 ), size ( B , 2 )), source = 0.0_rk ) call compute_block_ranges ( size ( A , 2 ), nblock , block_size , start_elem , end_elem ) #if defined(USE_DO_CONCURRENT) do concurrent ( ib = 1 : nblock ) se = start_elem ( ib ) ee = end_elem ( ib ) C ( se : ee , :) = & C ( se : ee , :) + matmul ( A (:, se : ee ), B , transA = . true ., transB = . false ., option = option ) end do #else do ib = 1 , nblock se = start_elem ( ib ) ee = end_elem ( ib ) C ( se : ee , :) = & C ( se : ee , :) + matmul ( A (:, se : ee ), B , transA = . true ., transB = . false ., option = option ) end do #endif else if (. not . transA ) then ! ABT allocate ( C ( size ( A , 1 ), size ( B , 1 )), source = 0.0_rk ) call compute_block_ranges ( size ( A , 2 ), nblock , block_size , start_elem , end_elem ) #if defined(USE_DO_CONCURRENT) do concurrent ( ib = 1 : nblock ) se = start_elem ( ib ) ee = end_elem ( ib ) C (:, :) = C (:, :) + & matmul ( A (:, se : ee ), B (:, se : ee ), transA = . false ., transB = . true ., option = option ) end do #else do ib = 1 , nblock se = start_elem ( ib ) ee = end_elem ( ib ) C (:, :) = C (:, :) + & matmul ( A (:, se : ee ), B (:, se : ee ), transA = . false ., transB = . true ., option = option ) end do #endif end if else if ( present ( transB )) then if ( transB ) then ! ABT allocate ( C ( size ( A , 1 ), size ( B , 1 )), source = 0.0_rk ) call compute_block_ranges ( size ( A , 2 ), nblock , block_size , start_elem , end_elem ) #if defined(USE_DO_CONCURRENT) do concurrent ( ib = 1 : nblock ) se = start_elem ( ib ) ee = end_elem ( ib ) C (:, :) = C (:, :) + & matmul ( A (:, se : ee ), B (:, se : ee ), transA = . false ., transB = . true ., option = option ) end do #else do ib = 1 , nblock se = start_elem ( ib ) ee = end_elem ( ib ) C (:, :) = C (:, :) + & matmul ( A (:, se : ee ), B (:, se : ee ), transA = . false ., transB = . true ., option = option ) end do #endif else if (. not . transB ) then ! ATB allocate ( C ( size ( A , 2 ), size ( B , 2 )), source = 0.0_rk ) call compute_block_ranges ( size ( A , 2 ), nblock , block_size , start_elem , end_elem ) #if defined(USE_DO_CONCURRENT) do concurrent ( ib = 1 : nblock ) se = start_elem ( ib ) ee = end_elem ( ib ) C ( se : ee , :) = & C ( se : ee , :) + matmul ( A (:, se : ee ), B , transA = . true ., transB = . false ., option = option ) end do #else do ib = 1 , nblock se = start_elem ( ib ) ee = end_elem ( ib ) C ( se : ee , :) = & C ( se : ee , :) + matmul ( A (:, se : ee ), B , transA = . true ., transB = . false ., option = option ) end do #endif end if end if else if (. not . present ( transA ) . and . . not . present ( transB )) then ! AB allocate ( C ( size ( A , 1 ), size ( B , 2 )), source = 0.0_rk ) call compute_block_ranges ( size ( B , 2 ), nblock , block_size , start_elem , end_elem ) #if defined(USE_DO_CONCURRENT) do concurrent ( ib = 1 : nblock ) se = start_elem ( ib ) ee = end_elem ( ib ) C (:, se : ee ) = & C (:, se : ee ) + matmul ( A , B (:, se : ee ), transA = . false ., transB = . false ., option = option ) end do #else do ib = 1 , nblock se = start_elem ( ib ) ee = end_elem ( ib ) C (:, se : ee ) = & C (:, se : ee ) + matmul ( A , B (:, se : ee ), transA = . false ., transB = . false ., option = option ) end do #endif end if end function mat_mat_block_rel !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure function mat_vec_block_rel ( A , v , transA , option , nblock ) result ( w ) real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) logical , intent ( in ), optional :: transA character ( * ), intent ( in ), optional :: option integer , intent ( in ) :: nblock real ( rk ), allocatable :: w (:) integer :: ib , se , ee integer :: block_size ( nblock ), start_elem ( nblock ), end_elem ( nblock ) if ( present ( transA )) then if ( transA ) then ! ATv allocate ( w ( size ( A , 2 )), source = 0.0_rk ) call compute_block_ranges ( size ( A , 2 ), nblock , block_size , start_elem , end_elem ) #if defined(USE_DO_CONCURRENT) do concurrent ( ib = 1 : nblock ) se = start_elem ( ib ) ee = end_elem ( ib ) w ( se : ee ) = & w ( se : ee ) + matmul ( A (:, se : ee ), v , transA = . true ., option = option ) end do #else do ib = 1 , nblock se = start_elem ( ib ) ee = end_elem ( ib ) w ( se : ee ) = & w ( se : ee ) + matmul ( A (:, se : ee ), v , transA = . true ., option = option ) end do #endif else if (. not . transA ) then ! Av allocate ( w ( size ( A , 1 )), source = 0.0_rk ) call compute_block_ranges ( size ( A , 2 ), nblock , block_size , start_elem , end_elem ) #if defined(USE_DO_CONCURRENT) do concurrent ( ib = 1 : nblock ) se = start_elem ( ib ) ee = end_elem ( ib ) w (:) = & w (:) + matmul ( A (:, se : ee ), v ( se : ee ), transA = . false ., option = option ) end do #else do ib = 1 , nblock se = start_elem ( ib ) ee = end_elem ( ib ) w (:) = & w (:) + matmul ( A (:, se : ee ), v ( se : ee ), transA = . false ., option = option ) end do #endif end if else if (. not . present ( transA )) then ! Av allocate ( w ( size ( A , 1 )), source = 0.0_rk ) call compute_block_ranges ( size ( A , 2 ), nblock , block_size , start_elem , end_elem ) #if defined(USE_DO_CONCURRENT) do concurrent ( ib = 1 : nblock ) se = start_elem ( ib ) ee = end_elem ( ib ) w (:) = & w (:) + matmul ( A (:, se : ee ), v ( se : ee ), transA = . false ., option = option ) end do #else do ib = 1 , nblock se = start_elem ( ib ) ee = end_elem ( ib ) w (:) = & w (:) + matmul ( A (:, se : ee ), v ( se : ee ), transA = . false ., option = option ) end do #endif end if end function mat_vec_block_rel !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure function mat_mat_rel ( A , B , transA , transB , option ) result ( C ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), allocatable :: C (:,:) character ( * ), intent ( in ), optional :: option logical , intent ( in ), optional :: transA , transB if ( present ( transA ) . and . present ( transB )) then if (. not . transA . and . . not . transB ) then ! AB allocate ( C ( size ( A , 1 ), size ( B , 2 )), source = 0.0_rk ) call mat_mat_rel_AB ( A , B , C , option ) else if ( transA . and . transB ) then ! ATBT allocate ( C ( size ( A , 2 ), size ( B , 1 )), source = 0.0_rk ) call mat_mat_rel_ATBT ( A , B , C , option ) else if ( transA . and . . not . transB ) then ! ATB allocate ( C ( size ( A , 2 ), size ( B , 2 )), source = 0.0_rk ) call mat_mat_rel_ATB ( A , B , C , option ) else if (. not . transA . and . transB ) then ! ABT allocate ( C ( size ( A , 1 ), size ( B , 1 )), source = 0.0_rk ) call mat_mat_rel_ABT ( A , B , C , option ) end if else if ( present ( transA ) . or . present ( transB )) then if ( present ( transA )) then if ( transA ) then ! ATB allocate ( C ( size ( A , 2 ), size ( B , 2 )), source = 0.0_rk ) call mat_mat_rel_ATB ( A , B , C , option ) else if (. not . transA ) then ! ABT allocate ( C ( size ( A , 1 ), size ( B , 1 )), source = 0.0_rk ) call mat_mat_rel_ABT ( A , B , C , option ) end if else if ( present ( transB )) then if ( transB ) then ! ABT allocate ( C ( size ( A , 1 ), size ( B , 1 )), source = 0.0_rk ) call mat_mat_rel_ABT ( A , B , C , option ) else if (. not . transB ) then ! ATB allocate ( C ( size ( A , 2 ), size ( B , 2 )), source = 0.0_rk ) call mat_mat_rel_ATB ( A , B , C , option ) end if end if else if (. not . present ( transA ) . and . . not . present ( transB )) then ! AB allocate ( C ( size ( A , 1 ), size ( B , 2 )), source = 0.0_rk ) call mat_mat_rel_AB ( A , B , C , option ) end if end function mat_mat_rel !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure function mat_vec_rel ( A , v , transA , option ) result ( w ) real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) real ( rk ), allocatable :: w (:) character ( * ), intent ( in ), optional :: option logical , intent ( in ), optional :: transA if ( present ( transA )) then if ( transA ) then ! ATv allocate ( w ( size ( A , 2 )), source = 0.0_rk ) call mat_vec_rel_ATv ( A , v , w , option ) else if (. not . transA ) then ! Av allocate ( w ( size ( A , 1 )), source = 0.0_rk ) call mat_vec_rel_Av ( A , v , w , option ) end if else if (. not . present ( transA )) then ! Av allocate ( w ( size ( A , 1 )), source = 0.0_rk ) call mat_vec_rel_Av ( A , v , w , option ) end if end function mat_vec_rel !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mat_mat_rel_AB ( A , B , C , option ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) character ( * ), intent ( in ), optional :: option if ( present ( option )) then call mat_mat_rel_AB_opt ( A , B , C , option ) else call mat_mat_rel_AB_opt ( A , B , C , 'm2' ) end if end subroutine mat_mat_rel_AB !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mat_mat_rel_ATB ( A , B , C , option ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) character ( * ), intent ( in ), optional :: option if ( present ( option )) then call mat_mat_rel_ATB_opt ( A , B , C , option ) else call mat_mat_rel_ATB_opt ( A , B , C , 'm2' ) end if end subroutine mat_mat_rel_ATB !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mat_mat_rel_ABT ( A , B , C , option ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) character ( * ), intent ( in ), optional :: option if ( present ( option )) then call mat_mat_rel_ABT_opt ( A , B , C , option ) else call mat_mat_rel_ABT_opt ( A , B , C , 'm2' ) end if end subroutine mat_mat_rel_ABT !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mat_mat_rel_ATBT ( A , B , C , option ) real ( rk ), intent ( in ), contiguous :: A (:,:), B (:,:) real ( rk ), intent ( inout ), contiguous :: C (:,:) character ( * ), intent ( in ), optional :: option if ( present ( option )) then call mat_mat_rel_ATBT_opt ( A , B , C , option ) else call mat_mat_rel_ATBT_opt ( A , B , C , 'm2' ) end if end subroutine mat_mat_rel_ATBT !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mat_vec_rel_Av ( A , v , w , option ) real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) real ( rk ), intent ( inout ), contiguous :: w (:) character ( * ), intent ( in ), optional :: option if ( present ( option )) then call mat_vec_rel_Av_opt ( A , v , w , option ) else call mat_vec_rel_Av_opt ( A , v , w , 'm2' ) end if end subroutine mat_vec_rel_Av !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine mat_vec_rel_ATv ( A , v , w , option ) real ( rk ), intent ( in ), contiguous :: A (:,:), v (:) real ( rk ), intent ( inout ), contiguous :: w (:) character ( * ), intent ( in ), optional :: option if ( present ( option )) then call mat_vec_rel_ATv_opt ( A , v , w , option ) else call mat_vec_rel_ATv_opt ( A , v , w , 'm2' ) end if end subroutine mat_vec_rel_ATv !=============================================================================== !    ! Ambiguous interface !    !=============================================================================== !    !> author: Seyed Ali Ghasemi !    pure function vec_mat_rel(v, A, transA, option) result(w) !       real(rk), intent(in), contiguous :: v(:), A(:,:) !       real(rk), allocatable :: w(:) !       character(*), intent(in), optional :: option !       logical, intent(in), optional :: transA !       if (present(transA)) then !          if (transA) then !             ! ATv !             allocate(w(size(A,1)), source=0.0_rk) !             call vec_mat_rel_ATv(v, A, w, option) !          else if (.not. transA) then !             ! Av !             allocate(w(size(A,2)), source=0.0_rk) !             call vec_mat_rel_Av(v, A, w, option) !          end if !       else if (.not. present(transA)) then !          ! Av !          allocate(w(size(A,2)), source=0.0_rk) !          call vec_mat_rel_Av(v, A, w, option) !       end if !    end function vec_mat_rel !    !=============================================================================== !    !=============================================================================== !    !> author: Seyed Ali Ghasemi !    pure subroutine vec_mat_rel_Av(v, A, w, option) !       real(rk), intent(in), contiguous :: A(:,:), v(:) !       real(rk), intent(inout), contiguous :: w(:) !       character(*), intent(in), optional :: option !       if (present(option)) then !          call vec_mat_rel_Av_opt(v, A, w, option) !       else !          call vec_mat_rel_Av_opt(v, A, w, 'm2') !       end if !    end subroutine vec_mat_rel_Av !    !=============================================================================== !    !=============================================================================== !    !> author: Seyed Ali Ghasemi !    pure subroutine vec_mat_rel_ATv(v, A, w, option) !       real(rk), intent(in), contiguous :: A(:,:), v(:) !       real(rk), intent(inout), contiguous :: w(:) !       character(*), intent(in), optional :: option !       if (present(option)) then !          call vec_mat_rel_ATv_opt(v, A, w, option) !       else !          call vec_mat_rel_ATv_opt(v, A, w, 'm2') !       end if !    end subroutine vec_mat_rel_ATv !    !=============================================================================== !    !=============================================================================== !    !> author: Seyed Ali Ghasemi !    pure subroutine vec_mat_rel_Av_opt(v, A, w, option) !       real(rk), intent(in), contiguous :: A(:,:), v(:) !       real(rk), intent(inout), contiguous :: w(:) !       character(*), intent(in) :: option !       !   select case (option) !       !    case ('m1') !       !      call vm_vA_1(v, A, w) !       !    case ('m2') !       !      call vm_vA_2(v, A, w) !       !    case ('m3') !       !      call vm_vA_3(v, A, w) !       !    case ('m4') !       !      call vm_vA_4(v, A, w) !       !    case ('m5') !       !      call vm_vA_5(v, A, w) !       !    case ('m6') !       !      call vm_vA_6(v, A, w) !       !    case ('m7') !       !      call vm_vA_7(v, A, w) !       !    case ('m8') !       !      call vm_vA_8(v, A, w) !       !   end select !    end subroutine vec_mat_rel_Av_opt !    !=============================================================================== !    !=============================================================================== !    !> author: Seyed Ali Ghasemi !    pure subroutine vec_mat_rel_ATv_opt(v, A, w, option) !       real(rk), intent(in), contiguous :: A(:,:), v(:) !       real(rk), intent(inout), contiguous :: w(:) !       character(*), intent(in) :: option !       !   select case (option) !       !    case ('m1') !       !      call vm_vAT_1(v, A, w) !       !    case ('m2') !       !      call vm_vAT_2(v, A, w) !       !    case ('m3') !       !      call vm_vAT_3(v, A, w) !       !    case ('m4') !       !      call vm_vAT_4(v, A, w) !       !    case ('m5') !       !      call vm_vAT_5(v, A, w) !       !    case ('m6') !       !      call vm_vAT_6(v, A, w) !       !    case ('m7') !       !      call vm_vAT_7(v, A, w) !       !    case ('m8') !       !      call vm_vAT_8(v, A, w) !       !   end select !    end subroutine vec_mat_rel_ATv_opt !    !=============================================================================== end module formatmul","tags":"","loc":"sourcefile/formatmul.f90.html"},{"title":"test7.f90 – ForMatmul","text":"This file depends on sourcefile~~test7.f90~~EfferentGraph sourcefile~test7.f90 test7.f90 sourcefile~formatmul.f90 formatmul.f90 sourcefile~test7.f90->sourcefile~formatmul.f90 sourcefile~formatmul_opts.f90 formatmul_opts.f90 sourcefile~formatmul.f90->sourcefile~formatmul_opts.f90 sourcefile~external_interfaces.f90 external_interfaces.f90 sourcefile~formatmul_opts.f90->sourcefile~external_interfaces.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program test_matmul9 use kinds use formatmul use forunittest implicit none real ( rk ), allocatable :: A (:,:), v (:) real ( rk ), allocatable :: w_ref (:), w (:) integer :: m , n type ( unit_test ) :: ut ! w(n) = v(m).A(m,n) m = 100 n = 300 allocate ( A ( m , n ), v ( m )) call random_number ( A ) call random_number ( v ) A = A * 10 0.0_rk v = v * 10 0.0_rk w_ref = matmul ( v , A ) w = matmul ( A , v , transA = . true .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul9.1' ) w = matmul ( A , v , option = 'm1' , transA = . true .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul9.2' ) w = matmul ( A , v , option = 'm2' , transA = . true .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul9.3' ) w = matmul ( A , v , option = 'm3' , transA = . true .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul9.4' ) w = matmul ( A , v , option = 'm4' , transA = . true .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul9.5' ) w = matmul ( A , v , option = 'm5' , transA = . true .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul9.6' ) w = matmul ( A , v , option = 'm6' , transA = . true .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul9.7' ) ! w = matmul(A,v, option='m7', transA=.true.) ! call ut%check(w, w_ref, tol=1e-5_rk, msg='test_matmul9.8') ! w = matmul(A,v, option='m8', transA=.true.) ! call ut%check(w, w_ref, tol=1e-5_rk, msg='test_matmul9.9') w = matmul ( A , v , transA = . true ., nblock = 4 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul9.10' ) w = matmul ( A , v , option = 'm1' , transA = . true ., nblock = 4 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul9.11' ) w = matmul ( A , v , option = 'm2' , transA = . true ., nblock = 4 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul9.12' ) w = matmul ( A , v , option = 'm3' , transA = . true ., nblock = 4 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul9.13' ) w = matmul ( A , v , option = 'm4' , transA = . true ., nblock = 4 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul9.14' ) w = matmul ( A , v , option = 'm5' , transA = . true ., nblock = 4 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul9.15' ) w = matmul ( A , v , option = 'm6' , transA = . true ., nblock = 4 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul9.16' ) ! w = matmul(A,v, option='m7', transA=.true., nblock=4) ! call ut%check(w, w_ref, tol=1e-5_rk, msg='test_matmul9.17') ! w = matmul(A,v, option='m8', transA=.true., nblock=4) ! call ut%check(w, w_ref, tol=1e-5_rk, msg='test_matmul9.18') end program test_matmul9","tags":"","loc":"sourcefile/test7.f90.html"},{"title":"test6.f90 – ForMatmul","text":"This file depends on sourcefile~~test6.f90~~EfferentGraph sourcefile~test6.f90 test6.f90 sourcefile~formatmul.f90 formatmul.f90 sourcefile~test6.f90->sourcefile~formatmul.f90 sourcefile~formatmul_opts.f90 formatmul_opts.f90 sourcefile~formatmul.f90->sourcefile~formatmul_opts.f90 sourcefile~external_interfaces.f90 external_interfaces.f90 sourcefile~formatmul_opts.f90->sourcefile~external_interfaces.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program test_matmul8 use kinds use formatmul use forunittest implicit none real ( rk ), allocatable :: A (:,:), v (:) real ( rk ), allocatable :: w_ref (:), w (:) integer :: m , n type ( unit_test ) :: ut ! w(m) = A(n,m).v(n) m = 100 n = 300 allocate ( A ( n , m ), v ( n )) call random_number ( A ) call random_number ( v ) A = A * 10 0.0_rk v = v * 10 0.0_rk w_ref = matmul ( transpose ( A ), v ) w = matmul ( A , v , transA = . true .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul8.1' ) w = matmul ( A , v , option = 'm1' , transA = . true .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul8.2' ) w = matmul ( A , v , option = 'm2' , transA = . true .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul8.3' ) w = matmul ( A , v , option = 'm3' , transA = . true .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul8.4' ) w = matmul ( A , v , option = 'm4' , transA = . true .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul8.5' ) w = matmul ( A , v , option = 'm5' , transA = . true .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul8.6' ) w = matmul ( A , v , option = 'm6' , transA = . true .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul8.7' ) ! w = matmul(A,v, option='m7', transA=.true.) ! call ut%check(w, w_ref, tol=1e-5_rk, msg='test_matmul8.8') ! w = matmul(A,v, option='m8', transA=.true.) ! call ut%check(w, w_ref, tol=1e-5_rk, msg='test_matmul8.9') w = matmul ( A , v , transA = . true ., nblock = 4 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul8.10' ) w = matmul ( A , v , option = 'm1' , transA = . true ., nblock = 4 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul8.11' ) w = matmul ( A , v , option = 'm2' , transA = . true ., nblock = 4 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul8.12' ) w = matmul ( A , v , option = 'm3' , transA = . true ., nblock = 4 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul8.13' ) w = matmul ( A , v , option = 'm4' , transA = . true ., nblock = 4 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul8.14' ) w = matmul ( A , v , option = 'm5' , transA = . true ., nblock = 4 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul8.15' ) w = matmul ( A , v , option = 'm6' , transA = . true ., nblock = 4 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul8.16' ) ! w = matmul(A,v, option='m7', transA=.true., nblock=4) ! call ut%check(w, w_ref, tol=1e-5_rk, msg='test_matmul8.17') ! w = matmul(A,v, option='m8', transA=.true., nblock=4) ! call ut%check(w, w_ref, tol=1e-5_rk, msg='test_matmul8.18') end program test_matmul8","tags":"","loc":"sourcefile/test6.f90.html"},{"title":"test13.f90 – ForMatmul","text":"This file depends on sourcefile~~test13.f90~~EfferentGraph sourcefile~test13.f90 test13.f90 sourcefile~formatmul.f90 formatmul.f90 sourcefile~test13.f90->sourcefile~formatmul.f90 sourcefile~formatmul_opts.f90 formatmul_opts.f90 sourcefile~formatmul.f90->sourcefile~formatmul_opts.f90 sourcefile~external_interfaces.f90 external_interfaces.f90 sourcefile~formatmul_opts.f90->sourcefile~external_interfaces.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program test_matmul15 use kinds use formatmul use forunittest implicit none real ( rk ), allocatable :: A (:,:), v (:) real ( rk ), allocatable :: w_ref (:), w (:) integer :: m , n , im type ( unit_test ) :: ut #if defined(USE_COARRAY) im = this_image () #else im = 1 #endif ! w(m) = A(n,m).v(n) m = 100 n = 300 allocate ( A ( n , m ), v ( n )) call random_number ( A ) call random_number ( v ) A = A * 10 0.0_rk v = v * 10 0.0_rk w_ref = matmul ( transpose ( A ), v ) w = matmul ( A , v , transA = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul15.1' ) w = matmul ( A , v , option = 'm1' , transA = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul15.2' ) w = matmul ( A , v , option = 'm2' , transA = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul15.3' ) w = matmul ( A , v , option = 'm3' , transA = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul15.4' ) w = matmul ( A , v , option = 'm4' , transA = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul15.5' ) w = matmul ( A , v , option = 'm5' , transA = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul15.6' ) w = matmul ( A , v , option = 'm6' , transA = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul15.7' ) ! w = matmul(A,v, option='m7', transA=.true., coarray=.true.) ! if (im==1) call ut%check(w, w_ref, tol=1e-5_rk, msg='test_matmul15.8') ! w = matmul(A,v, option='m8', transA=.true., coarray=.true.) ! if (im==1) call ut%check(w, w_ref, tol=1e-5_rk, msg='test_matmul15.9') end program test_matmul15","tags":"","loc":"sourcefile/test13.f90.html"},{"title":"test10.f90 – ForMatmul","text":"This file depends on sourcefile~~test10.f90~~EfferentGraph sourcefile~test10.f90 test10.f90 sourcefile~formatmul.f90 formatmul.f90 sourcefile~test10.f90->sourcefile~formatmul.f90 sourcefile~formatmul_opts.f90 formatmul_opts.f90 sourcefile~formatmul.f90->sourcefile~formatmul_opts.f90 sourcefile~external_interfaces.f90 external_interfaces.f90 sourcefile~formatmul_opts.f90->sourcefile~external_interfaces.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program test_matmul12 use kinds use formatmul use forunittest implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C_ref (:,:), C (:,:) integer :: m , n , o , im type ( unit_test ) :: ut #if defined(USE_COARRAY) im = this_image () #else im = 1 #endif ! C(m,o) = A(m,n).B(o,n) m = 500 n = 400 o = 300 allocate ( A ( m , n ), B ( o , n )) call random_number ( A ) call random_number ( B ) A = A * 10 0.0_rk B = B * 10 0.0_rk C_ref = matmul ( A , transpose ( B )) C = matmul ( A , B , transB = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul12.1' ) C = matmul ( A , B , option = 'm1' , transB = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul12.2' ) C = matmul ( A , B , option = 'm2' , transB = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul12.3' ) C = matmul ( A , B , option = 'm3' , transB = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul12.4' ) C = matmul ( A , B , option = 'm4' , transB = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul12.5' ) C = matmul ( A , B , option = 'm5' , transB = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul12.6' ) C = matmul ( A , B , option = 'm6' , transB = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul12.7' ) C = matmul ( A , B , option = 'm7' , transB = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul12.8' ) C = matmul ( A , B , option = 'm8' , transB = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul12.9' ) C = matmul ( A , B , option = 'm9' , transB = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul12.10' ) ! C = matmul(A,B, option='m10', transB=.true., coarray=.true.) ! if (im==1) call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul12.11') ! C = matmul(A,B, option='m11', transB=.true., coarray=.true.) ! if (im==1) call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul12.12') C = matmul ( A , B , option = 'm12' , transB = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul12.13' ) C = matmul ( A , B , option = 'm13' , transB = . true ., coarray = . true .) if ( im == 1 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul12.14' ) end program test_matmul12","tags":"","loc":"sourcefile/test10.f90.html"},{"title":"test5.f90 – ForMatmul","text":"This file depends on sourcefile~~test5.f90~~EfferentGraph sourcefile~test5.f90 test5.f90 sourcefile~formatmul.f90 formatmul.f90 sourcefile~test5.f90->sourcefile~formatmul.f90 sourcefile~formatmul_opts.f90 formatmul_opts.f90 sourcefile~formatmul.f90->sourcefile~formatmul_opts.f90 sourcefile~external_interfaces.f90 external_interfaces.f90 sourcefile~formatmul_opts.f90->sourcefile~external_interfaces.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program test_matmul7 use kinds use formatmul use forunittest implicit none real ( rk ), allocatable :: A (:,:), v (:) real ( rk ), allocatable :: w_ref (:), w (:) integer :: m , n type ( unit_test ) :: ut ! w(m) = A(m,n).v(n) m = 100 n = 300 allocate ( A ( m , n ), v ( n )) call random_number ( A ) call random_number ( v ) A = A * 10 0.0_rk v = v * 10 0.0_rk w_ref = matmul ( A , v ) w = matmul ( A , v ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.1' ) w = matmul ( A , v , option = 'm1' ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.2' ) w = matmul ( A , v , option = 'm2' ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.3' ) w = matmul ( A , v , option = 'm3' ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.4' ) w = matmul ( A , v , option = 'm4' ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.5' ) w = matmul ( A , v , option = 'm5' ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.6' ) w = matmul ( A , v , option = 'm6' ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.7' ) ! w = matmul(A,v, option='m7') ! call ut%check(w, w_ref, tol=1e-5_rk, msg='test_matmul7.8') ! w = matmul(A,v, option='m8') ! call ut%check(w, w_ref, tol=1e-5_rk, msg='test_matmul7.9') w = matmul ( A , v , nblock = 4 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.10' ) w = matmul ( A , v , option = 'm1' , nblock = 4 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.11' ) w = matmul ( A , v , option = 'm2' , nblock = 4 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.12' ) w = matmul ( A , v , option = 'm3' , nblock = 4 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.13' ) w = matmul ( A , v , option = 'm4' , nblock = 4 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.14' ) w = matmul ( A , v , option = 'm5' , nblock = 4 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.15' ) w = matmul ( A , v , option = 'm6' , nblock = 4 ) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.16' ) ! w = matmul(A,v, option='m7', nblock=4) ! call ut%check(w, w_ref, tol=1e-5_rk, msg='test_matmul7.17') ! w = matmul(A,v, option='m8', nblock=4) ! call ut%check(w, w_ref, tol=1e-5_rk, msg='test_matmul7.18') w = matmul ( A , v , option = 'm1' , transA = . false .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.19' ) w = matmul ( A , v , option = 'm2' , transA = . false .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.20' ) w = matmul ( A , v , option = 'm3' , transA = . false .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.21' ) w = matmul ( A , v , option = 'm4' , transA = . false .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.22' ) w = matmul ( A , v , option = 'm5' , transA = . false .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.23' ) w = matmul ( A , v , option = 'm6' , transA = . false .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.24' ) ! w = matmul(A,v, option='m7', transA=.false.) ! call ut%check(w, w_ref, tol=1e-5_rk, msg='test_matmul7.25') ! w = matmul(A,v, option='m8', transA=.false.) ! call ut%check(w, w_ref, tol=1e-5_rk, msg='test_matmul7.26') w = matmul ( A , v , nblock = 4 , transA = . false .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.27' ) w = matmul ( A , v , option = 'm1' , nblock = 4 , transA = . false .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.28' ) w = matmul ( A , v , option = 'm2' , nblock = 4 , transA = . false .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.29' ) w = matmul ( A , v , option = 'm3' , nblock = 4 , transA = . false .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.30' ) w = matmul ( A , v , option = 'm4' , nblock = 4 , transA = . false .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.31' ) w = matmul ( A , v , option = 'm5' , nblock = 4 , transA = . false .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.32' ) w = matmul ( A , v , option = 'm6' , nblock = 4 , transA = . false .) call ut % check ( w , w_ref , tol = 1e-5_rk , msg = 'test_matmul7.33' ) ! w = matmul(A,v, option='m7', nblock=4, transA=.false.) ! call ut%check(w, w_ref, tol=1e-5_rk, msg='test_matmul7.34') ! w = matmul(A,v, option='m8', nblock=4, transA=.false.) ! call ut%check(w, w_ref, tol=1e-5_rk, msg='test_matmul7.35') end program test_matmul7","tags":"","loc":"sourcefile/test5.f90.html"},{"title":"test2.f90 – ForMatmul","text":"This file depends on sourcefile~~test2.f90~~EfferentGraph sourcefile~test2.f90 test2.f90 sourcefile~formatmul.f90 formatmul.f90 sourcefile~test2.f90->sourcefile~formatmul.f90 sourcefile~formatmul_opts.f90 formatmul_opts.f90 sourcefile~formatmul.f90->sourcefile~formatmul_opts.f90 sourcefile~external_interfaces.f90 external_interfaces.f90 sourcefile~formatmul_opts.f90->sourcefile~external_interfaces.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program test_matmul4 use kinds use formatmul use forunittest implicit none real ( rk ), allocatable :: A (:,:), B (:,:) real ( rk ), allocatable :: C_ref (:,:), C (:,:) integer :: m , n , o type ( unit_test ) :: ut ! C(m,o) = A(n,m).B(n,o) m = 300 n = 200 o = 100 allocate ( A ( n , m ), B ( n , o )) call random_number ( A ) call random_number ( B ) A = A * 10 0.0_rk B = B * 10 0.0_rk C_ref = matmul ( transpose ( A ), B ) C = matmul ( A , B , transA = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.1' ) C = matmul ( A , B , option = 'm1' , transA = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.2' ) C = matmul ( A , B , option = 'm2' , transA = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.3' ) C = matmul ( A , B , option = 'm3' , transA = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.4' ) C = matmul ( A , B , option = 'm4' , transA = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.5' ) C = matmul ( A , B , option = 'm5' , transA = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.6' ) C = matmul ( A , B , option = 'm6' , transA = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.7' ) C = matmul ( A , B , option = 'm7' , transA = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.8' ) C = matmul ( A , B , option = 'm8' , transA = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.9' ) C = matmul ( A , B , option = 'm9' , transA = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.10' ) ! C = matmul(A,B, option='m10', transA=.true.) ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul4.11') ! C = matmul(A,B, option='m11', transA=.true.) ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul4.12') C = matmul ( A , B , option = 'm12' , transA = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.13' ) C = matmul ( A , B , option = 'm13' , transA = . true .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.14' ) C = matmul ( A , B , transA = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.15' ) C = matmul ( A , B , option = 'm1' , transA = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.16' ) C = matmul ( A , B , option = 'm2' , transA = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.17' ) C = matmul ( A , B , option = 'm3' , transA = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.18' ) C = matmul ( A , B , option = 'm4' , transA = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.19' ) C = matmul ( A , B , option = 'm5' , transA = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.20' ) C = matmul ( A , B , option = 'm6' , transA = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.21' ) C = matmul ( A , B , option = 'm7' , transA = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.22' ) C = matmul ( A , B , option = 'm8' , transA = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.23' ) C = matmul ( A , B , option = 'm9' , transA = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.24' ) ! C = matmul(A,B, option='m10', transA=.true., nblock=4) ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul4.25') ! C = matmul(A,B, option='m11', transA=.true., nblock=4) ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul4.26') C = matmul ( A , B , option = 'm12' , transA = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.27' ) C = matmul ( A , B , option = 'm13' , transA = . true ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.28' ) C = matmul ( A , B , transA = . true ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.29' ) C = matmul ( A , B , option = 'm1' , transA = . true ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.30' ) C = matmul ( A , B , option = 'm2' , transA = . true ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.31' ) C = matmul ( A , B , option = 'm3' , transA = . true ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.32' ) C = matmul ( A , B , option = 'm4' , transA = . true ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.33' ) C = matmul ( A , B , option = 'm5' , transA = . true ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.34' ) C = matmul ( A , B , option = 'm6' , transA = . true ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.35' ) C = matmul ( A , B , option = 'm7' , transA = . true ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.36' ) C = matmul ( A , B , option = 'm8' , transA = . true ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.37' ) C = matmul ( A , B , option = 'm9' , transA = . true ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.38' ) ! C = matmul(A,B, option='m10', transA=.true., transB=.false.) ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul4.39') ! C = matmul(A,B, option='m11', transA=.true., transB=.false.) ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul4.40') C = matmul ( A , B , option = 'm12' , transA = . true ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.41' ) C = matmul ( A , B , option = 'm13' , transA = . true ., transB = . false .) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.42' ) C = matmul ( A , B , transA = . true ., transB = . false ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.43' ) C = matmul ( A , B , option = 'm1' , transA = . true ., transB = . false ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.44' ) C = matmul ( A , B , option = 'm2' , transA = . true ., transB = . false ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.45' ) C = matmul ( A , B , option = 'm3' , transA = . true ., transB = . false ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.46' ) C = matmul ( A , B , option = 'm4' , transA = . true ., transB = . false ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.47' ) C = matmul ( A , B , option = 'm5' , transA = . true ., transB = . false ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.48' ) C = matmul ( A , B , option = 'm6' , transA = . true ., transB = . false ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.49' ) C = matmul ( A , B , option = 'm7' , transA = . true ., transB = . false ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.50' ) C = matmul ( A , B , option = 'm8' , transA = . true ., transB = . false ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.51' ) C = matmul ( A , B , option = 'm9' , transA = . true ., transB = . false ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.52' ) ! C = matmul(A,B, option='m10', transA=.true., transB=.false., nblock=4) ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul4.53') ! C = matmul(A,B, option='m11', transA=.true., transB=.false., nblock=4) ! call ut%check(C, C_ref, tol=1e-5_rk, msg='test_matmul4.54') C = matmul ( A , B , option = 'm12' , transA = . true ., transB = . false ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.55' ) C = matmul ( A , B , option = 'm13' , transA = . true ., transB = . false ., nblock = 4 ) call ut % check ( C , C_ref , tol = 1e-5_rk , msg = 'test_matmul4.56' ) end program test_matmul4","tags":"","loc":"sourcefile/test2.f90.html"}]}